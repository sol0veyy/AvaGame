"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mobx";
exports.ids = ["vendor-chunks/mobx"];
exports.modules = {

/***/ "(ssr)/./node_modules/mobx/dist/mobx.esm.js":
/*!********************************************!*\
  !*** ./node_modules/mobx/dist/mobx.esm.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $mobx: () => (/* binding */ $mobx),\n/* harmony export */   FlowCancellationError: () => (/* binding */ FlowCancellationError),\n/* harmony export */   ObservableMap: () => (/* binding */ ObservableMap),\n/* harmony export */   ObservableSet: () => (/* binding */ ObservableSet),\n/* harmony export */   Reaction: () => (/* binding */ Reaction),\n/* harmony export */   _allowStateChanges: () => (/* binding */ allowStateChanges),\n/* harmony export */   _allowStateChangesInsideComputed: () => (/* binding */ runInAction),\n/* harmony export */   _allowStateReadsEnd: () => (/* binding */ allowStateReadsEnd),\n/* harmony export */   _allowStateReadsStart: () => (/* binding */ allowStateReadsStart),\n/* harmony export */   _autoAction: () => (/* binding */ autoAction),\n/* harmony export */   _endAction: () => (/* binding */ _endAction),\n/* harmony export */   _getAdministration: () => (/* binding */ getAdministration),\n/* harmony export */   _getGlobalState: () => (/* binding */ getGlobalState),\n/* harmony export */   _interceptReads: () => (/* binding */ interceptReads),\n/* harmony export */   _isComputingDerivation: () => (/* binding */ isComputingDerivation),\n/* harmony export */   _resetGlobalState: () => (/* binding */ resetGlobalState),\n/* harmony export */   _startAction: () => (/* binding */ _startAction),\n/* harmony export */   action: () => (/* binding */ action),\n/* harmony export */   autorun: () => (/* binding */ autorun),\n/* harmony export */   comparer: () => (/* binding */ comparer),\n/* harmony export */   computed: () => (/* binding */ computed),\n/* harmony export */   configure: () => (/* binding */ configure),\n/* harmony export */   createAtom: () => (/* binding */ createAtom),\n/* harmony export */   defineProperty: () => (/* binding */ apiDefineProperty),\n/* harmony export */   entries: () => (/* binding */ entries),\n/* harmony export */   extendObservable: () => (/* binding */ extendObservable),\n/* harmony export */   flow: () => (/* binding */ flow),\n/* harmony export */   flowResult: () => (/* binding */ flowResult),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getAtom: () => (/* binding */ getAtom),\n/* harmony export */   getDebugName: () => (/* binding */ getDebugName),\n/* harmony export */   getDependencyTree: () => (/* binding */ getDependencyTree),\n/* harmony export */   getObserverTree: () => (/* binding */ getObserverTree),\n/* harmony export */   has: () => (/* binding */ has),\n/* harmony export */   intercept: () => (/* binding */ intercept),\n/* harmony export */   isAction: () => (/* binding */ isAction),\n/* harmony export */   isBoxedObservable: () => (/* binding */ isObservableValue),\n/* harmony export */   isComputed: () => (/* binding */ isComputed),\n/* harmony export */   isComputedProp: () => (/* binding */ isComputedProp),\n/* harmony export */   isFlow: () => (/* binding */ isFlow),\n/* harmony export */   isFlowCancellationError: () => (/* binding */ isFlowCancellationError),\n/* harmony export */   isObservable: () => (/* binding */ isObservable),\n/* harmony export */   isObservableArray: () => (/* binding */ isObservableArray),\n/* harmony export */   isObservableMap: () => (/* binding */ isObservableMap),\n/* harmony export */   isObservableObject: () => (/* binding */ isObservableObject),\n/* harmony export */   isObservableProp: () => (/* binding */ isObservableProp),\n/* harmony export */   isObservableSet: () => (/* binding */ isObservableSet),\n/* harmony export */   keys: () => (/* binding */ keys),\n/* harmony export */   makeAutoObservable: () => (/* binding */ makeAutoObservable),\n/* harmony export */   makeObservable: () => (/* binding */ makeObservable),\n/* harmony export */   observable: () => (/* binding */ observable),\n/* harmony export */   observe: () => (/* binding */ observe),\n/* harmony export */   onBecomeObserved: () => (/* binding */ onBecomeObserved),\n/* harmony export */   onBecomeUnobserved: () => (/* binding */ onBecomeUnobserved),\n/* harmony export */   onReactionError: () => (/* binding */ onReactionError),\n/* harmony export */   override: () => (/* binding */ override),\n/* harmony export */   ownKeys: () => (/* binding */ apiOwnKeys),\n/* harmony export */   reaction: () => (/* binding */ reaction),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   runInAction: () => (/* binding */ runInAction),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   spy: () => (/* binding */ spy),\n/* harmony export */   toJS: () => (/* binding */ toJS),\n/* harmony export */   trace: () => (/* binding */ trace),\n/* harmony export */   transaction: () => (/* binding */ transaction),\n/* harmony export */   untracked: () => (/* binding */ untracked),\n/* harmony export */   values: () => (/* binding */ values),\n/* harmony export */   when: () => (/* binding */ when)\n/* harmony export */ });\nvar niceErrors = {\n    0: \"Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'\",\n    1: function _(annotationType, key) {\n        return \"Cannot apply '\" + annotationType + \"' to '\" + key.toString() + \"': Field not found.\";\n    },\n    /*\r\n  2(prop) {\r\n      return `invalid decorator for '${prop.toString()}'`\r\n  },\r\n  3(prop) {\r\n      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`\r\n  },\r\n  4(prop) {\r\n      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`\r\n  },\r\n  */ 5: \"'keys()' can only be used on observable objects, arrays, sets and maps\",\n    6: \"'values()' can only be used on observable objects, arrays, sets and maps\",\n    7: \"'entries()' can only be used on observable objects, arrays and maps\",\n    8: \"'set()' can only be used on observable objects, arrays and maps\",\n    9: \"'remove()' can only be used on observable objects, arrays and maps\",\n    10: \"'has()' can only be used on observable objects, arrays and maps\",\n    11: \"'get()' can only be used on observable objects, arrays and maps\",\n    12: \"Invalid annotation\",\n    13: \"Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)\",\n    14: \"Intercept handlers should return nothing or a change object\",\n    15: \"Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)\",\n    16: \"Modification exception: the internal structure of an observable array was changed.\",\n    17: function _(index, length) {\n        return \"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + length;\n    },\n    18: \"mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js\",\n    19: function _(other) {\n        return \"Cannot initialize from classes that inherit from Map: \" + other.constructor.name;\n    },\n    20: function _(other) {\n        return \"Cannot initialize map from \" + other;\n    },\n    21: function _(dataStructure) {\n        return \"Cannot convert to map from '\" + dataStructure + \"'\";\n    },\n    22: \"mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js\",\n    23: \"It is not possible to get index atoms from arrays\",\n    24: function _(thing) {\n        return \"Cannot obtain administration from \" + thing;\n    },\n    25: function _(property, name) {\n        return \"the entry '\" + property + \"' does not exist in the observable map '\" + name + \"'\";\n    },\n    26: \"please specify a property\",\n    27: function _(property, name) {\n        return \"no observable property '\" + property.toString() + \"' found on the observable object '\" + name + \"'\";\n    },\n    28: function _(thing) {\n        return \"Cannot obtain atom from \" + thing;\n    },\n    29: \"Expecting some object\",\n    30: \"invalid action stack. did you forget to finish an action?\",\n    31: \"missing option for computed: get\",\n    32: function _(name, derivation) {\n        return \"Cycle detected in computation \" + name + \": \" + derivation;\n    },\n    33: function _(name) {\n        return \"The setter of computed value '\" + name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\";\n    },\n    34: function _(name) {\n        return \"[ComputedValue '\" + name + \"'] It is not possible to assign a new value to a computed value.\";\n    },\n    35: \"There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`\",\n    36: \"isolateGlobalState should be called before MobX is running any reactions\",\n    37: function _(method) {\n        return \"[mobx] `observableArray.\" + method + \"()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice().\" + method + \"()` instead\";\n    },\n    38: \"'ownKeys()' can only be used on observable objects\",\n    39: \"'defineProperty()' can only be used on observable objects\"\n};\nvar errors =  true ? niceErrors : 0;\nfunction die(error) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (true) {\n        var e = typeof error === \"string\" ? error : errors[error];\n        if (typeof e === \"function\") e = e.apply(null, args);\n        throw new Error(\"[MobX] \" + e);\n    }\n    throw new Error(typeof error === \"number\" ? \"[MobX] minified error nr: \" + error + (args.length ? \" \" + args.map(String).join(\",\") : \"\") + \". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts\" : \"[MobX] \" + error);\n}\nvar mockGlobal = {};\nfunction getGlobal() {\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    if (false) {}\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    return mockGlobal;\n}\n// We shorten anything used > 5 times\nvar assign = Object.assign;\nvar getDescriptor = Object.getOwnPropertyDescriptor;\nvar defineProperty = Object.defineProperty;\nvar objectPrototype = Object.prototype;\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nvar EMPTY_OBJECT = {};\nObject.freeze(EMPTY_OBJECT);\nvar hasProxy = typeof Proxy !== \"undefined\";\nvar plainObjectString = /*#__PURE__*/ Object.toString();\nfunction assertProxies() {\n    if (!hasProxy) {\n        die( true ? \"`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`\" : 0);\n    }\n}\nfunction warnAboutProxyRequirement(msg) {\n    if ( true && globalState.verifyProxies) {\n        die(\"MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to \" + msg);\n    }\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\n/**\r\n * Makes sure that the provided function is invoked at most once.\r\n */ function once(func) {\n    var invoked = false;\n    return function() {\n        if (invoked) {\n            return;\n        }\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() {};\nfunction isFunction(fn) {\n    return typeof fn === \"function\";\n}\nfunction isStringish(value) {\n    var t = typeof value;\n    switch(t){\n        case \"string\":\n        case \"symbol\":\n        case \"number\":\n            return true;\n    }\n    return false;\n}\nfunction isObject(value) {\n    return value !== null && typeof value === \"object\";\n}\nfunction isPlainObject(value) {\n    if (!isObject(value)) {\n        return false;\n    }\n    var proto = Object.getPrototypeOf(value);\n    if (proto == null) {\n        return true;\n    }\n    var protoConstructor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n    return typeof protoConstructor === \"function\" && protoConstructor.toString() === plainObjectString;\n}\n// https://stackoverflow.com/a/37865170\nfunction isGenerator(obj) {\n    var constructor = obj == null ? void 0 : obj.constructor;\n    if (!constructor) {\n        return false;\n    }\n    if (\"GeneratorFunction\" === constructor.name || \"GeneratorFunction\" === constructor.displayName) {\n        return true;\n    }\n    return false;\n}\nfunction addHiddenProp(object, propName, value) {\n    defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction createInstanceofPredicate(name, theClass) {\n    var propName = \"isMobX\" + name;\n    theClass.prototype[propName] = true;\n    return function(x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\nfunction isES6Map(thing) {\n    return thing instanceof Map;\n}\nfunction isES6Set(thing) {\n    return thing instanceof Set;\n}\nvar hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== \"undefined\";\n/**\r\n * Returns the following: own enumerable keys and symbols.\r\n */ function getPlainObjectKeys(object) {\n    var keys = Object.keys(object);\n    // Not supported in IE, so there are not going to be symbol props anyway...\n    if (!hasGetOwnPropertySymbols) {\n        return keys;\n    }\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (!symbols.length) {\n        return keys;\n    }\n    return [].concat(keys, symbols.filter(function(s) {\n        return objectPrototype.propertyIsEnumerable.call(object, s);\n    }));\n}\n// From Immer utils\n// Returns all own keys, including non-enumerable and symbolic\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {\n    return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} : /* istanbul ignore next */ Object.getOwnPropertyNames;\nfunction stringifyKey(key) {\n    if (typeof key === \"string\") {\n        return key;\n    }\n    if (typeof key === \"symbol\") {\n        return key.toString();\n    }\n    return new String(key).toString();\n}\nfunction toPrimitive(value) {\n    return value === null ? null : typeof value === \"object\" ? \"\" + value : value;\n}\nfunction hasProp(target, prop) {\n    return objectPrototype.hasOwnProperty.call(target, prop);\n}\n// From Immer utils\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {\n    // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n    var res = {};\n    // Note: without polyfill for ownKeys, symbols won't be picked up\n    ownKeys(target).forEach(function(key) {\n        res[key] = getDescriptor(target, key);\n    });\n    return res;\n};\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _assertThisInitialized(self1) {\n    if (self1 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self1;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nvar storedAnnotationsSymbol = /*#__PURE__*/ Symbol(\"mobx-stored-annotations\");\n/**\r\n * Creates a function that acts as\r\n * - decorator\r\n * - annotation object\r\n */ function createDecoratorAnnotation(annotation) {\n    function decorator(target, property) {\n        storeAnnotation(target, property, annotation);\n    }\n    return Object.assign(decorator, annotation);\n}\n/**\r\n * Stores annotation to prototype,\r\n * so it can be inspected later by `makeObservable` called from constructor\r\n */ function storeAnnotation(prototype, key, annotation) {\n    if (!hasProp(prototype, storedAnnotationsSymbol)) {\n        addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));\n    }\n    // @override must override something\n    if ( true && isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {\n        var fieldName = prototype.constructor.name + \".prototype.\" + key.toString();\n        die(\"'\" + fieldName + \"' is decorated with 'override', \" + \"but no such decorated member was found on prototype.\");\n    }\n    // Cannot re-decorate\n    assertNotDecorated(prototype, annotation, key);\n    // Ignore override\n    if (!isOverride(annotation)) {\n        prototype[storedAnnotationsSymbol][key] = annotation;\n    }\n}\nfunction assertNotDecorated(prototype, annotation, key) {\n    if ( true && !isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {\n        var fieldName = prototype.constructor.name + \".prototype.\" + key.toString();\n        var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;\n        var requestedAnnotationType = annotation.annotationType_;\n        die(\"Cannot apply '@\" + requestedAnnotationType + \"' to '\" + fieldName + \"':\" + (\"\\nThe field is already decorated with '@\" + currentAnnotationType + \"'.\") + \"\\nRe-decorating fields is not allowed.\" + \"\\nUse '@override' decorator for methods overridden by subclass.\");\n    }\n}\n/**\r\n * Collects annotations from prototypes and stores them on target (instance)\r\n */ function collectStoredAnnotations(target) {\n    if (!hasProp(target, storedAnnotationsSymbol)) {\n        if ( true && !target[storedAnnotationsSymbol]) {\n            die(\"No annotations were passed to makeObservable, but no decorated members have been found either\");\n        }\n        // We need a copy as we will remove annotation from the list once it's applied.\n        addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));\n    }\n    return target[storedAnnotationsSymbol];\n}\nvar $mobx = /*#__PURE__*/ Symbol(\"mobx administration\");\nvar Atom = /*#__PURE__*/ function() {\n    // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed\n    /**\r\n   * Create a new atom. For debugging purposes it is recommended to give it a name.\r\n   * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.\r\n   */ function Atom(name_) {\n        if (name_ === void 0) {\n            name_ =  true ? \"Atom@\" + getNextId() : 0;\n        }\n        this.name_ = void 0;\n        this.isPendingUnobservation_ = false;\n        this.isBeingObserved_ = false;\n        this.observers_ = new Set();\n        this.diffValue_ = 0;\n        this.lastAccessedBy_ = 0;\n        this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;\n        this.onBOL = void 0;\n        this.onBUOL = void 0;\n        this.name_ = name_;\n    }\n    // onBecomeObservedListeners\n    var _proto = Atom.prototype;\n    _proto.onBO = function onBO() {\n        if (this.onBOL) {\n            this.onBOL.forEach(function(listener) {\n                return listener();\n            });\n        }\n    };\n    _proto.onBUO = function onBUO() {\n        if (this.onBUOL) {\n            this.onBUOL.forEach(function(listener) {\n                return listener();\n            });\n        }\n    } /**\r\n   * Invoke this method to notify mobx that your atom has been used somehow.\r\n   * Returns true if there is currently a reactive context.\r\n   */ ;\n    _proto.reportObserved = function reportObserved$1() {\n        return reportObserved(this);\n    } /**\r\n   * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.\r\n   */ ;\n    _proto.reportChanged = function reportChanged() {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    _proto.toString = function toString() {\n        return this.name_;\n    };\n    return Atom;\n}();\nvar isAtom = /*#__PURE__*/ createInstanceofPredicate(\"Atom\", Atom);\nfunction createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n    if (onBecomeObservedHandler === void 0) {\n        onBecomeObservedHandler = noop;\n    }\n    if (onBecomeUnobservedHandler === void 0) {\n        onBecomeUnobservedHandler = noop;\n    }\n    var atom = new Atom(name);\n    // default `noop` listener will not initialize the hook Set\n    if (onBecomeObservedHandler !== noop) {\n        onBecomeObserved(atom, onBecomeObservedHandler);\n    }\n    if (onBecomeUnobservedHandler !== noop) {\n        onBecomeUnobserved(atom, onBecomeUnobservedHandler);\n    }\n    return atom;\n}\nfunction identityComparer(a, b) {\n    return a === b;\n}\nfunction structuralComparer(a, b) {\n    return deepEqual(a, b);\n}\nfunction shallowComparer(a, b) {\n    return deepEqual(a, b, 1);\n}\nfunction defaultComparer(a, b) {\n    if (Object.is) {\n        return Object.is(a, b);\n    }\n    return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;\n}\nvar comparer = {\n    identity: identityComparer,\n    structural: structuralComparer,\n    \"default\": defaultComparer,\n    shallow: shallowComparer\n};\nfunction deepEnhancer(v, _, name) {\n    // it is an observable already, done\n    if (isObservable(v)) {\n        return v;\n    }\n    // something that can be converted and mutated?\n    if (Array.isArray(v)) {\n        return observable.array(v, {\n            name: name\n        });\n    }\n    if (isPlainObject(v)) {\n        return observable.object(v, undefined, {\n            name: name\n        });\n    }\n    if (isES6Map(v)) {\n        return observable.map(v, {\n            name: name\n        });\n    }\n    if (isES6Set(v)) {\n        return observable.set(v, {\n            name: name\n        });\n    }\n    if (typeof v === \"function\" && !isAction(v) && !isFlow(v)) {\n        if (isGenerator(v)) {\n            return flow(v);\n        } else {\n            return autoAction(name, v);\n        }\n    }\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (v === undefined || v === null) {\n        return v;\n    }\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) {\n        return v;\n    }\n    if (Array.isArray(v)) {\n        return observable.array(v, {\n            name: name,\n            deep: false\n        });\n    }\n    if (isPlainObject(v)) {\n        return observable.object(v, undefined, {\n            name: name,\n            deep: false\n        });\n    }\n    if (isES6Map(v)) {\n        return observable.map(v, {\n            name: name,\n            deep: false\n        });\n    }\n    if (isES6Set(v)) {\n        return observable.set(v, {\n            name: name,\n            deep: false\n        });\n    }\n    if (true) {\n        die(\"The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets\");\n    }\n}\nfunction referenceEnhancer(newValue) {\n    // never turn into an observable\n    return newValue;\n}\nfunction refStructEnhancer(v, oldValue) {\n    if ( true && isObservable(v)) {\n        die(\"observable.struct should not be used with observable values\");\n    }\n    if (deepEqual(v, oldValue)) {\n        return oldValue;\n    }\n    return v;\n}\nvar OVERRIDE = \"override\";\nvar override = /*#__PURE__*/ createDecoratorAnnotation({\n    annotationType_: OVERRIDE,\n    make_: make_,\n    extend_: extend_\n});\nfunction isOverride(annotation) {\n    return annotation.annotationType_ === OVERRIDE;\n}\nfunction make_(adm, key) {\n    // Must not be plain object\n    if ( true && adm.isPlainObject_) {\n        die(\"Cannot apply '\" + this.annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + this.annotationType_ + \"' cannot be used on plain objects.\"));\n    }\n    // Must override something\n    if ( true && !hasProp(adm.appliedAnnotations_, key)) {\n        die(\"'\" + adm.name_ + \".\" + key.toString() + \"' is annotated with '\" + this.annotationType_ + \"', \" + \"but no such annotated member was found on prototype.\");\n    }\n    return 0 /* Cancel */ ;\n}\nfunction extend_(adm, key, descriptor, proxyTrap) {\n    die(\"'\" + this.annotationType_ + \"' can only be used with 'makeObservable'\");\n}\nfunction createActionAnnotation(name, options) {\n    return {\n        annotationType_: name,\n        options_: options,\n        make_: make_$1,\n        extend_: extend_$1\n    };\n}\nfunction make_$1(adm, key, descriptor, source) {\n    var _this$options_;\n    // bound\n    if ((_this$options_ = this.options_) != null && _this$options_.bound) {\n        return this.extend_(adm, key, descriptor, false) === null ? 0 /* Cancel */  : 1 /* Break */ ;\n    }\n    // own\n    if (source === adm.target_) {\n        return this.extend_(adm, key, descriptor, false) === null ? 0 /* Cancel */  : 2 /* Continue */ ;\n    }\n    // prototype\n    if (isAction(descriptor.value)) {\n        // A prototype could have been annotated already by other constructor,\n        // rest of the proto chain must be annotated already\n        return 1 /* Break */ ;\n    }\n    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);\n    defineProperty(source, key, actionDescriptor);\n    return 2 /* Continue */ ;\n}\nfunction extend_$1(adm, key, descriptor, proxyTrap) {\n    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);\n    return adm.defineProperty_(key, actionDescriptor, proxyTrap);\n}\nfunction assertActionDescriptor(adm, _ref, key, _ref2) {\n    var annotationType_ = _ref.annotationType_;\n    var value = _ref2.value;\n    if ( true && !isFunction(value)) {\n        die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' can only be used on properties with a function value.\"));\n    }\n}\nfunction createActionDescriptor(adm, annotation, key, descriptor, // provides ability to disable safeDescriptors for prototypes\nsafeDescriptors) {\n    var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;\n    if (safeDescriptors === void 0) {\n        safeDescriptors = globalState.safeDescriptors;\n    }\n    assertActionDescriptor(adm, annotation, key, descriptor);\n    var value = descriptor.value;\n    if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {\n        var _adm$proxy_;\n        value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);\n    }\n    return {\n        value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false, // https://github.com/mobxjs/mobx/discussions/3140\n        (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : undefined),\n        // Non-configurable for classes\n        // prevents accidental field redefinition in subclass\n        configurable: safeDescriptors ? adm.isPlainObject_ : true,\n        // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058\n        enumerable: false,\n        // Non-obsevable, therefore non-writable\n        // Also prevents rewriting in subclass constructor\n        writable: safeDescriptors ? false : true\n    };\n}\nfunction createFlowAnnotation(name, options) {\n    return {\n        annotationType_: name,\n        options_: options,\n        make_: make_$2,\n        extend_: extend_$2\n    };\n}\nfunction make_$2(adm, key, descriptor, source) {\n    var _this$options_;\n    // own\n    if (source === adm.target_) {\n        return this.extend_(adm, key, descriptor, false) === null ? 0 /* Cancel */  : 2 /* Continue */ ;\n    }\n    // prototype\n    // bound - must annotate protos to support super.flow()\n    if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {\n        if (this.extend_(adm, key, descriptor, false) === null) {\n            return 0 /* Cancel */ ;\n        }\n    }\n    if (isFlow(descriptor.value)) {\n        // A prototype could have been annotated already by other constructor,\n        // rest of the proto chain must be annotated already\n        return 1 /* Break */ ;\n    }\n    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);\n    defineProperty(source, key, flowDescriptor);\n    return 2 /* Continue */ ;\n}\nfunction extend_$2(adm, key, descriptor, proxyTrap) {\n    var _this$options_2;\n    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);\n    return adm.defineProperty_(key, flowDescriptor, proxyTrap);\n}\nfunction assertFlowDescriptor(adm, _ref, key, _ref2) {\n    var annotationType_ = _ref.annotationType_;\n    var value = _ref2.value;\n    if ( true && !isFunction(value)) {\n        die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' can only be used on properties with a generator function value.\"));\n    }\n}\nfunction createFlowDescriptor(adm, annotation, key, descriptor, bound, // provides ability to disable safeDescriptors for prototypes\nsafeDescriptors) {\n    if (safeDescriptors === void 0) {\n        safeDescriptors = globalState.safeDescriptors;\n    }\n    assertFlowDescriptor(adm, annotation, key, descriptor);\n    var value = descriptor.value;\n    // In case of flow.bound, the descriptor can be from already annotated prototype\n    if (!isFlow(value)) {\n        value = flow(value);\n    }\n    if (bound) {\n        var _adm$proxy_;\n        // We do not keep original function around, so we bind the existing flow\n        value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);\n        // This is normally set by `flow`, but `bind` returns new function...\n        value.isMobXFlow = true;\n    }\n    return {\n        value: value,\n        // Non-configurable for classes\n        // prevents accidental field redefinition in subclass\n        configurable: safeDescriptors ? adm.isPlainObject_ : true,\n        // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058\n        enumerable: false,\n        // Non-obsevable, therefore non-writable\n        // Also prevents rewriting in subclass constructor\n        writable: safeDescriptors ? false : true\n    };\n}\nfunction createComputedAnnotation(name, options) {\n    return {\n        annotationType_: name,\n        options_: options,\n        make_: make_$3,\n        extend_: extend_$3\n    };\n}\nfunction make_$3(adm, key, descriptor) {\n    return this.extend_(adm, key, descriptor, false) === null ? 0 /* Cancel */  : 1 /* Break */ ;\n}\nfunction extend_$3(adm, key, descriptor, proxyTrap) {\n    assertComputedDescriptor(adm, this, key, descriptor);\n    return adm.defineComputedProperty_(key, _extends({}, this.options_, {\n        get: descriptor.get,\n        set: descriptor.set\n    }), proxyTrap);\n}\nfunction assertComputedDescriptor(adm, _ref, key, _ref2) {\n    var annotationType_ = _ref.annotationType_;\n    var get = _ref2.get;\n    if ( true && !get) {\n        die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' can only be used on getter(+setter) properties.\"));\n    }\n}\nfunction createObservableAnnotation(name, options) {\n    return {\n        annotationType_: name,\n        options_: options,\n        make_: make_$4,\n        extend_: extend_$4\n    };\n}\nfunction make_$4(adm, key, descriptor) {\n    return this.extend_(adm, key, descriptor, false) === null ? 0 /* Cancel */  : 1 /* Break */ ;\n}\nfunction extend_$4(adm, key, descriptor, proxyTrap) {\n    var _this$options_$enhanc, _this$options_;\n    assertObservableDescriptor(adm, this, key, descriptor);\n    return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);\n}\nfunction assertObservableDescriptor(adm, _ref, key, descriptor) {\n    var annotationType_ = _ref.annotationType_;\n    if ( true && !(\"value\" in descriptor)) {\n        die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' cannot be used on getter/setter properties\"));\n    }\n}\nvar AUTO = \"true\";\nvar autoAnnotation = /*#__PURE__*/ createAutoAnnotation();\nfunction createAutoAnnotation(options) {\n    return {\n        annotationType_: AUTO,\n        options_: options,\n        make_: make_$5,\n        extend_: extend_$5\n    };\n}\nfunction make_$5(adm, key, descriptor, source) {\n    var _this$options_3, _this$options_4;\n    // getter -> computed\n    if (descriptor.get) {\n        return computed.make_(adm, key, descriptor, source);\n    }\n    // lone setter -> action setter\n    if (descriptor.set) {\n        // TODO make action applicable to setter and delegate to action.make_\n        var set = createAction(key.toString(), descriptor.set);\n        // own\n        if (source === adm.target_) {\n            return adm.defineProperty_(key, {\n                configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,\n                set: set\n            }) === null ? 0 /* Cancel */  : 2 /* Continue */ ;\n        }\n        // proto\n        defineProperty(source, key, {\n            configurable: true,\n            set: set\n        });\n        return 2 /* Continue */ ;\n    }\n    // function on proto -> autoAction/flow\n    if (source !== adm.target_ && typeof descriptor.value === \"function\") {\n        var _this$options_2;\n        if (isGenerator(descriptor.value)) {\n            var _this$options_;\n            var flowAnnotation = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;\n            return flowAnnotation.make_(adm, key, descriptor, source);\n        }\n        var actionAnnotation = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;\n        return actionAnnotation.make_(adm, key, descriptor, source);\n    }\n    // other -> observable\n    // Copy props from proto as well, see test:\n    // \"decorate should work with Object.create\"\n    var observableAnnotation = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;\n    // if function respect autoBind option\n    if (typeof descriptor.value === \"function\" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {\n        var _adm$proxy_;\n        descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);\n    }\n    return observableAnnotation.make_(adm, key, descriptor, source);\n}\nfunction extend_$5(adm, key, descriptor, proxyTrap) {\n    var _this$options_5, _this$options_6;\n    // getter -> computed\n    if (descriptor.get) {\n        return computed.extend_(adm, key, descriptor, proxyTrap);\n    }\n    // lone setter -> action setter\n    if (descriptor.set) {\n        // TODO make action applicable to setter and delegate to action.extend_\n        return adm.defineProperty_(key, {\n            configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,\n            set: createAction(key.toString(), descriptor.set)\n        }, proxyTrap);\n    }\n    // other -> observable\n    // if function respect autoBind option\n    if (typeof descriptor.value === \"function\" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {\n        var _adm$proxy_2;\n        descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);\n    }\n    var observableAnnotation = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;\n    return observableAnnotation.extend_(adm, key, descriptor, proxyTrap);\n}\nvar OBSERVABLE = \"observable\";\nvar OBSERVABLE_REF = \"observable.ref\";\nvar OBSERVABLE_SHALLOW = \"observable.shallow\";\nvar OBSERVABLE_STRUCT = \"observable.struct\";\n// Predefined bags of create observable options, to avoid allocating temporarily option objects\n// in the majority of cases\nvar defaultCreateObservableOptions = {\n    deep: true,\n    name: undefined,\n    defaultDecorator: undefined,\n    proxy: true\n};\nObject.freeze(defaultCreateObservableOptions);\nfunction asCreateObservableOptions(thing) {\n    return thing || defaultCreateObservableOptions;\n}\nvar observableAnnotation = /*#__PURE__*/ createObservableAnnotation(OBSERVABLE);\nvar observableRefAnnotation = /*#__PURE__*/ createObservableAnnotation(OBSERVABLE_REF, {\n    enhancer: referenceEnhancer\n});\nvar observableShallowAnnotation = /*#__PURE__*/ createObservableAnnotation(OBSERVABLE_SHALLOW, {\n    enhancer: shallowEnhancer\n});\nvar observableStructAnnotation = /*#__PURE__*/ createObservableAnnotation(OBSERVABLE_STRUCT, {\n    enhancer: refStructEnhancer\n});\nvar observableDecoratorAnnotation = /*#__PURE__*/ createDecoratorAnnotation(observableAnnotation);\nfunction getEnhancerFromOptions(options) {\n    return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);\n}\nfunction getAnnotationFromOptions(options) {\n    var _options$defaultDecor;\n    return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : undefined;\n}\nfunction getEnhancerFromAnnotation(annotation) {\n    var _annotation$options_$, _annotation$options_;\n    return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;\n}\n/**\r\n * Turns an object, array or function into a reactive structure.\r\n * @param v the value which should become observable.\r\n */ function createObservable(v, arg2, arg3) {\n    // @observable someProp;\n    if (isStringish(arg2)) {\n        storeAnnotation(v, arg2, observableAnnotation);\n        return;\n    }\n    // already observable - ignore\n    if (isObservable(v)) {\n        return v;\n    }\n    // plain object\n    if (isPlainObject(v)) {\n        return observable.object(v, arg2, arg3);\n    }\n    // Array\n    if (Array.isArray(v)) {\n        return observable.array(v, arg2);\n    }\n    // Map\n    if (isES6Map(v)) {\n        return observable.map(v, arg2);\n    }\n    // Set\n    if (isES6Set(v)) {\n        return observable.set(v, arg2);\n    }\n    // other object - ignore\n    if (typeof v === \"object\" && v !== null) {\n        return v;\n    }\n    // anything else\n    return observable.box(v, arg2);\n}\nassign(createObservable, observableDecoratorAnnotation);\nvar observableFactories = {\n    box: function box(value, options) {\n        var o = asCreateObservableOptions(options);\n        return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);\n    },\n    array: function array(initialValues, options) {\n        var o = asCreateObservableOptions(options);\n        return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);\n    },\n    map: function map(initialValues, options) {\n        var o = asCreateObservableOptions(options);\n        return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);\n    },\n    set: function set(initialValues, options) {\n        var o = asCreateObservableOptions(options);\n        return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);\n    },\n    object: function object(props, decorators, options) {\n        return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);\n    },\n    ref: /*#__PURE__*/ createDecoratorAnnotation(observableRefAnnotation),\n    shallow: /*#__PURE__*/ createDecoratorAnnotation(observableShallowAnnotation),\n    deep: observableDecoratorAnnotation,\n    struct: /*#__PURE__*/ createDecoratorAnnotation(observableStructAnnotation)\n};\n// eslint-disable-next-line\nvar observable = /*#__PURE__*/ assign(createObservable, observableFactories);\nvar COMPUTED = \"computed\";\nvar COMPUTED_STRUCT = \"computed.struct\";\nvar computedAnnotation = /*#__PURE__*/ createComputedAnnotation(COMPUTED);\nvar computedStructAnnotation = /*#__PURE__*/ createComputedAnnotation(COMPUTED_STRUCT, {\n    equals: comparer.structural\n});\n/**\r\n * Decorator for class properties: @computed get value() { return expr; }.\r\n * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;\r\n */ var computed = function computed(arg1, arg2) {\n    if (isStringish(arg2)) {\n        // @computed\n        return storeAnnotation(arg1, arg2, computedAnnotation);\n    }\n    if (isPlainObject(arg1)) {\n        // @computed({ options })\n        return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));\n    }\n    // computed(expr, options?)\n    if (true) {\n        if (!isFunction(arg1)) {\n            die(\"First argument to `computed` should be an expression.\");\n        }\n        if (isFunction(arg2)) {\n            die(\"A setter as second argument is no longer supported, use `{ set: fn }` option instead\");\n        }\n    }\n    var opts = isPlainObject(arg2) ? arg2 : {};\n    opts.get = arg1;\n    opts.name || (opts.name = arg1.name || \"\"); /* for generated name */ \n    return new ComputedValue(opts);\n};\nObject.assign(computed, computedAnnotation);\ncomputed.struct = /*#__PURE__*/ createDecoratorAnnotation(computedStructAnnotation);\nvar _getDescriptor$config, _getDescriptor;\n// we don't use globalState for these in order to avoid possible issues with multiple\n// mobx versions\nvar currentActionId = 0;\nvar nextActionId = 1;\nvar isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /*#__PURE__*/ getDescriptor(function() {}, \"name\")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;\n// we can safely recycle this object\nvar tmpNameDescriptor = {\n    value: \"action\",\n    configurable: true,\n    writable: false,\n    enumerable: false\n};\nfunction createAction(actionName, fn, autoAction, ref) {\n    if (autoAction === void 0) {\n        autoAction = false;\n    }\n    if (true) {\n        if (!isFunction(fn)) {\n            die(\"`action` can only be invoked on functions\");\n        }\n        if (typeof actionName !== \"string\" || !actionName) {\n            die(\"actions should have valid names, got: '\" + actionName + \"'\");\n        }\n    }\n    function res() {\n        return executeAction(actionName, autoAction, fn, ref || this, arguments);\n    }\n    res.isMobxAction = true;\n    if (isFunctionNameConfigurable) {\n        tmpNameDescriptor.value = actionName;\n        defineProperty(res, \"name\", tmpNameDescriptor);\n    }\n    return res;\n}\nfunction executeAction(actionName, canRunAsDerivation, fn, scope, args) {\n    var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);\n    try {\n        return fn.apply(scope, args);\n    } catch (err) {\n        runInfo.error_ = err;\n        throw err;\n    } finally{\n        _endAction(runInfo);\n    }\n}\nfunction _startAction(actionName, canRunAsDerivation, // true for autoAction\nscope, args) {\n    var notifySpy_ =  true && isSpyEnabled() && !!actionName;\n    var startTime_ = 0;\n    if ( true && notifySpy_) {\n        startTime_ = Date.now();\n        var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;\n        spyReportStart({\n            type: ACTION,\n            name: actionName,\n            object: scope,\n            arguments: flattenedArgs\n        });\n    }\n    var prevDerivation_ = globalState.trackingDerivation;\n    var runAsAction = !canRunAsDerivation || !prevDerivation_;\n    startBatch();\n    var prevAllowStateChanges_ = globalState.allowStateChanges; // by default preserve previous allow\n    if (runAsAction) {\n        untrackedStart();\n        prevAllowStateChanges_ = allowStateChangesStart(true);\n    }\n    var prevAllowStateReads_ = allowStateReadsStart(true);\n    var runInfo = {\n        runAsAction_: runAsAction,\n        prevDerivation_: prevDerivation_,\n        prevAllowStateChanges_: prevAllowStateChanges_,\n        prevAllowStateReads_: prevAllowStateReads_,\n        notifySpy_: notifySpy_,\n        startTime_: startTime_,\n        actionId_: nextActionId++,\n        parentActionId_: currentActionId\n    };\n    currentActionId = runInfo.actionId_;\n    return runInfo;\n}\nfunction _endAction(runInfo) {\n    if (currentActionId !== runInfo.actionId_) {\n        die(30);\n    }\n    currentActionId = runInfo.parentActionId_;\n    if (runInfo.error_ !== undefined) {\n        globalState.suppressReactionErrors = true;\n    }\n    allowStateChangesEnd(runInfo.prevAllowStateChanges_);\n    allowStateReadsEnd(runInfo.prevAllowStateReads_);\n    endBatch();\n    if (runInfo.runAsAction_) {\n        untrackedEnd(runInfo.prevDerivation_);\n    }\n    if ( true && runInfo.notifySpy_) {\n        spyReportEnd({\n            time: Date.now() - runInfo.startTime_\n        });\n    }\n    globalState.suppressReactionErrors = false;\n}\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    try {\n        return func();\n    } finally{\n        allowStateChangesEnd(prev);\n    }\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar _Symbol$toPrimitive;\nvar CREATE = \"create\";\n_Symbol$toPrimitive = Symbol.toPrimitive;\nvar ObservableValue = /*#__PURE__*/ function(_Atom) {\n    _inheritsLoose(ObservableValue, _Atom);\n    function ObservableValue(value, enhancer, name_, notifySpy, equals) {\n        var _this;\n        if (name_ === void 0) {\n            name_ =  true ? \"ObservableValue@\" + getNextId() : 0;\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        if (equals === void 0) {\n            equals = comparer[\"default\"];\n        }\n        _this = _Atom.call(this, name_) || this;\n        _this.enhancer = void 0;\n        _this.name_ = void 0;\n        _this.equals = void 0;\n        _this.hasUnreportedChange_ = false;\n        _this.interceptors_ = void 0;\n        _this.changeListeners_ = void 0;\n        _this.value_ = void 0;\n        _this.dehancer = void 0;\n        _this.enhancer = enhancer;\n        _this.name_ = name_;\n        _this.equals = equals;\n        _this.value_ = enhancer(value, undefined, name_);\n        if ( true && notifySpy && isSpyEnabled()) {\n            // only notify spy if this is a stand-alone observable\n            spyReport({\n                type: CREATE,\n                object: _assertThisInitialized(_this),\n                observableKind: \"value\",\n                debugObjectName: _this.name_,\n                newValue: \"\" + _this.value_\n            });\n        }\n        return _this;\n    }\n    var _proto = ObservableValue.prototype;\n    _proto.dehanceValue = function dehanceValue(value) {\n        if (this.dehancer !== undefined) {\n            return this.dehancer(value);\n        }\n        return value;\n    };\n    _proto.set = function set(newValue) {\n        var oldValue = this.value_;\n        newValue = this.prepareNewValue_(newValue);\n        if (newValue !== globalState.UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if ( true && notifySpy) {\n                spyReportStart({\n                    type: UPDATE,\n                    object: this,\n                    observableKind: \"value\",\n                    debugObjectName: this.name_,\n                    newValue: newValue,\n                    oldValue: oldValue\n                });\n            }\n            this.setNewValue_(newValue);\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n        }\n    };\n    _proto.prepareNewValue_ = function prepareNewValue_(newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this,\n                type: UPDATE,\n                newValue: newValue\n            });\n            if (!change) {\n                return globalState.UNCHANGED;\n            }\n            newValue = change.newValue;\n        }\n        // apply modifier\n        newValue = this.enhancer(newValue, this.value_, this.name_);\n        return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;\n    };\n    _proto.setNewValue_ = function setNewValue_(newValue) {\n        var oldValue = this.value_;\n        this.value_ = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: UPDATE,\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    _proto.get = function get() {\n        this.reportObserved();\n        return this.dehanceValue(this.value_);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n        if (fireImmediately) {\n            listener({\n                observableKind: \"value\",\n                debugObjectName: this.name_,\n                object: this,\n                type: UPDATE,\n                newValue: this.value_,\n                oldValue: undefined\n            });\n        }\n        return registerListener(this, listener);\n    };\n    _proto.raw = function raw() {\n        // used by MST ot get undehanced value\n        return this.value_;\n    };\n    _proto.toJSON = function toJSON() {\n        return this.get();\n    };\n    _proto.toString = function toString() {\n        return this.name_ + \"[\" + this.value_ + \"]\";\n    };\n    _proto.valueOf = function valueOf() {\n        return toPrimitive(this.get());\n    };\n    _proto[_Symbol$toPrimitive] = function() {\n        return this.valueOf();\n    };\n    return ObservableValue;\n}(Atom);\nvar isObservableValue = /*#__PURE__*/ createInstanceofPredicate(\"ObservableValue\", ObservableValue);\nvar _Symbol$toPrimitive$1;\n/**\r\n * A node in the state dependency root that observes other nodes, and can be observed itself.\r\n *\r\n * ComputedValue will remember the result of the computation for the duration of the batch, or\r\n * while being observed.\r\n *\r\n * During this time it will recompute only when one of its direct dependencies changed,\r\n * but only when it is being accessed with `ComputedValue.get()`.\r\n *\r\n * Implementation description:\r\n * 1. First time it's being accessed it will compute and remember result\r\n *    give back remembered result until 2. happens\r\n * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.\r\n * 3. When it's being accessed, recompute if any shallow dependency changed.\r\n *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.\r\n *    go to step 2. either way\r\n *\r\n * If at any point it's outside batch and it isn't observed: reset everything and go to 1.\r\n */ _Symbol$toPrimitive$1 = Symbol.toPrimitive;\nvar ComputedValue = /*#__PURE__*/ function() {\n    // nodes we are looking at. Our value depends on these nodes\n    // during tracking it's an array with new observed observers\n    // to check for cycles\n    // N.B: unminified as it is used by MST\n    /**\r\n   * Create a new computed value based on a function expression.\r\n   *\r\n   * The `name` property is for debug purposes only.\r\n   *\r\n   * The `equals` property specifies the comparer function to use to determine if a newly produced\r\n   * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`\r\n   * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.\r\n   * Structural comparison can be convenient if you always produce a new aggregated object and\r\n   * don't want to notify observers if it is structurally the same.\r\n   * This is useful for working with vectors, mouse coordinates etc.\r\n   */ function ComputedValue(options) {\n        this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n        this.observing_ = [];\n        this.newObserving_ = null;\n        this.isBeingObserved_ = false;\n        this.isPendingUnobservation_ = false;\n        this.observers_ = new Set();\n        this.diffValue_ = 0;\n        this.runId_ = 0;\n        this.lastAccessedBy_ = 0;\n        this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n        this.unboundDepsCount_ = 0;\n        this.value_ = new CaughtException(null);\n        this.name_ = void 0;\n        this.triggeredBy_ = void 0;\n        this.isComputing_ = false;\n        this.isRunningSetter_ = false;\n        this.derivation = void 0;\n        this.setter_ = void 0;\n        this.isTracing_ = TraceMode.NONE;\n        this.scope_ = void 0;\n        this.equals_ = void 0;\n        this.requiresReaction_ = void 0;\n        this.keepAlive_ = void 0;\n        this.onBOL = void 0;\n        this.onBUOL = void 0;\n        if (!options.get) {\n            die(31);\n        }\n        this.derivation = options.get;\n        this.name_ = options.name || ( true ? \"ComputedValue@\" + getNextId() : 0);\n        if (options.set) {\n            this.setter_ = createAction( true ? this.name_ + \"-setter\" : 0, options.set);\n        }\n        this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer[\"default\"]);\n        this.scope_ = options.context;\n        this.requiresReaction_ = options.requiresReaction;\n        this.keepAlive_ = !!options.keepAlive;\n    }\n    var _proto = ComputedValue.prototype;\n    _proto.onBecomeStale_ = function onBecomeStale_() {\n        propagateMaybeChanged(this);\n    };\n    _proto.onBO = function onBO() {\n        if (this.onBOL) {\n            this.onBOL.forEach(function(listener) {\n                return listener();\n            });\n        }\n    };\n    _proto.onBUO = function onBUO() {\n        if (this.onBUOL) {\n            this.onBUOL.forEach(function(listener) {\n                return listener();\n            });\n        }\n    } /**\r\n   * Returns the current value of this computed value.\r\n   * Will evaluate its computation first if needed.\r\n   */ ;\n    _proto.get = function get() {\n        if (this.isComputing_) {\n            die(32, this.name_, this.derivation);\n        }\n        if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&\n        this.observers_.size === 0 && !this.keepAlive_) {\n            if (shouldCompute(this)) {\n                this.warnAboutUntrackedRead_();\n                startBatch(); // See perf test 'computed memoization'\n                this.value_ = this.computeValue_(false);\n                endBatch();\n            }\n        } else {\n            reportObserved(this);\n            if (shouldCompute(this)) {\n                var prevTrackingContext = globalState.trackingContext;\n                if (this.keepAlive_ && !prevTrackingContext) {\n                    globalState.trackingContext = this;\n                }\n                if (this.trackAndCompute()) {\n                    propagateChangeConfirmed(this);\n                }\n                globalState.trackingContext = prevTrackingContext;\n            }\n        }\n        var result = this.value_;\n        if (isCaughtException(result)) {\n            throw result.cause;\n        }\n        return result;\n    };\n    _proto.set = function set(value) {\n        if (this.setter_) {\n            if (this.isRunningSetter_) {\n                die(33, this.name_);\n            }\n            this.isRunningSetter_ = true;\n            try {\n                this.setter_.call(this.scope_, value);\n            } finally{\n                this.isRunningSetter_ = false;\n            }\n        } else {\n            die(34, this.name_);\n        }\n    };\n    _proto.trackAndCompute = function trackAndCompute() {\n        // N.B: unminified as it is used by MST\n        var oldValue = this.value_;\n        var wasSuspended = /* see #1208 */ this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;\n        var newValue = this.computeValue_(true);\n        var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);\n        if (changed) {\n            this.value_ = newValue;\n            if ( true && isSpyEnabled()) {\n                spyReport({\n                    observableKind: \"computed\",\n                    debugObjectName: this.name_,\n                    object: this.scope_,\n                    type: \"update\",\n                    oldValue: oldValue,\n                    newValue: newValue\n                });\n            }\n        }\n        return changed;\n    };\n    _proto.computeValue_ = function computeValue_(track) {\n        this.isComputing_ = true;\n        // don't allow state changes during computation\n        var prev = allowStateChangesStart(false);\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope_);\n        } else {\n            if (globalState.disableErrorBoundaries === true) {\n                res = this.derivation.call(this.scope_);\n            } else {\n                try {\n                    res = this.derivation.call(this.scope_);\n                } catch (e) {\n                    res = new CaughtException(e);\n                }\n            }\n        }\n        allowStateChangesEnd(prev);\n        this.isComputing_ = false;\n        return res;\n    };\n    _proto.suspend_ = function suspend_() {\n        if (!this.keepAlive_) {\n            clearObserving(this);\n            this.value_ = undefined; // don't hold on to computed value!\n            if ( true && this.isTracing_ !== TraceMode.NONE) {\n                console.log(\"[mobx.trace] Computed value '\" + this.name_ + \"' was suspended and it will recompute on the next access.\");\n            }\n        }\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function() {\n            // TODO: why is this in a different place than the spyReport() function? in all other observables it's called in the same place\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    observableKind: \"computed\",\n                    debugObjectName: _this.name_,\n                    type: UPDATE,\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {\n        if (false) {}\n        if (this.isTracing_ !== TraceMode.NONE) {\n            console.log(\"[mobx.trace] Computed value '\" + this.name_ + \"' is being read outside a reactive context. Doing a full recompute.\");\n        }\n        if (typeof this.requiresReaction_ === \"boolean\" ? this.requiresReaction_ : globalState.computedRequiresReaction) {\n            console.warn(\"[mobx] Computed value '\" + this.name_ + \"' is being read outside a reactive context. Doing a full recompute.\");\n        }\n    };\n    _proto.toString = function toString() {\n        return this.name_ + \"[\" + this.derivation.toString() + \"]\";\n    };\n    _proto.valueOf = function valueOf() {\n        return toPrimitive(this.get());\n    };\n    _proto[_Symbol$toPrimitive$1] = function() {\n        return this.valueOf();\n    };\n    return ComputedValue;\n}();\nvar isComputedValue = /*#__PURE__*/ createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState_;\n(function(IDerivationState_) {\n    // before being run or (outside batch and not being observed)\n    // at this point derivation is not holding any data about dependency tree\n    IDerivationState_[IDerivationState_[\"NOT_TRACKING_\"] = -1] = \"NOT_TRACKING_\";\n    // no shallow dependency changed since last computation\n    // won't recalculate derivation\n    // this is what makes mobx fast\n    IDerivationState_[IDerivationState_[\"UP_TO_DATE_\"] = 0] = \"UP_TO_DATE_\";\n    // some deep dependency changed, but don't know if shallow dependency changed\n    // will require to check first if UP_TO_DATE or POSSIBLY_STALE\n    // currently only ComputedValue will propagate POSSIBLY_STALE\n    //\n    // having this state is second big optimization:\n    // don't have to recompute on every dependency change, but only when it's needed\n    IDerivationState_[IDerivationState_[\"POSSIBLY_STALE_\"] = 1] = \"POSSIBLY_STALE_\";\n    // A shallow dependency has changed since last computation and the derivation\n    // will need to recompute when it's needed next.\n    IDerivationState_[IDerivationState_[\"STALE_\"] = 2] = \"STALE_\";\n})(IDerivationState_ || (IDerivationState_ = {}));\nvar TraceMode;\n(function(TraceMode) {\n    TraceMode[TraceMode[\"NONE\"] = 0] = \"NONE\";\n    TraceMode[TraceMode[\"LOG\"] = 1] = \"LOG\";\n    TraceMode[TraceMode[\"BREAK\"] = 2] = \"BREAK\";\n})(TraceMode || (TraceMode = {}));\nvar CaughtException = function CaughtException(cause) {\n    this.cause = void 0;\n    this.cause = cause;\n// Empty\n};\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\n/**\r\n * Finds out whether any dependency of the derivation has actually changed.\r\n * If dependenciesState is 1 then it will recalculate dependencies,\r\n * if any dependency changed it will propagate it by changing dependenciesState to 2.\r\n *\r\n * By iterating over the dependencies in the same order that they were reported and\r\n * stopping on the first change, all the recalculations are only called for ComputedValues\r\n * that will be tracked by derivation. That is because we assume that if the first x\r\n * dependencies of the derivation doesn't change then the derivation should run the same way\r\n * up until accessing x-th dependency.\r\n */ function shouldCompute(derivation) {\n    switch(derivation.dependenciesState_){\n        case IDerivationState_.UP_TO_DATE_:\n            return false;\n        case IDerivationState_.NOT_TRACKING_:\n        case IDerivationState_.STALE_:\n            return true;\n        case IDerivationState_.POSSIBLY_STALE_:\n            {\n                // state propagation can occur outside of action/reactive context #2195\n                var prevAllowStateReads = allowStateReadsStart(true);\n                var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.\n                var obs = derivation.observing_, l = obs.length;\n                for(var i = 0; i < l; i++){\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        if (globalState.disableErrorBoundaries) {\n                            obj.get();\n                        } else {\n                            try {\n                                obj.get();\n                            } catch (e) {\n                                // we are not interested in the value *or* exception at this moment, but if there is one, notify all\n                                untrackedEnd(prevUntracked);\n                                allowStateReadsEnd(prevAllowStateReads);\n                                return true;\n                            }\n                        }\n                        // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.\n                        // and `derivation` is an observer of `obj`\n                        // invariantShouldCompute(derivation)\n                        if (derivation.dependenciesState_ === IDerivationState_.STALE_) {\n                            untrackedEnd(prevUntracked);\n                            allowStateReadsEnd(prevAllowStateReads);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                allowStateReadsEnd(prevAllowStateReads);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null; // filter out actions inside computations\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n    if (false) {}\n    var hasObservers = atom.observers_.size > 0;\n    // Should not be possible to change observed state outside strict mode, except during initialization, see #563\n    if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === \"always\")) {\n        console.warn(\"[MobX] \" + (globalState.enforceActions ? \"Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: \" : \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: \") + atom.name_);\n    }\n}\nfunction checkIfStateReadsAreAllowed(observable) {\n    if ( true && !globalState.allowStateReads && globalState.observableRequiresReaction) {\n        console.warn(\"[mobx] Observable '\" + observable.name_ + \"' being read outside a reactive context.\");\n    }\n}\n/**\r\n * Executes the provided function `f` and tracks which observables are being accessed.\r\n * The tracking information is stored on the `derivation` object and the derivation is registered\r\n * as observer of any of the accessed observables.\r\n */ function trackDerivedFunction(derivation, f, context) {\n    var prevAllowStateReads = allowStateReadsStart(true);\n    // pre allocate array allocation + room for variation in deps\n    // array will be trimmed by bindDependencies\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving_ = new Array(derivation.observing_.length + 100);\n    derivation.unboundDepsCount_ = 0;\n    derivation.runId_ = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    globalState.inBatch++;\n    var result;\n    if (globalState.disableErrorBoundaries === true) {\n        result = f.call(context);\n    } else {\n        try {\n            result = f.call(context);\n        } catch (e) {\n            result = new CaughtException(e);\n        }\n    }\n    globalState.inBatch--;\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    warnAboutDerivationWithoutDependencies(derivation);\n    allowStateReadsEnd(prevAllowStateReads);\n    return result;\n}\nfunction warnAboutDerivationWithoutDependencies(derivation) {\n    if (false) {}\n    if (derivation.observing_.length !== 0) {\n        return;\n    }\n    if (typeof derivation.requiresObservable_ === \"boolean\" ? derivation.requiresObservable_ : globalState.reactionRequiresObservable) {\n        console.warn(\"[mobx] Derivation '\" + derivation.name_ + \"' is created/updated without reading any observable value.\");\n    }\n}\n/**\r\n * diffs newObserving with observing.\r\n * update observing to be newObserving with unique observables\r\n * notify observers that become observed/unobserved\r\n */ function bindDependencies(derivation) {\n    // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, \"INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1\");\n    var prevObserving = derivation.observing_;\n    var observing = derivation.observing_ = derivation.newObserving_;\n    var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;\n    // Go through all new observables and check diffValue: (this list can contain duplicates):\n    //   0: first occurrence, change to 1 and keep it\n    //   1: extra occurrence, drop it\n    var i0 = 0, l = derivation.unboundDepsCount_;\n    for(var i = 0; i < l; i++){\n        var dep = observing[i];\n        if (dep.diffValue_ === 0) {\n            dep.diffValue_ = 1;\n            if (i0 !== i) {\n                observing[i0] = dep;\n            }\n            i0++;\n        }\n        // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,\n        // not hitting the condition\n        if (dep.dependenciesState_ > lowestNewObservingDerivationState) {\n            lowestNewObservingDerivationState = dep.dependenciesState_;\n        }\n    }\n    observing.length = i0;\n    derivation.newObserving_ = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)\n    // Go through all old observables and check diffValue: (it is unique after last bindDependencies)\n    //   0: it's not in new observables, unobserve it\n    //   1: it keeps being observed, don't want to notify it. change to 0\n    l = prevObserving.length;\n    while(l--){\n        var _dep = prevObserving[l];\n        if (_dep.diffValue_ === 0) {\n            removeObserver(_dep, derivation);\n        }\n        _dep.diffValue_ = 0;\n    }\n    // Go through all new observables and check diffValue: (now it should be unique)\n    //   0: it was set to 0 in last loop. don't need to do anything.\n    //   1: it wasn't observed, let's observe it. set back to 0\n    while(i0--){\n        var _dep2 = observing[i0];\n        if (_dep2.diffValue_ === 1) {\n            _dep2.diffValue_ = 0;\n            addObserver(_dep2, derivation);\n        }\n    }\n    // Some new observed derivations may become stale during this derivation computation\n    // so they have had no chance to propagate staleness (#916)\n    if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {\n        derivation.dependenciesState_ = lowestNewObservingDerivationState;\n        derivation.onBecomeStale_();\n    }\n}\nfunction clearObserving(derivation) {\n    // invariant(globalState.inBatch > 0, \"INTERNAL ERROR clearObserving should be called only inside batch\");\n    var obs = derivation.observing_;\n    derivation.observing_ = [];\n    var i = obs.length;\n    while(i--){\n        removeObserver(obs[i], derivation);\n    }\n    derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    try {\n        return action();\n    } finally{\n        untrackedEnd(prev);\n    }\n}\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction allowStateReadsStart(allowStateReads) {\n    var prev = globalState.allowStateReads;\n    globalState.allowStateReads = allowStateReads;\n    return prev;\n}\nfunction allowStateReadsEnd(prev) {\n    globalState.allowStateReads = prev;\n}\n/**\r\n * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0\r\n *\r\n */ function changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n        return;\n    }\n    derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;\n    var obs = derivation.observing_;\n    var i = obs.length;\n    while(i--){\n        obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n    }\n}\n/**\r\n * These values will persist if global state is reset\r\n */ var persistentKeys = [\n    \"mobxGuid\",\n    \"spyListeners\",\n    \"enforceActions\",\n    \"computedRequiresReaction\",\n    \"reactionRequiresObservable\",\n    \"observableRequiresReaction\",\n    \"allowStateReads\",\n    \"disableErrorBoundaries\",\n    \"runId\",\n    \"UNCHANGED\",\n    \"useProxies\"\n];\nvar MobXGlobals = function MobXGlobals() {\n    this.version = 6;\n    this.UNCHANGED = {};\n    this.trackingDerivation = null;\n    this.trackingContext = null;\n    this.runId = 0;\n    this.mobxGuid = 0;\n    this.inBatch = 0;\n    this.pendingUnobservations = [];\n    this.pendingReactions = [];\n    this.isRunningReactions = false;\n    this.allowStateChanges = false;\n    this.allowStateReads = true;\n    this.enforceActions = true;\n    this.spyListeners = [];\n    this.globalReactionErrorHandlers = [];\n    this.computedRequiresReaction = false;\n    this.reactionRequiresObservable = false;\n    this.observableRequiresReaction = false;\n    this.disableErrorBoundaries = false;\n    this.suppressReactionErrors = false;\n    this.useProxies = true;\n    this.verifyProxies = false;\n    this.safeDescriptors = true;\n};\nvar canMergeGlobalState = true;\nvar isolateCalled = false;\nvar globalState = /*#__PURE__*/ function() {\n    var global1 = /*#__PURE__*/ getGlobal();\n    if (global1.__mobxInstanceCount > 0 && !global1.__mobxGlobals) {\n        canMergeGlobalState = false;\n    }\n    if (global1.__mobxGlobals && global1.__mobxGlobals.version !== new MobXGlobals().version) {\n        canMergeGlobalState = false;\n    }\n    if (!canMergeGlobalState) {\n        // Because this is a IIFE we need to let isolateCalled a chance to change\n        // so we run it after the event loop completed at least 1 iteration\n        setTimeout(function() {\n            if (!isolateCalled) {\n                die(35);\n            }\n        }, 1);\n        return new MobXGlobals();\n    } else if (global1.__mobxGlobals) {\n        global1.__mobxInstanceCount += 1;\n        if (!global1.__mobxGlobals.UNCHANGED) {\n            global1.__mobxGlobals.UNCHANGED = {};\n        } // make merge backward compatible\n        return global1.__mobxGlobals;\n    } else {\n        global1.__mobxInstanceCount = 1;\n        return global1.__mobxGlobals = /*#__PURE__*/ new MobXGlobals();\n    }\n}();\nfunction isolateGlobalState() {\n    if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {\n        die(36);\n    }\n    isolateCalled = true;\n    if (canMergeGlobalState) {\n        var global1 = getGlobal();\n        if (--global1.__mobxInstanceCount === 0) {\n            global1.__mobxGlobals = undefined;\n        }\n        globalState = new MobXGlobals();\n    }\n}\nfunction getGlobalState() {\n    return globalState;\n}\n/**\r\n * For testing purposes only; this will break the internal state of existing observables,\r\n * but can be used to get back at a stable state after throwing errors\r\n */ function resetGlobalState() {\n    var defaultGlobals = new MobXGlobals();\n    for(var key in defaultGlobals){\n        if (persistentKeys.indexOf(key) === -1) {\n            globalState[key] = defaultGlobals[key];\n        }\n    }\n    globalState.allowStateChanges = !globalState.enforceActions;\n}\nfunction hasObservers(observable) {\n    return observable.observers_ && observable.observers_.size > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers_;\n}\n// function invariantObservers(observable: IObservable) {\n//     const list = observable.observers\n//     const map = observable.observersIndexes\n//     const l = list.length\n//     for (let i = 0; i < l; i++) {\n//         const id = list[i].__mapid\n//         if (i) {\n//             invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\") // for performance\n//         } else {\n//             invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldn't be held in map.\") // for performance\n//         }\n//     }\n//     invariant(\n//         list.length === 0 || Object.keys(map).length === list.length - 1,\n//         \"INTERNAL ERROR there is no junk in map\"\n//     )\n// }\nfunction addObserver(observable, node) {\n    // invariant(node.dependenciesState !== -1, \"INTERNAL ERROR, can add only dependenciesState !== -1\");\n    // invariant(observable._observers.indexOf(node) === -1, \"INTERNAL ERROR add already added node\");\n    // invariantObservers(observable);\n    observable.observers_.add(node);\n    if (observable.lowestObserverState_ > node.dependenciesState_) {\n        observable.lowestObserverState_ = node.dependenciesState_;\n    }\n// invariantObservers(observable);\n// invariant(observable._observers.indexOf(node) !== -1, \"INTERNAL ERROR didn't add node\");\n}\nfunction removeObserver(observable, node) {\n    // invariant(globalState.inBatch > 0, \"INTERNAL ERROR, remove should be called only inside batch\");\n    // invariant(observable._observers.indexOf(node) !== -1, \"INTERNAL ERROR remove already removed node\");\n    // invariantObservers(observable);\n    observable.observers_[\"delete\"](node);\n    if (observable.observers_.size === 0) {\n        // deleting last observer\n        queueForUnobservation(observable);\n    }\n// invariantObservers(observable);\n// invariant(observable._observers.indexOf(node) === -1, \"INTERNAL ERROR remove already removed node2\");\n}\nfunction queueForUnobservation(observable) {\n    if (observable.isPendingUnobservation_ === false) {\n        // invariant(observable._observers.length === 0, \"INTERNAL ERROR, should only queue for unobservation unobserved observables\");\n        observable.isPendingUnobservation_ = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\n/**\r\n * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.\r\n * During a batch `onBecomeUnobserved` will be called at most once per observable.\r\n * Avoids unnecessary recalculations.\r\n */ function startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        // the batch is actually about to finish, all unobserving should happen here.\n        var list = globalState.pendingUnobservations;\n        for(var i = 0; i < list.length; i++){\n            var observable = list[i];\n            observable.isPendingUnobservation_ = false;\n            if (observable.observers_.size === 0) {\n                if (observable.isBeingObserved_) {\n                    // if this observable had reactive observers, trigger the hooks\n                    observable.isBeingObserved_ = false;\n                    observable.onBUO();\n                }\n                if (observable instanceof ComputedValue) {\n                    // computed values are automatically teared down when the last observer leaves\n                    // this process happens recursively, this computed might be the last observabe of another, etc..\n                    observable.suspend_();\n                }\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    checkIfStateReadsAreAllowed(observable);\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        /**\r\n     * Simple optimization, give each derivation run an unique id (runId)\r\n     * Check if last time this observable was accessed the same runId is used\r\n     * if this is the case, the relation is already known\r\n     */ if (derivation.runId_ !== observable.lastAccessedBy_) {\n            observable.lastAccessedBy_ = derivation.runId_;\n            // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...\n            derivation.newObserving_[derivation.unboundDepsCount_++] = observable;\n            if (!observable.isBeingObserved_ && globalState.trackingContext) {\n                observable.isBeingObserved_ = true;\n                observable.onBO();\n            }\n        }\n        return observable.isBeingObserved_;\n    } else if (observable.observers_.size === 0 && globalState.inBatch > 0) {\n        queueForUnobservation(observable);\n    }\n    return false;\n}\n// function invariantLOS(observable: IObservable, msg: string) {\n//     // it's expensive so better not run it in produciton. but temporarily helpful for testing\n//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)\n//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`\n//     throw new Error(\n//         \"lowestObserverState is wrong for \" +\n//             msg +\n//             \" because \" +\n//             min +\n//             \" < \" +\n//             observable.lowestObserverState\n//     )\n// }\n/**\r\n * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly\r\n * It will propagate changes to observers from previous run\r\n * It's hard or maybe impossible (with reasonable perf) to get it right with current approach\r\n * Hopefully self reruning autoruns aren't a feature people should depend on\r\n * Also most basic use cases should be ok\r\n */ // Called by Atom when its value changes\nfunction propagateChanged(observable) {\n    // invariantLOS(observable, \"changed start\");\n    if (observable.lowestObserverState_ === IDerivationState_.STALE_) {\n        return;\n    }\n    observable.lowestObserverState_ = IDerivationState_.STALE_;\n    // Ideally we use for..of here, but the downcompiled version is really slow...\n    observable.observers_.forEach(function(d) {\n        if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n            if ( true && d.isTracing_ !== TraceMode.NONE) {\n                logTraceInfo(d, observable);\n            }\n            d.onBecomeStale_();\n        }\n        d.dependenciesState_ = IDerivationState_.STALE_;\n    });\n// invariantLOS(observable, \"changed end\");\n}\n// Called by ComputedValue when it recalculate and its value changed\nfunction propagateChangeConfirmed(observable) {\n    // invariantLOS(observable, \"confirmed start\");\n    if (observable.lowestObserverState_ === IDerivationState_.STALE_) {\n        return;\n    }\n    observable.lowestObserverState_ = IDerivationState_.STALE_;\n    observable.observers_.forEach(function(d) {\n        if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {\n            d.dependenciesState_ = IDerivationState_.STALE_;\n            if ( true && d.isTracing_ !== TraceMode.NONE) {\n                logTraceInfo(d, observable);\n            }\n        } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_ // this happens during computing of `d`, just keep lowestObserverState up to date.\n        ) {\n            observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n        }\n    });\n// invariantLOS(observable, \"confirmed end\");\n}\n// Used by computed when its dependency changed, but we don't wan't to immediately recompute.\nfunction propagateMaybeChanged(observable) {\n    // invariantLOS(observable, \"maybe start\");\n    if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {\n        return;\n    }\n    observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;\n    observable.observers_.forEach(function(d) {\n        if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n            d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;\n            d.onBecomeStale_();\n        }\n    });\n// invariantLOS(observable, \"maybe end\");\n}\nfunction logTraceInfo(derivation, observable) {\n    console.log(\"[mobx.trace] '\" + derivation.name_ + \"' is invalidated due to a change in: '\" + observable.name_ + \"'\");\n    if (derivation.isTracing_ === TraceMode.BREAK) {\n        var lines = [];\n        printDepTree(getDependencyTree(derivation), lines, 1);\n        // prettier-ignore\n        new Function(\"debugger;\\n/*\\nTracing '\" + derivation.name_ + \"'\\n\\nYou are entering this break point because derivation '\" + derivation.name_ + \"' is being traced and '\" + observable.name_ + \"' is now forcing it to update.\\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\\n\\n\" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\\//g, \"/\") : \"\") + \"\\n\\nThe dependencies for this derivation are:\\n\\n\" + lines.join(\"\\n\") + \"\\n*/\\n    \")();\n    }\n}\nfunction printDepTree(tree, lines, depth) {\n    if (lines.length >= 1000) {\n        lines.push(\"(and many more)\");\n        return;\n    }\n    lines.push(\"\" + \"\t\".repeat(depth - 1) + tree.name);\n    if (tree.dependencies) {\n        tree.dependencies.forEach(function(child) {\n            return printDepTree(child, lines, depth + 1);\n        });\n    }\n}\nvar Reaction = /*#__PURE__*/ function() {\n    // nodes we are looking at. Our value depends on these nodes\n    function Reaction(name_, onInvalidate_, errorHandler_, requiresObservable_) {\n        if (name_ === void 0) {\n            name_ =  true ? \"Reaction@\" + getNextId() : 0;\n        }\n        this.name_ = void 0;\n        this.onInvalidate_ = void 0;\n        this.errorHandler_ = void 0;\n        this.requiresObservable_ = void 0;\n        this.observing_ = [];\n        this.newObserving_ = [];\n        this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n        this.diffValue_ = 0;\n        this.runId_ = 0;\n        this.unboundDepsCount_ = 0;\n        this.isDisposed_ = false;\n        this.isScheduled_ = false;\n        this.isTrackPending_ = false;\n        this.isRunning_ = false;\n        this.isTracing_ = TraceMode.NONE;\n        this.name_ = name_;\n        this.onInvalidate_ = onInvalidate_;\n        this.errorHandler_ = errorHandler_;\n        this.requiresObservable_ = requiresObservable_;\n    }\n    var _proto = Reaction.prototype;\n    _proto.onBecomeStale_ = function onBecomeStale_() {\n        this.schedule_();\n    };\n    _proto.schedule_ = function schedule_() {\n        if (!this.isScheduled_) {\n            this.isScheduled_ = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    _proto.isScheduled = function isScheduled() {\n        return this.isScheduled_;\n    } /**\r\n   * internal, use schedule() if you intend to kick off a reaction\r\n   */ ;\n    _proto.runReaction_ = function runReaction_() {\n        if (!this.isDisposed_) {\n            startBatch();\n            this.isScheduled_ = false;\n            var prev = globalState.trackingContext;\n            globalState.trackingContext = this;\n            if (shouldCompute(this)) {\n                this.isTrackPending_ = true;\n                try {\n                    this.onInvalidate_();\n                    if ( true && this.isTrackPending_ && isSpyEnabled()) {\n                        // onInvalidate didn't trigger track right away..\n                        spyReport({\n                            name: this.name_,\n                            type: \"scheduled-reaction\"\n                        });\n                    }\n                } catch (e) {\n                    this.reportExceptionInDerivation_(e);\n                }\n            }\n            globalState.trackingContext = prev;\n            endBatch();\n        }\n    };\n    _proto.track = function track(fn) {\n        if (this.isDisposed_) {\n            return;\n        // console.warn(\"Reaction already disposed\") // Note: Not a warning / error in mobx 4 either\n        }\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if ( true && notify) {\n            startTime = Date.now();\n            spyReportStart({\n                name: this.name_,\n                type: \"reaction\"\n            });\n        }\n        this.isRunning_ = true;\n        var prevReaction = globalState.trackingContext; // reactions could create reactions...\n        globalState.trackingContext = this;\n        var result = trackDerivedFunction(this, fn, undefined);\n        globalState.trackingContext = prevReaction;\n        this.isRunning_ = false;\n        this.isTrackPending_ = false;\n        if (this.isDisposed_) {\n            // disposed during last run. Clean up everything that was bound after the dispose call.\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) {\n            this.reportExceptionInDerivation_(result.cause);\n        }\n        if ( true && notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {\n        var _this = this;\n        if (this.errorHandler_) {\n            this.errorHandler_(error, this);\n            return;\n        }\n        if (globalState.disableErrorBoundaries) {\n            throw error;\n        }\n        var message =  true ? \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this + \"'\" : 0;\n        if (!globalState.suppressReactionErrors) {\n            console.error(message, error);\n        /** If debugging brought you here, please, read the above message :-). Tnx! */ } else if (true) {\n            console.warn(\"[mobx] (error in reaction '\" + this.name_ + \"' suppressed, fix error of causing action below)\");\n        } // prettier-ignore\n        if ( true && isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                name: this.name_,\n                message: message,\n                error: \"\" + error\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function(f) {\n            return f(error, _this);\n        });\n    };\n    _proto.dispose = function dispose() {\n        if (!this.isDisposed_) {\n            this.isDisposed_ = true;\n            if (!this.isRunning_) {\n                // if disposed while running, clean up later. Maybe not optimal, but rare case\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    _proto.getDisposer_ = function getDisposer_() {\n        var r = this.dispose.bind(this);\n        r[$mobx] = this;\n        return r;\n    };\n    _proto.toString = function toString() {\n        return \"Reaction[\" + this.name_ + \"]\";\n    };\n    _proto.trace = function trace$1(enterBreakPoint) {\n        if (enterBreakPoint === void 0) {\n            enterBreakPoint = false;\n        }\n        trace(this, enterBreakPoint);\n    };\n    return Reaction;\n}();\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function() {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) {\n            globalState.globalReactionErrorHandlers.splice(idx, 1);\n        }\n    };\n}\n/**\r\n * Magic number alert!\r\n * Defines within how many times a reaction is allowed to re-trigger itself\r\n * until it is assumed that this is gonna be a never ending loop...\r\n */ var MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    // Trampolining, if runReactions are already running, new reactions will be picked up\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) {\n        return;\n    }\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    // While running reactions, new reactions might be triggered.\n    // Hence we work with two variables and check whether\n    // we converge to no remaining reactions after a while.\n    while(allReactions.length > 0){\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error( true ? \"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]) : 0);\n            allReactions.splice(0); // clear reactions\n        }\n        var remainingReactions = allReactions.splice(0);\n        for(var i = 0, l = remainingReactions.length; i < l; i++){\n            remainingReactions[i].runReaction_();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = /*#__PURE__*/ createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function() {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return  true && !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (false) {} // dead code elimination can do the rest\n    if (!globalState.spyListeners.length) {\n        return;\n    }\n    var listeners = globalState.spyListeners;\n    for(var i = 0, l = listeners.length; i < l; i++){\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    if (false) {}\n    var change = _extends({}, event, {\n        spyReportStart: true\n    });\n    spyReport(change);\n}\nvar END_EVENT = {\n    type: \"report-end\",\n    spyReportEnd: true\n};\nfunction spyReportEnd(change) {\n    if (false) {}\n    if (change) {\n        spyReport(_extends({}, change, {\n            type: \"report-end\",\n            spyReportEnd: true\n        }));\n    } else {\n        spyReport(END_EVENT);\n    }\n}\nfunction spy(listener) {\n    if (false) {} else {\n        globalState.spyListeners.push(listener);\n        return once(function() {\n            globalState.spyListeners = globalState.spyListeners.filter(function(l) {\n                return l !== listener;\n            });\n        });\n    }\n}\nvar ACTION = \"action\";\nvar ACTION_BOUND = \"action.bound\";\nvar AUTOACTION = \"autoAction\";\nvar AUTOACTION_BOUND = \"autoAction.bound\";\nvar DEFAULT_ACTION_NAME = \"<unnamed action>\";\nvar actionAnnotation = /*#__PURE__*/ createActionAnnotation(ACTION);\nvar actionBoundAnnotation = /*#__PURE__*/ createActionAnnotation(ACTION_BOUND, {\n    bound: true\n});\nvar autoActionAnnotation = /*#__PURE__*/ createActionAnnotation(AUTOACTION, {\n    autoAction: true\n});\nvar autoActionBoundAnnotation = /*#__PURE__*/ createActionAnnotation(AUTOACTION_BOUND, {\n    autoAction: true,\n    bound: true\n});\nfunction createActionFactory(autoAction) {\n    var res = function action(arg1, arg2) {\n        // action(fn() {})\n        if (isFunction(arg1)) {\n            return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction);\n        }\n        // action(\"name\", fn() {})\n        if (isFunction(arg2)) {\n            return createAction(arg1, arg2, autoAction);\n        }\n        // @action\n        if (isStringish(arg2)) {\n            return storeAnnotation(arg1, arg2, autoAction ? autoActionAnnotation : actionAnnotation);\n        }\n        // action(\"name\") & @action(\"name\")\n        if (isStringish(arg1)) {\n            return createDecoratorAnnotation(createActionAnnotation(autoAction ? AUTOACTION : ACTION, {\n                name: arg1,\n                autoAction: autoAction\n            }));\n        }\n        if (true) {\n            die(\"Invalid arguments for `action`\");\n        }\n    };\n    return res;\n}\nvar action = /*#__PURE__*/ createActionFactory(false);\nObject.assign(action, actionAnnotation);\nvar autoAction = /*#__PURE__*/ createActionFactory(true);\nObject.assign(autoAction, autoActionAnnotation);\naction.bound = /*#__PURE__*/ createDecoratorAnnotation(actionBoundAnnotation);\nautoAction.bound = /*#__PURE__*/ createDecoratorAnnotation(autoActionBoundAnnotation);\nfunction runInAction(fn) {\n    return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, undefined);\n}\nfunction isAction(thing) {\n    return isFunction(thing) && thing.isMobxAction === true;\n}\n/**\r\n * Creates a named reactive view and keeps it alive, so that the view is always\r\n * updated if one of the dependencies changes, even when the view is not further used by something else.\r\n * @param view The reactive view\r\n * @returns disposer function, which can be used to stop the view from being updated in the future.\r\n */ function autorun(view, opts) {\n    var _opts$name, _opts;\n    if (opts === void 0) {\n        opts = EMPTY_OBJECT;\n    }\n    if (true) {\n        if (!isFunction(view)) {\n            die(\"Autorun expects a function as first argument\");\n        }\n        if (isAction(view)) {\n            die(\"Autorun does not accept actions since actions are untrackable\");\n        }\n    }\n    var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name :  true ? view.name || \"Autorun@\" + getNextId() : 0;\n    var runSync = !opts.scheduler && !opts.delay;\n    var reaction;\n    if (runSync) {\n        // normal autorun\n        reaction = new Reaction(name, function() {\n            this.track(reactionRunner);\n        }, opts.onError, opts.requiresObservable);\n    } else {\n        var scheduler = createSchedulerFromOptions(opts);\n        // debounced autorun\n        var isScheduled = false;\n        reaction = new Reaction(name, function() {\n            if (!isScheduled) {\n                isScheduled = true;\n                scheduler(function() {\n                    isScheduled = false;\n                    if (!reaction.isDisposed_) {\n                        reaction.track(reactionRunner);\n                    }\n                });\n            }\n        }, opts.onError, opts.requiresObservable);\n    }\n    function reactionRunner() {\n        view(reaction);\n    }\n    reaction.schedule_();\n    return reaction.getDisposer_();\n}\nvar run = function run(f) {\n    return f();\n};\nfunction createSchedulerFromOptions(opts) {\n    return opts.scheduler ? opts.scheduler : opts.delay ? function(f) {\n        return setTimeout(f, opts.delay);\n    } : run;\n}\nfunction reaction(expression, effect, opts) {\n    var _opts$name2;\n    if (opts === void 0) {\n        opts = EMPTY_OBJECT;\n    }\n    if (true) {\n        if (!isFunction(expression) || !isFunction(effect)) {\n            die(\"First and second argument to reaction should be functions\");\n        }\n        if (!isPlainObject(opts)) {\n            die(\"Third argument of reactions should be an object\");\n        }\n    }\n    var name = (_opts$name2 = opts.name) != null ? _opts$name2 :  true ? \"Reaction@\" + getNextId() : 0;\n    var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);\n    var runSync = !opts.scheduler && !opts.delay;\n    var scheduler = createSchedulerFromOptions(opts);\n    var firstTime = true;\n    var isScheduled = false;\n    var value;\n    var oldValue;\n    var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer[\"default\"];\n    var r = new Reaction(name, function() {\n        if (firstTime || runSync) {\n            reactionRunner();\n        } else if (!isScheduled) {\n            isScheduled = true;\n            scheduler(reactionRunner);\n        }\n    }, opts.onError, opts.requiresObservable);\n    function reactionRunner() {\n        isScheduled = false;\n        if (r.isDisposed_) {\n            return;\n        }\n        var changed = false;\n        r.track(function() {\n            var nextValue = allowStateChanges(false, function() {\n                return expression(r);\n            });\n            changed = firstTime || !equals(value, nextValue);\n            oldValue = value;\n            value = nextValue;\n        });\n        if (firstTime && opts.fireImmediately) {\n            effectAction(value, oldValue, r);\n        } else if (!firstTime && changed) {\n            effectAction(value, oldValue, r);\n        }\n        firstTime = false;\n    }\n    r.schedule_();\n    return r.getDisposer_();\n}\nfunction wrapErrorHandler(errorHandler, baseFn) {\n    return function() {\n        try {\n            return baseFn.apply(this, arguments);\n        } catch (e) {\n            errorHandler.call(this, e);\n        }\n    };\n}\nvar ON_BECOME_OBSERVED = \"onBO\";\nvar ON_BECOME_UNOBSERVED = \"onBUO\";\nfunction onBecomeObserved(thing, arg2, arg3) {\n    return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);\n}\nfunction onBecomeUnobserved(thing, arg2, arg3) {\n    return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);\n}\nfunction interceptHook(hook, thing, arg2, arg3) {\n    var atom = typeof arg3 === \"function\" ? getAtom(thing, arg2) : getAtom(thing);\n    var cb = isFunction(arg3) ? arg3 : arg2;\n    var listenersKey = hook + \"L\";\n    if (atom[listenersKey]) {\n        atom[listenersKey].add(cb);\n    } else {\n        atom[listenersKey] = new Set([\n            cb\n        ]);\n    }\n    return function() {\n        var hookListeners = atom[listenersKey];\n        if (hookListeners) {\n            hookListeners[\"delete\"](cb);\n            if (hookListeners.size === 0) {\n                delete atom[listenersKey];\n            }\n        }\n    };\n}\nvar NEVER = \"never\";\nvar ALWAYS = \"always\";\nvar OBSERVED = \"observed\";\n// const IF_AVAILABLE = \"ifavailable\"\nfunction configure(options) {\n    if (options.isolateGlobalState === true) {\n        isolateGlobalState();\n    }\n    var useProxies = options.useProxies, enforceActions = options.enforceActions;\n    if (useProxies !== undefined) {\n        globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== \"undefined\";\n    }\n    if (useProxies === \"ifavailable\") {\n        globalState.verifyProxies = true;\n    }\n    if (enforceActions !== undefined) {\n        var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;\n        globalState.enforceActions = ea;\n        globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;\n    }\n    [\n        \"computedRequiresReaction\",\n        \"reactionRequiresObservable\",\n        \"observableRequiresReaction\",\n        \"disableErrorBoundaries\",\n        \"safeDescriptors\"\n    ].forEach(function(key) {\n        if (key in options) {\n            globalState[key] = !!options[key];\n        }\n    });\n    globalState.allowStateReads = !globalState.observableRequiresReaction;\n    if ( true && globalState.disableErrorBoundaries === true) {\n        console.warn(\"WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.\");\n    }\n    if (options.reactionScheduler) {\n        setReactionScheduler(options.reactionScheduler);\n    }\n}\nfunction extendObservable(target, properties, annotations, options) {\n    if (true) {\n        if (arguments.length > 4) {\n            die(\"'extendObservable' expected 2-4 arguments\");\n        }\n        if (typeof target !== \"object\") {\n            die(\"'extendObservable' expects an object as first argument\");\n        }\n        if (isObservableMap(target)) {\n            die(\"'extendObservable' should not be used on maps, use map.merge instead\");\n        }\n        if (!isPlainObject(properties)) {\n            die(\"'extendObservable' only accepts plain objects as second argument\");\n        }\n        if (isObservable(properties) || isObservable(annotations)) {\n            die(\"Extending an object with another observable (object) is not supported\");\n        }\n    }\n    // Pull descriptors first, so we don't have to deal with props added by administration ($mobx)\n    var descriptors = getOwnPropertyDescriptors(properties);\n    var adm = asObservableObject(target, options)[$mobx];\n    startBatch();\n    try {\n        ownKeys(descriptors).forEach(function(key) {\n            adm.extend_(key, descriptors[key], // must pass \"undefined\" for { key: undefined }\n            !annotations ? true : key in annotations ? annotations[key] : true);\n        });\n    } finally{\n        endBatch();\n    }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name_\n    };\n    if (node.observing_ && node.observing_.length > 0) {\n        result.dependencies = unique(node.observing_).map(nodeToDependencyTree);\n    }\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name_\n    };\n    if (hasObservers(node)) {\n        result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);\n    }\n    return result;\n}\nfunction unique(list) {\n    return Array.from(new Set(list));\n}\nvar generatorId = 0;\nfunction FlowCancellationError() {\n    this.message = \"FLOW_CANCELLED\";\n}\nFlowCancellationError.prototype = /*#__PURE__*/ Object.create(Error.prototype);\nfunction isFlowCancellationError(error) {\n    return error instanceof FlowCancellationError;\n}\nvar flowAnnotation = /*#__PURE__*/ createFlowAnnotation(\"flow\");\nvar flowBoundAnnotation = /*#__PURE__*/ createFlowAnnotation(\"flow.bound\", {\n    bound: true\n});\nvar flow = /*#__PURE__*/ Object.assign(function flow(arg1, arg2) {\n    // @flow\n    if (isStringish(arg2)) {\n        return storeAnnotation(arg1, arg2, flowAnnotation);\n    }\n    // flow(fn)\n    if ( true && arguments.length !== 1) {\n        die(\"Flow expects single argument with generator function\");\n    }\n    var generator = arg1;\n    var name = generator.name || \"<unnamed flow>\";\n    // Implementation based on https://github.com/tj/co/blob/master/index.js\n    var res = function res() {\n        var ctx = this;\n        var args = arguments;\n        var runId = ++generatorId;\n        var gen = action(name + \" - runid: \" + runId + \" - init\", generator).apply(ctx, args);\n        var rejector;\n        var pendingPromise = undefined;\n        var promise = new Promise(function(resolve, reject) {\n            var stepId = 0;\n            rejector = reject;\n            function onFulfilled(res) {\n                pendingPromise = undefined;\n                var ret;\n                try {\n                    ret = action(name + \" - runid: \" + runId + \" - yield \" + stepId++, gen.next).call(gen, res);\n                } catch (e) {\n                    return reject(e);\n                }\n                next(ret);\n            }\n            function onRejected(err) {\n                pendingPromise = undefined;\n                var ret;\n                try {\n                    ret = action(name + \" - runid: \" + runId + \" - yield \" + stepId++, gen[\"throw\"]).call(gen, err);\n                } catch (e) {\n                    return reject(e);\n                }\n                next(ret);\n            }\n            function next(ret) {\n                if (isFunction(ret == null ? void 0 : ret.then)) {\n                    // an async iterator\n                    ret.then(next, reject);\n                    return;\n                }\n                if (ret.done) {\n                    return resolve(ret.value);\n                }\n                pendingPromise = Promise.resolve(ret.value);\n                return pendingPromise.then(onFulfilled, onRejected);\n            }\n            onFulfilled(undefined); // kick off the process\n        });\n        promise.cancel = action(name + \" - runid: \" + runId + \" - cancel\", function() {\n            try {\n                if (pendingPromise) {\n                    cancelPromise(pendingPromise);\n                }\n                // Finally block can return (or yield) stuff..\n                var _res = gen[\"return\"](undefined);\n                // eat anything that promise would do, it's cancelled!\n                var yieldedPromise = Promise.resolve(_res.value);\n                yieldedPromise.then(noop, noop);\n                cancelPromise(yieldedPromise); // maybe it can be cancelled :)\n                // reject our original promise\n                rejector(new FlowCancellationError());\n            } catch (e) {\n                rejector(e); // there could be a throwing finally block\n            }\n        });\n        return promise;\n    };\n    res.isMobXFlow = true;\n    return res;\n}, flowAnnotation);\nflow.bound = /*#__PURE__*/ createDecoratorAnnotation(flowBoundAnnotation);\nfunction cancelPromise(promise) {\n    if (isFunction(promise.cancel)) {\n        promise.cancel();\n    }\n}\nfunction flowResult(result) {\n    return result; // just tricking TypeScript :)\n}\nfunction isFlow(fn) {\n    return (fn == null ? void 0 : fn.isMobXFlow) === true;\n}\nfunction interceptReads(thing, propOrHandler, handler) {\n    var target;\n    if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {\n        target = getAdministration(thing);\n    } else if (isObservableObject(thing)) {\n        if ( true && !isStringish(propOrHandler)) {\n            return die(\"InterceptReads can only be used with a specific property, not with an object in general\");\n        }\n        target = getAdministration(thing, propOrHandler);\n    } else if (true) {\n        return die(\"Expected observable map, object or array as first array\");\n    }\n    if ( true && target.dehancer !== undefined) {\n        return die(\"An intercept reader was already established\");\n    }\n    target.dehancer = typeof propOrHandler === \"function\" ? propOrHandler : handler;\n    return function() {\n        target.dehancer = undefined;\n    };\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (isFunction(handler)) {\n        return interceptProperty(thing, propOrHandler, handler);\n    } else {\n        return interceptInterceptable(thing, propOrHandler);\n    }\n}\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept_(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept_(handler);\n}\nfunction _isComputed(value, property) {\n    if (property === undefined) {\n        return isComputedValue(value);\n    }\n    if (isObservableObject(value) === false) {\n        return false;\n    }\n    if (!value[$mobx].values_.has(property)) {\n        return false;\n    }\n    var atom = getAtom(value, property);\n    return isComputedValue(atom);\n}\nfunction isComputed(value) {\n    if ( true && arguments.length > 1) {\n        return die(\"isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property\");\n    }\n    return _isComputed(value);\n}\nfunction isComputedProp(value, propName) {\n    if ( true && !isStringish(propName)) {\n        return die(\"isComputed expected a property name as second argument\");\n    }\n    return _isComputed(value, propName);\n}\nfunction _isObservable(value, property) {\n    if (!value) {\n        return false;\n    }\n    if (property !== undefined) {\n        if ( true && (isObservableMap(value) || isObservableArray(value))) {\n            return die(\"isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\");\n        }\n        if (isObservableObject(value)) {\n            return value[$mobx].values_.has(property);\n        }\n        return false;\n    }\n    // For first check, see #701\n    return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nfunction isObservable(value) {\n    if ( true && arguments.length !== 1) {\n        die(\"isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property\");\n    }\n    return _isObservable(value);\n}\nfunction isObservableProp(value, propName) {\n    if ( true && !isStringish(propName)) {\n        return die(\"expected a property name as second argument\");\n    }\n    return _isObservable(value, propName);\n}\nfunction keys(obj) {\n    if (isObservableObject(obj)) {\n        return obj[$mobx].keys_();\n    }\n    if (isObservableMap(obj) || isObservableSet(obj)) {\n        return Array.from(obj.keys());\n    }\n    if (isObservableArray(obj)) {\n        return obj.map(function(_, index) {\n            return index;\n        });\n    }\n    die(5);\n}\nfunction values(obj) {\n    if (isObservableObject(obj)) {\n        return keys(obj).map(function(key) {\n            return obj[key];\n        });\n    }\n    if (isObservableMap(obj)) {\n        return keys(obj).map(function(key) {\n            return obj.get(key);\n        });\n    }\n    if (isObservableSet(obj)) {\n        return Array.from(obj.values());\n    }\n    if (isObservableArray(obj)) {\n        return obj.slice();\n    }\n    die(6);\n}\nfunction entries(obj) {\n    if (isObservableObject(obj)) {\n        return keys(obj).map(function(key) {\n            return [\n                key,\n                obj[key]\n            ];\n        });\n    }\n    if (isObservableMap(obj)) {\n        return keys(obj).map(function(key) {\n            return [\n                key,\n                obj.get(key)\n            ];\n        });\n    }\n    if (isObservableSet(obj)) {\n        return Array.from(obj.entries());\n    }\n    if (isObservableArray(obj)) {\n        return obj.map(function(key, index) {\n            return [\n                index,\n                key\n            ];\n        });\n    }\n    die(7);\n}\nfunction set(obj, key, value) {\n    if (arguments.length === 2 && !isObservableSet(obj)) {\n        startBatch();\n        var _values = key;\n        try {\n            for(var _key in _values){\n                set(obj, _key, _values[_key]);\n            }\n        } finally{\n            endBatch();\n        }\n        return;\n    }\n    if (isObservableObject(obj)) {\n        obj[$mobx].set_(key, value);\n    } else if (isObservableMap(obj)) {\n        obj.set(key, value);\n    } else if (isObservableSet(obj)) {\n        obj.add(key);\n    } else if (isObservableArray(obj)) {\n        if (typeof key !== \"number\") {\n            key = parseInt(key, 10);\n        }\n        if (key < 0) {\n            die(\"Invalid index: '\" + key + \"'\");\n        }\n        startBatch();\n        if (key >= obj.length) {\n            obj.length = key + 1;\n        }\n        obj[key] = value;\n        endBatch();\n    } else {\n        die(8);\n    }\n}\nfunction remove(obj, key) {\n    if (isObservableObject(obj)) {\n        obj[$mobx].delete_(key);\n    } else if (isObservableMap(obj)) {\n        obj[\"delete\"](key);\n    } else if (isObservableSet(obj)) {\n        obj[\"delete\"](key);\n    } else if (isObservableArray(obj)) {\n        if (typeof key !== \"number\") {\n            key = parseInt(key, 10);\n        }\n        obj.splice(key, 1);\n    } else {\n        die(9);\n    }\n}\nfunction has(obj, key) {\n    if (isObservableObject(obj)) {\n        return obj[$mobx].has_(key);\n    } else if (isObservableMap(obj)) {\n        return obj.has(key);\n    } else if (isObservableSet(obj)) {\n        return obj.has(key);\n    } else if (isObservableArray(obj)) {\n        return key >= 0 && key < obj.length;\n    }\n    die(10);\n}\nfunction get(obj, key) {\n    if (!has(obj, key)) {\n        return undefined;\n    }\n    if (isObservableObject(obj)) {\n        return obj[$mobx].get_(key);\n    } else if (isObservableMap(obj)) {\n        return obj.get(key);\n    } else if (isObservableArray(obj)) {\n        return obj[key];\n    }\n    die(11);\n}\nfunction apiDefineProperty(obj, key, descriptor) {\n    if (isObservableObject(obj)) {\n        return obj[$mobx].defineProperty_(key, descriptor);\n    }\n    die(39);\n}\nfunction apiOwnKeys(obj) {\n    if (isObservableObject(obj)) {\n        return obj[$mobx].ownKeys_();\n    }\n    die(38);\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (isFunction(cbOrFire)) {\n        return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);\n    } else {\n        return observeObservable(thing, propOrCb, cbOrFire);\n    }\n}\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe_(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe_(listener, fireImmediately);\n}\nfunction cache(map, key, value) {\n    map.set(key, value);\n    return value;\n}\nfunction toJSHelper(source, __alreadySeen) {\n    if (source == null || typeof source !== \"object\" || source instanceof Date || !isObservable(source)) {\n        return source;\n    }\n    if (isObservableValue(source) || isComputedValue(source)) {\n        return toJSHelper(source.get(), __alreadySeen);\n    }\n    if (__alreadySeen.has(source)) {\n        return __alreadySeen.get(source);\n    }\n    if (isObservableArray(source)) {\n        var res = cache(__alreadySeen, source, new Array(source.length));\n        source.forEach(function(value, idx) {\n            res[idx] = toJSHelper(value, __alreadySeen);\n        });\n        return res;\n    }\n    if (isObservableSet(source)) {\n        var _res = cache(__alreadySeen, source, new Set());\n        source.forEach(function(value) {\n            _res.add(toJSHelper(value, __alreadySeen));\n        });\n        return _res;\n    }\n    if (isObservableMap(source)) {\n        var _res2 = cache(__alreadySeen, source, new Map());\n        source.forEach(function(value, key) {\n            _res2.set(key, toJSHelper(value, __alreadySeen));\n        });\n        return _res2;\n    } else {\n        // must be observable object\n        var _res3 = cache(__alreadySeen, source, {});\n        apiOwnKeys(source).forEach(function(key) {\n            if (objectPrototype.propertyIsEnumerable.call(source, key)) {\n                _res3[key] = toJSHelper(source[key], __alreadySeen);\n            }\n        });\n        return _res3;\n    }\n}\n/**\r\n * Recursively converts an observable to it's non-observable native counterpart.\r\n * It does NOT recurse into non-observables, these are left as they are, even if they contain observables.\r\n * Computed and other non-enumerable properties are completely ignored.\r\n * Complex scenarios require custom solution, eg implementing `toJSON` or using `serializr` lib.\r\n */ function toJS(source, options) {\n    if ( true && options) {\n        die(\"toJS no longer supports options\");\n    }\n    return toJSHelper(source, new Map());\n}\nfunction trace() {\n    if (false) {}\n    var enterBreakPoint = false;\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (typeof args[args.length - 1] === \"boolean\") {\n        enterBreakPoint = args.pop();\n    }\n    var derivation = getAtomFromArgs(args);\n    if (!derivation) {\n        return die(\"'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly\");\n    }\n    if (derivation.isTracing_ === TraceMode.NONE) {\n        console.log(\"[mobx.trace] '\" + derivation.name_ + \"' tracing enabled\");\n    }\n    derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;\n}\nfunction getAtomFromArgs(args) {\n    switch(args.length){\n        case 0:\n            return globalState.trackingDerivation;\n        case 1:\n            return getAtom(args[0]);\n        case 2:\n            return getAtom(args[0], args[1]);\n    }\n}\n/**\r\n * During a transaction no views are updated until the end of the transaction.\r\n * The transaction will be run synchronously nonetheless.\r\n *\r\n * @param action a function that updates some reactive state\r\n * @returns any value that was returned by the 'action' parameter.\r\n */ function transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    startBatch();\n    try {\n        return action.apply(thisArg);\n    } finally{\n        endBatch();\n    }\n}\nfunction when(predicate, arg1, arg2) {\n    if (arguments.length === 1 || arg1 && typeof arg1 === \"object\") {\n        return whenPromise(predicate, arg1);\n    }\n    return _when(predicate, arg1, arg2 || {});\n}\nfunction _when(predicate, effect, opts) {\n    var timeoutHandle;\n    if (typeof opts.timeout === \"number\") {\n        var error = new Error(\"WHEN_TIMEOUT\");\n        timeoutHandle = setTimeout(function() {\n            if (!disposer[$mobx].isDisposed_) {\n                disposer();\n                if (opts.onError) {\n                    opts.onError(error);\n                } else {\n                    throw error;\n                }\n            }\n        }, opts.timeout);\n    }\n    opts.name =  true ? opts.name || \"When@\" + getNextId() : 0;\n    var effectAction = createAction( true ? opts.name + \"-effect\" : 0, effect);\n    // eslint-disable-next-line\n    var disposer = autorun(function(r) {\n        // predicate should not change state\n        var cond = allowStateChanges(false, predicate);\n        if (cond) {\n            r.dispose();\n            if (timeoutHandle) {\n                clearTimeout(timeoutHandle);\n            }\n            effectAction();\n        }\n    }, opts);\n    return disposer;\n}\nfunction whenPromise(predicate, opts) {\n    var _opts$signal;\n    if ( true && opts && opts.onError) {\n        return die(\"the options 'onError' and 'promise' cannot be combined\");\n    }\n    if (opts != null && (_opts$signal = opts.signal) != null && _opts$signal.aborted) {\n        return Object.assign(Promise.reject(new Error(\"WHEN_ABORTED\")), {\n            cancel: function cancel() {\n                return null;\n            }\n        });\n    }\n    var cancel;\n    var abort;\n    var res = new Promise(function(resolve, reject) {\n        var _opts$signal2;\n        var disposer = _when(predicate, resolve, _extends({}, opts, {\n            onError: reject\n        }));\n        cancel = function cancel() {\n            disposer();\n            reject(new Error(\"WHEN_CANCELLED\"));\n        };\n        abort = function abort() {\n            disposer();\n            reject(new Error(\"WHEN_ABORTED\"));\n        };\n        opts == null ? void 0 : (_opts$signal2 = opts.signal) == null ? void 0 : _opts$signal2.addEventListener == null ? void 0 : _opts$signal2.addEventListener(\"abort\", abort);\n    })[\"finally\"](function() {\n        var _opts$signal3;\n        return opts == null ? void 0 : (_opts$signal3 = opts.signal) == null ? void 0 : _opts$signal3.removeEventListener == null ? void 0 : _opts$signal3.removeEventListener(\"abort\", abort);\n    });\n    res.cancel = cancel;\n    return res;\n}\nfunction getAdm(target) {\n    return target[$mobx];\n}\n// Optimization: we don't need the intermediate objects and could have a completely custom administration for DynamicObjects,\n// and skip either the internal values map, or the base object with its property descriptors!\nvar objectProxyTraps = {\n    has: function has(target, name) {\n        if ( true && globalState.trackingDerivation) {\n            warnAboutProxyRequirement(\"detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.\");\n        }\n        return getAdm(target).has_(name);\n    },\n    get: function get(target, name) {\n        return getAdm(target).get_(name);\n    },\n    set: function set(target, name, value) {\n        var _getAdm$set_;\n        if (!isStringish(name)) {\n            return false;\n        }\n        if ( true && !getAdm(target).values_.has(name)) {\n            warnAboutProxyRequirement(\"add a new observable property through direct assignment. Use 'set' from 'mobx' instead.\");\n        }\n        // null (intercepted) -> true (success)\n        return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;\n    },\n    deleteProperty: function deleteProperty(target, name) {\n        var _getAdm$delete_;\n        if (true) {\n            warnAboutProxyRequirement(\"delete properties from an observable object. Use 'remove' from 'mobx' instead.\");\n        }\n        if (!isStringish(name)) {\n            return false;\n        }\n        // null (intercepted) -> true (success)\n        return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;\n    },\n    defineProperty: function defineProperty(target, name, descriptor) {\n        var _getAdm$definePropert;\n        if (true) {\n            warnAboutProxyRequirement(\"define property on an observable object. Use 'defineProperty' from 'mobx' instead.\");\n        }\n        // null (intercepted) -> true (success)\n        return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;\n    },\n    ownKeys: function ownKeys(target) {\n        if ( true && globalState.trackingDerivation) {\n            warnAboutProxyRequirement(\"iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.\");\n        }\n        return getAdm(target).ownKeys_();\n    },\n    preventExtensions: function preventExtensions(target) {\n        die(13);\n    }\n};\nfunction asDynamicObservableObject(target, options) {\n    var _target$$mobx, _target$$mobx$proxy_;\n    assertProxies();\n    target = asObservableObject(target, options);\n    return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);\n}\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors_ !== undefined && interceptable.interceptors_.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);\n    interceptors.push(handler);\n    return once(function() {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) {\n            interceptors.splice(idx, 1);\n        }\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        // Interceptor can modify the array, copy it to avoid concurrent modification, see #1950\n        var interceptors = [].concat(interceptable.interceptors_ || []);\n        for(var i = 0, l = interceptors.length; i < l; i++){\n            change = interceptors[i](change);\n            if (change && !change.type) {\n                die(14);\n            }\n            if (!change) {\n                break;\n            }\n        }\n        return change;\n    } finally{\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners_ !== undefined && listenable.changeListeners_.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);\n    listeners.push(handler);\n    return once(function() {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) {\n            listeners.splice(idx, 1);\n        }\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners_;\n    if (!listeners) {\n        return;\n    }\n    listeners = listeners.slice();\n    for(var i = 0, l = listeners.length; i < l; i++){\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction makeObservable(target, annotations, options) {\n    var adm = asObservableObject(target, options)[$mobx];\n    startBatch();\n    try {\n        var _annotations;\n        if ( true && annotations && target[storedAnnotationsSymbol]) {\n            die(\"makeObservable second arg must be nullish when using decorators. Mixing @decorator syntax with annotations is not supported.\");\n        }\n        // Default to decorators\n        (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);\n        // Annotate\n        ownKeys(annotations).forEach(function(key) {\n            return adm.make_(key, annotations[key]);\n        });\n    } finally{\n        endBatch();\n    }\n    return target;\n}\n// proto[keysSymbol] = new Set<PropertyKey>()\nvar keysSymbol = /*#__PURE__*/ Symbol(\"mobx-keys\");\nfunction makeAutoObservable(target, overrides, options) {\n    if (true) {\n        if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target))) {\n            die(\"'makeAutoObservable' can only be used for classes that don't have a superclass\");\n        }\n        if (isObservableObject(target)) {\n            die(\"makeAutoObservable can only be used on objects not already made observable\");\n        }\n    }\n    // Optimization: avoid visiting protos\n    // Assumes that annotation.make_/.extend_ works the same for plain objects\n    if (isPlainObject(target)) {\n        return extendObservable(target, target, overrides, options);\n    }\n    var adm = asObservableObject(target, options)[$mobx];\n    // Optimization: cache keys on proto\n    // Assumes makeAutoObservable can be called only once per object and can't be used in subclass\n    if (!target[keysSymbol]) {\n        var proto = Object.getPrototypeOf(target);\n        var keys = new Set([].concat(ownKeys(target), ownKeys(proto)));\n        keys[\"delete\"](\"constructor\");\n        keys[\"delete\"]($mobx);\n        addHiddenProp(proto, keysSymbol, keys);\n    }\n    startBatch();\n    try {\n        target[keysSymbol].forEach(function(key) {\n            return adm.make_(key, // must pass \"undefined\" for { key: undefined }\n            !overrides ? true : key in overrides ? overrides[key] : true);\n        });\n    } finally{\n        endBatch();\n    }\n    return target;\n}\nvar SPLICE = \"splice\";\nvar UPDATE = \"update\";\nvar MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859\nvar arrayTraps = {\n    get: function get(target, name) {\n        var adm = target[$mobx];\n        if (name === $mobx) {\n            return adm;\n        }\n        if (name === \"length\") {\n            return adm.getArrayLength_();\n        }\n        if (typeof name === \"string\" && !isNaN(name)) {\n            return adm.get_(parseInt(name));\n        }\n        if (hasProp(arrayExtensions, name)) {\n            return arrayExtensions[name];\n        }\n        return target[name];\n    },\n    set: function set(target, name, value) {\n        var adm = target[$mobx];\n        if (name === \"length\") {\n            adm.setArrayLength_(value);\n        }\n        if (typeof name === \"symbol\" || isNaN(name)) {\n            target[name] = value;\n        } else {\n            // numeric string\n            adm.set_(parseInt(name), value);\n        }\n        return true;\n    },\n    preventExtensions: function preventExtensions() {\n        die(15);\n    }\n};\nvar ObservableArrayAdministration = /*#__PURE__*/ function() {\n    // this is the prop that gets proxied, so can't replace it!\n    function ObservableArrayAdministration(name, enhancer, owned_, legacyMode_) {\n        if (name === void 0) {\n            name =  true ? \"ObservableArray@\" + getNextId() : 0;\n        }\n        this.owned_ = void 0;\n        this.legacyMode_ = void 0;\n        this.atom_ = void 0;\n        this.values_ = [];\n        this.interceptors_ = void 0;\n        this.changeListeners_ = void 0;\n        this.enhancer_ = void 0;\n        this.dehancer = void 0;\n        this.proxy_ = void 0;\n        this.lastKnownLength_ = 0;\n        this.owned_ = owned_;\n        this.legacyMode_ = legacyMode_;\n        this.atom_ = new Atom(name);\n        this.enhancer_ = function(newV, oldV) {\n            return enhancer(newV, oldV,  true ? name + \"[..]\" : 0);\n        };\n    }\n    var _proto = ObservableArrayAdministration.prototype;\n    _proto.dehanceValue_ = function dehanceValue_(value) {\n        if (this.dehancer !== undefined) {\n            return this.dehancer(value);\n        }\n        return value;\n    };\n    _proto.dehanceValues_ = function dehanceValues_(values) {\n        if (this.dehancer !== undefined && values.length > 0) {\n            return values.map(this.dehancer);\n        }\n        return values;\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                observableKind: \"array\",\n                object: this.proxy_,\n                debugObjectName: this.atom_.name_,\n                type: \"splice\",\n                index: 0,\n                added: this.values_.slice(),\n                addedCount: this.values_.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    _proto.getArrayLength_ = function getArrayLength_() {\n        this.atom_.reportObserved();\n        return this.values_.length;\n    };\n    _proto.setArrayLength_ = function setArrayLength_(newLength) {\n        if (typeof newLength !== \"number\" || isNaN(newLength) || newLength < 0) {\n            die(\"Out of range: \" + newLength);\n        }\n        var currentLength = this.values_.length;\n        if (newLength === currentLength) {\n            return;\n        } else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for(var i = 0; i < newLength - currentLength; i++){\n                newItems[i] = undefined;\n            } // No Array.fill everywhere...\n            this.spliceWithArray_(currentLength, 0, newItems);\n        } else {\n            this.spliceWithArray_(newLength, currentLength - newLength);\n        }\n    };\n    _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {\n        if (oldLength !== this.lastKnownLength_) {\n            die(16);\n        }\n        this.lastKnownLength_ += delta;\n        if (this.legacyMode_ && delta > 0) {\n            reserveArrayBuffer(oldLength + delta + 1);\n        }\n    };\n    _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom_);\n        var length = this.values_.length;\n        if (index === undefined) {\n            index = 0;\n        } else if (index > length) {\n            index = length;\n        } else if (index < 0) {\n            index = Math.max(0, length + index);\n        }\n        if (arguments.length === 1) {\n            deleteCount = length - index;\n        } else if (deleteCount === undefined || deleteCount === null) {\n            deleteCount = 0;\n        } else {\n            deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        }\n        if (newItems === undefined) {\n            newItems = EMPTY_ARRAY;\n        }\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.proxy_,\n                type: SPLICE,\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) {\n                return EMPTY_ARRAY;\n            }\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.length === 0 ? newItems : newItems.map(function(v) {\n            return _this.enhancer_(v, undefined);\n        });\n        if (this.legacyMode_ || \"development\" !== \"production\") {\n            var lengthDelta = newItems.length - deleteCount;\n            this.updateArrayLength_(length, lengthDelta); // checks if internal array wasn't modified\n        }\n        var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) {\n            this.notifyArraySplice_(index, newItems, res);\n        }\n        return this.dehanceValues_(res);\n    };\n    _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            var _this$values_;\n            return (_this$values_ = this.values_).splice.apply(_this$values_, [\n                index,\n                deleteCount\n            ].concat(newItems));\n        } else {\n            // The items removed by the splice\n            var res = this.values_.slice(index, index + deleteCount);\n            // The items that that should remain at the end of the array\n            var oldItems = this.values_.slice(index + deleteCount);\n            // New length is the previous length + addition count - deletion count\n            this.values_.length += newItems.length - deleteCount;\n            for(var i = 0; i < newItems.length; i++){\n                this.values_[index + i] = newItems[i];\n            }\n            for(var _i = 0; _i < oldItems.length; _i++){\n                this.values_[index + newItems.length + _i] = oldItems[_i];\n            }\n            return res;\n        }\n    };\n    _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {\n        var notifySpy = !this.owned_ && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            observableKind: \"array\",\n            object: this.proxy_,\n            type: UPDATE,\n            debugObjectName: this.atom_.name_,\n            index: index,\n            newValue: newValue,\n            oldValue: oldValue\n        } : null;\n        // The reason why this is on right hand side here (and not above), is this way the uglifier will drop it, but it won't\n        // cause any runtime overhead in development mode without NODE_ENV set, unless spying is enabled\n        if ( true && notifySpy) {\n            spyReportStart(change);\n        }\n        this.atom_.reportChanged();\n        if (notify) {\n            notifyListeners(this, change);\n        }\n        if ( true && notifySpy) {\n            spyReportEnd();\n        }\n    };\n    _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {\n        var notifySpy = !this.owned_ && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            observableKind: \"array\",\n            object: this.proxy_,\n            debugObjectName: this.atom_.name_,\n            type: SPLICE,\n            index: index,\n            removed: removed,\n            added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if ( true && notifySpy) {\n            spyReportStart(change);\n        }\n        this.atom_.reportChanged();\n        // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe\n        if (notify) {\n            notifyListeners(this, change);\n        }\n        if ( true && notifySpy) {\n            spyReportEnd();\n        }\n    };\n    _proto.get_ = function get_(index) {\n        if (this.legacyMode_ && index >= this.values_.length) {\n            console.warn( true ? \"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + this.values_.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\" : 0);\n            return undefined;\n        }\n        this.atom_.reportObserved();\n        return this.dehanceValue_(this.values_[index]);\n    };\n    _proto.set_ = function set_(index, newValue) {\n        var values = this.values_;\n        if (this.legacyMode_ && index > values.length) {\n            // out of bounds\n            die(17, index, values.length);\n        }\n        if (index < values.length) {\n            // update at index in range\n            checkIfStateModificationsAreAllowed(this.atom_);\n            var oldValue = values[index];\n            if (hasInterceptors(this)) {\n                var change = interceptChange(this, {\n                    type: UPDATE,\n                    object: this.proxy_,\n                    index: index,\n                    newValue: newValue\n                });\n                if (!change) {\n                    return;\n                }\n                newValue = change.newValue;\n            }\n            newValue = this.enhancer_(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                this.notifyArrayChildUpdate_(index, newValue, oldValue);\n            }\n        } else {\n            // For out of bound index, we don't create an actual sparse array,\n            // but rather fill the holes with undefined (same as setArrayLength_).\n            // This could be considered a bug.\n            var newItems = new Array(index + 1 - values.length);\n            for(var i = 0; i < newItems.length - 1; i++){\n                newItems[i] = undefined;\n            } // No Array.fill everywhere...\n            newItems[newItems.length - 1] = newValue;\n            this.spliceWithArray_(values.length, 0, newItems);\n        }\n    };\n    return ObservableArrayAdministration;\n}();\nfunction createObservableArray(initialValues, enhancer, name, owned) {\n    if (name === void 0) {\n        name =  true ? \"ObservableArray@\" + getNextId() : 0;\n    }\n    if (owned === void 0) {\n        owned = false;\n    }\n    assertProxies();\n    var adm = new ObservableArrayAdministration(name, enhancer, owned, false);\n    addHiddenFinalProp(adm.values_, $mobx, adm);\n    var proxy = new Proxy(adm.values_, arrayTraps);\n    adm.proxy_ = proxy;\n    if (initialValues && initialValues.length) {\n        var prev = allowStateChangesStart(true);\n        adm.spliceWithArray_(0, 0, initialValues);\n        allowStateChangesEnd(prev);\n    }\n    return proxy;\n}\n// eslint-disable-next-line\nvar arrayExtensions = {\n    clear: function clear() {\n        return this.splice(0);\n    },\n    replace: function replace(newItems) {\n        var adm = this[$mobx];\n        return adm.spliceWithArray_(0, adm.values_.length, newItems);\n    },\n    // Used by JSON.stringify\n    toJSON: function toJSON() {\n        return this.slice();\n    },\n    /*\r\n   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)\r\n   * since these functions alter the inner structure of the array, the have side effects.\r\n   * Because the have side effects, they should not be used in computed function,\r\n   * and for that reason the do not call dependencyState.notifyObserved\r\n   */ splice: function splice(index, deleteCount) {\n        for(var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            newItems[_key - 2] = arguments[_key];\n        }\n        var adm = this[$mobx];\n        switch(arguments.length){\n            case 0:\n                return [];\n            case 1:\n                return adm.spliceWithArray_(index);\n            case 2:\n                return adm.spliceWithArray_(index, deleteCount);\n        }\n        return adm.spliceWithArray_(index, deleteCount, newItems);\n    },\n    spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {\n        return this[$mobx].spliceWithArray_(index, deleteCount, newItems);\n    },\n    push: function push() {\n        var adm = this[$mobx];\n        for(var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            items[_key2] = arguments[_key2];\n        }\n        adm.spliceWithArray_(adm.values_.length, 0, items);\n        return adm.values_.length;\n    },\n    pop: function pop() {\n        return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];\n    },\n    shift: function shift() {\n        return this.splice(0, 1)[0];\n    },\n    unshift: function unshift() {\n        var adm = this[$mobx];\n        for(var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n            items[_key3] = arguments[_key3];\n        }\n        adm.spliceWithArray_(0, 0, items);\n        return adm.values_.length;\n    },\n    reverse: function reverse() {\n        // reverse by default mutates in place before returning the result\n        // which makes it both a 'derivation' and a 'mutation'.\n        if (globalState.trackingDerivation) {\n            die(37, \"reverse\");\n        }\n        this.replace(this.slice().reverse());\n        return this;\n    },\n    sort: function sort() {\n        // sort by default mutates in place before returning the result\n        // which goes against all good practices. Let's not change the array in place!\n        if (globalState.trackingDerivation) {\n            die(37, \"sort\");\n        }\n        var copy = this.slice();\n        copy.sort.apply(copy, arguments);\n        this.replace(copy);\n        return this;\n    },\n    remove: function remove(value) {\n        var adm = this[$mobx];\n        var idx = adm.dehanceValues_(adm.values_).indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    }\n};\n/**\r\n * Wrap function from prototype\r\n * Without this, everything works as well, but this works\r\n * faster as everything works on unproxied values\r\n */ addArrayExtension(\"concat\", simpleFunc);\naddArrayExtension(\"flat\", simpleFunc);\naddArrayExtension(\"includes\", simpleFunc);\naddArrayExtension(\"indexOf\", simpleFunc);\naddArrayExtension(\"join\", simpleFunc);\naddArrayExtension(\"lastIndexOf\", simpleFunc);\naddArrayExtension(\"slice\", simpleFunc);\naddArrayExtension(\"toString\", simpleFunc);\naddArrayExtension(\"toLocaleString\", simpleFunc);\n// map\naddArrayExtension(\"every\", mapLikeFunc);\naddArrayExtension(\"filter\", mapLikeFunc);\naddArrayExtension(\"find\", mapLikeFunc);\naddArrayExtension(\"findIndex\", mapLikeFunc);\naddArrayExtension(\"flatMap\", mapLikeFunc);\naddArrayExtension(\"forEach\", mapLikeFunc);\naddArrayExtension(\"map\", mapLikeFunc);\naddArrayExtension(\"some\", mapLikeFunc);\n// reduce\naddArrayExtension(\"reduce\", reduceLikeFunc);\naddArrayExtension(\"reduceRight\", reduceLikeFunc);\nfunction addArrayExtension(funcName, funcFactory) {\n    if (typeof Array.prototype[funcName] === \"function\") {\n        arrayExtensions[funcName] = funcFactory(funcName);\n    }\n}\n// Report and delegate to dehanced array\nfunction simpleFunc(funcName) {\n    return function() {\n        var adm = this[$mobx];\n        adm.atom_.reportObserved();\n        var dehancedValues = adm.dehanceValues_(adm.values_);\n        return dehancedValues[funcName].apply(dehancedValues, arguments);\n    };\n}\n// Make sure callbacks recieve correct array arg #2326\nfunction mapLikeFunc(funcName) {\n    return function(callback, thisArg) {\n        var _this2 = this;\n        var adm = this[$mobx];\n        adm.atom_.reportObserved();\n        var dehancedValues = adm.dehanceValues_(adm.values_);\n        return dehancedValues[funcName](function(element, index) {\n            return callback.call(thisArg, element, index, _this2);\n        });\n    };\n}\n// Make sure callbacks recieve correct array arg #2326\nfunction reduceLikeFunc(funcName) {\n    return function() {\n        var _this3 = this;\n        var adm = this[$mobx];\n        adm.atom_.reportObserved();\n        var dehancedValues = adm.dehanceValues_(adm.values_);\n        // #2432 - reduce behavior depends on arguments.length\n        var callback = arguments[0];\n        arguments[0] = function(accumulator, currentValue, index) {\n            return callback(accumulator, currentValue, index, _this3);\n        };\n        return dehancedValues[funcName].apply(dehancedValues, arguments);\n    };\n}\nvar isObservableArrayAdministration = /*#__PURE__*/ createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);\n}\nvar _Symbol$iterator, _Symbol$toStringTag;\nvar ObservableMapMarker = {};\nvar ADD = \"add\";\nvar DELETE = \"delete\";\n// just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54\n// But: https://github.com/mobxjs/mobx/issues/1556\n_Symbol$iterator = Symbol.iterator;\n_Symbol$toStringTag = Symbol.toStringTag;\nvar ObservableMap = /*#__PURE__*/ function() {\n    // hasMap, not hashMap >-).\n    function ObservableMap(initialData, enhancer_, name_) {\n        var _this = this;\n        if (enhancer_ === void 0) {\n            enhancer_ = deepEnhancer;\n        }\n        if (name_ === void 0) {\n            name_ =  true ? \"ObservableMap@\" + getNextId() : 0;\n        }\n        this.enhancer_ = void 0;\n        this.name_ = void 0;\n        this[$mobx] = ObservableMapMarker;\n        this.data_ = void 0;\n        this.hasMap_ = void 0;\n        this.keysAtom_ = void 0;\n        this.interceptors_ = void 0;\n        this.changeListeners_ = void 0;\n        this.dehancer = void 0;\n        this.enhancer_ = enhancer_;\n        this.name_ = name_;\n        if (!isFunction(Map)) {\n            die(18);\n        }\n        this.keysAtom_ = createAtom( true ? this.name_ + \".keys()\" : 0);\n        this.data_ = new Map();\n        this.hasMap_ = new Map();\n        allowStateChanges(true, function() {\n            _this.merge(initialData);\n        });\n    }\n    var _proto = ObservableMap.prototype;\n    _proto.has_ = function has_(key) {\n        return this.data_.has(key);\n    };\n    _proto.has = function has(key) {\n        var _this2 = this;\n        if (!globalState.trackingDerivation) {\n            return this.has_(key);\n        }\n        var entry = this.hasMap_.get(key);\n        if (!entry) {\n            var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer,  true ? this.name_ + \".\" + stringifyKey(key) + \"?\" : 0, false);\n            this.hasMap_.set(key, newEntry);\n            onBecomeUnobserved(newEntry, function() {\n                return _this2.hasMap_[\"delete\"](key);\n            });\n        }\n        return entry.get();\n    };\n    _proto.set = function set(key, value) {\n        var hasKey = this.has_(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? UPDATE : ADD,\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) {\n                return this;\n            }\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this.updateValue_(key, value);\n        } else {\n            this.addValue_(key, value);\n        }\n        return this;\n    };\n    _proto[\"delete\"] = function _delete(key) {\n        var _this3 = this;\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: DELETE,\n                object: this,\n                name: key\n            });\n            if (!change) {\n                return false;\n            }\n        }\n        if (this.has_(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var _change = notify || notifySpy ? {\n                observableKind: \"map\",\n                debugObjectName: this.name_,\n                type: DELETE,\n                object: this,\n                oldValue: this.data_.get(key).value_,\n                name: key\n            } : null;\n            if ( true && notifySpy) {\n                spyReportStart(_change);\n            } // TODO fix type\n            transaction(function() {\n                var _this3$hasMap_$get;\n                _this3.keysAtom_.reportChanged();\n                (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null ? void 0 : _this3$hasMap_$get.setNewValue_(false);\n                var observable = _this3.data_.get(key);\n                observable.setNewValue_(undefined);\n                _this3.data_[\"delete\"](key);\n            });\n            if (notify) {\n                notifyListeners(this, _change);\n            }\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n            return true;\n        }\n        return false;\n    };\n    _proto.updateValue_ = function updateValue_(key, newValue) {\n        var observable = this.data_.get(key);\n        newValue = observable.prepareNewValue_(newValue);\n        if (newValue !== globalState.UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                observableKind: \"map\",\n                debugObjectName: this.name_,\n                type: UPDATE,\n                object: this,\n                oldValue: observable.value_,\n                name: key,\n                newValue: newValue\n            } : null;\n            if ( true && notifySpy) {\n                spyReportStart(change);\n            } // TODO fix type\n            observable.setNewValue_(newValue);\n            if (notify) {\n                notifyListeners(this, change);\n            }\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n        }\n    };\n    _proto.addValue_ = function addValue_(key, newValue) {\n        var _this4 = this;\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\n        transaction(function() {\n            var _this4$hasMap_$get;\n            var observable = new ObservableValue(newValue, _this4.enhancer_,  true ? _this4.name_ + \".\" + stringifyKey(key) : 0, false);\n            _this4.data_.set(key, observable);\n            newValue = observable.value_; // value might have been changed\n            (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null ? void 0 : _this4$hasMap_$get.setNewValue_(true);\n            _this4.keysAtom_.reportChanged();\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            observableKind: \"map\",\n            debugObjectName: this.name_,\n            type: ADD,\n            object: this,\n            name: key,\n            newValue: newValue\n        } : null;\n        if ( true && notifySpy) {\n            spyReportStart(change);\n        } // TODO fix type\n        if (notify) {\n            notifyListeners(this, change);\n        }\n        if ( true && notifySpy) {\n            spyReportEnd();\n        }\n    };\n    _proto.get = function get(key) {\n        if (this.has(key)) {\n            return this.dehanceValue_(this.data_.get(key).get());\n        }\n        return this.dehanceValue_(undefined);\n    };\n    _proto.dehanceValue_ = function dehanceValue_(value) {\n        if (this.dehancer !== undefined) {\n            return this.dehancer(value);\n        }\n        return value;\n    };\n    _proto.keys = function keys() {\n        this.keysAtom_.reportObserved();\n        return this.data_.keys();\n    };\n    _proto.values = function values() {\n        var self1 = this;\n        var keys = this.keys();\n        return makeIterable({\n            next: function next() {\n                var _keys$next = keys.next(), done = _keys$next.done, value = _keys$next.value;\n                return {\n                    done: done,\n                    value: done ? undefined : self1.get(value)\n                };\n            }\n        });\n    };\n    _proto.entries = function entries() {\n        var self1 = this;\n        var keys = this.keys();\n        return makeIterable({\n            next: function next() {\n                var _keys$next2 = keys.next(), done = _keys$next2.done, value = _keys$next2.value;\n                return {\n                    done: done,\n                    value: done ? undefined : [\n                        value,\n                        self1.get(value)\n                    ]\n                };\n            }\n        });\n    };\n    _proto[_Symbol$iterator] = function() {\n        return this.entries();\n    };\n    _proto.forEach = function forEach(callback, thisArg) {\n        for(var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done;){\n            var _step$value = _step.value, key = _step$value[0], value = _step$value[1];\n            callback.call(thisArg, value, key, this);\n        }\n    } /** Merge another object into this object, returns this. */ ;\n    _proto.merge = function merge(other) {\n        var _this5 = this;\n        if (isObservableMap(other)) {\n            other = new Map(other);\n        }\n        transaction(function() {\n            if (isPlainObject(other)) {\n                getPlainObjectKeys(other).forEach(function(key) {\n                    return _this5.set(key, other[key]);\n                });\n            } else if (Array.isArray(other)) {\n                other.forEach(function(_ref) {\n                    var key = _ref[0], value = _ref[1];\n                    return _this5.set(key, value);\n                });\n            } else if (isES6Map(other)) {\n                if (other.constructor !== Map) {\n                    die(19, other);\n                }\n                other.forEach(function(value, key) {\n                    return _this5.set(key, value);\n                });\n            } else if (other !== null && other !== undefined) {\n                die(20, other);\n            }\n        });\n        return this;\n    };\n    _proto.clear = function clear() {\n        var _this6 = this;\n        transaction(function() {\n            untracked(function() {\n                for(var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done;){\n                    var key = _step2.value;\n                    _this6[\"delete\"](key);\n                }\n            });\n        });\n    };\n    _proto.replace = function replace(values) {\n        var _this7 = this;\n        // Implementation requirements:\n        // - respect ordering of replacement map\n        // - allow interceptors to run and potentially prevent individual operations\n        // - don't recreate observables that already exist in original map (so we don't destroy existing subscriptions)\n        // - don't _keysAtom.reportChanged if the keys of resulting map are indentical (order matters!)\n        // - note that result map may differ from replacement map due to the interceptors\n        transaction(function() {\n            // Convert to map so we can do quick key lookups\n            var replacementMap = convertToMap(values);\n            var orderedData = new Map();\n            // Used for optimization\n            var keysReportChangedCalled = false;\n            // Delete keys that don't exist in replacement map\n            // if the key deletion is prevented by interceptor\n            // add entry at the beginning of the result map\n            for(var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done;){\n                var key = _step3.value;\n                // Concurrently iterating/deleting keys\n                // iterator should handle this correctly\n                if (!replacementMap.has(key)) {\n                    var deleted = _this7[\"delete\"](key);\n                    // Was the key removed?\n                    if (deleted) {\n                        // _keysAtom.reportChanged() was already called\n                        keysReportChangedCalled = true;\n                    } else {\n                        // Delete prevented by interceptor\n                        var value = _this7.data_.get(key);\n                        orderedData.set(key, value);\n                    }\n                }\n            }\n            // Merge entries\n            for(var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done;){\n                var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];\n                // We will want to know whether a new key is added\n                var keyExisted = _this7.data_.has(_key);\n                // Add or update value\n                _this7.set(_key, _value);\n                // The addition could have been prevent by interceptor\n                if (_this7.data_.has(_key)) {\n                    // The update could have been prevented by interceptor\n                    // and also we want to preserve existing values\n                    // so use value from _data map (instead of replacement map)\n                    var _value2 = _this7.data_.get(_key);\n                    orderedData.set(_key, _value2);\n                    // Was a new key added?\n                    if (!keyExisted) {\n                        // _keysAtom.reportChanged() was already called\n                        keysReportChangedCalled = true;\n                    }\n                }\n            }\n            // Check for possible key order change\n            if (!keysReportChangedCalled) {\n                if (_this7.data_.size !== orderedData.size) {\n                    // If size differs, keys are definitely modified\n                    _this7.keysAtom_.reportChanged();\n                } else {\n                    var iter1 = _this7.data_.keys();\n                    var iter2 = orderedData.keys();\n                    var next1 = iter1.next();\n                    var next2 = iter2.next();\n                    while(!next1.done){\n                        if (next1.value !== next2.value) {\n                            _this7.keysAtom_.reportChanged();\n                            break;\n                        }\n                        next1 = iter1.next();\n                        next2 = iter2.next();\n                    }\n                }\n            }\n            // Use correctly ordered map\n            _this7.data_ = orderedData;\n        });\n        return this;\n    };\n    _proto.toString = function toString() {\n        return \"[object ObservableMap]\";\n    };\n    _proto.toJSON = function toJSON() {\n        return Array.from(this);\n    };\n    /**\r\n   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.\r\n   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe\r\n   * for callback details\r\n   */ _proto.observe_ = function observe_(listener, fireImmediately) {\n        if ( true && fireImmediately === true) {\n            die(\"`observe` doesn't support fireImmediately=true in combination with maps.\");\n        }\n        return registerListener(this, listener);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    _createClass(ObservableMap, [\n        {\n            key: \"size\",\n            get: function get() {\n                this.keysAtom_.reportObserved();\n                return this.data_.size;\n            }\n        },\n        {\n            key: _Symbol$toStringTag,\n            get: function get() {\n                return \"Map\";\n            }\n        }\n    ]);\n    return ObservableMap;\n}();\n// eslint-disable-next-line\nvar isObservableMap = /*#__PURE__*/ createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nfunction convertToMap(dataStructure) {\n    if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {\n        return dataStructure;\n    } else if (Array.isArray(dataStructure)) {\n        return new Map(dataStructure);\n    } else if (isPlainObject(dataStructure)) {\n        var map = new Map();\n        for(var key in dataStructure){\n            map.set(key, dataStructure[key]);\n        }\n        return map;\n    } else {\n        return die(21, dataStructure);\n    }\n}\nvar _Symbol$iterator$1, _Symbol$toStringTag$1;\nvar ObservableSetMarker = {};\n_Symbol$iterator$1 = Symbol.iterator;\n_Symbol$toStringTag$1 = Symbol.toStringTag;\nvar ObservableSet = /*#__PURE__*/ function() {\n    function ObservableSet(initialData, enhancer, name_) {\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name_ === void 0) {\n            name_ =  true ? \"ObservableSet@\" + getNextId() : 0;\n        }\n        this.name_ = void 0;\n        this[$mobx] = ObservableSetMarker;\n        this.data_ = new Set();\n        this.atom_ = void 0;\n        this.changeListeners_ = void 0;\n        this.interceptors_ = void 0;\n        this.dehancer = void 0;\n        this.enhancer_ = void 0;\n        this.name_ = name_;\n        if (!isFunction(Set)) {\n            die(22);\n        }\n        this.atom_ = createAtom(this.name_);\n        this.enhancer_ = function(newV, oldV) {\n            return enhancer(newV, oldV, name_);\n        };\n        if (initialData) {\n            this.replace(initialData);\n        }\n    }\n    var _proto = ObservableSet.prototype;\n    _proto.dehanceValue_ = function dehanceValue_(value) {\n        if (this.dehancer !== undefined) {\n            return this.dehancer(value);\n        }\n        return value;\n    };\n    _proto.clear = function clear() {\n        var _this = this;\n        transaction(function() {\n            untracked(function() {\n                for(var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done;){\n                    var value = _step.value;\n                    _this[\"delete\"](value);\n                }\n            });\n        });\n    };\n    _proto.forEach = function forEach(callbackFn, thisArg) {\n        for(var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done;){\n            var value = _step2.value;\n            callbackFn.call(thisArg, value, value, this);\n        }\n    };\n    _proto.add = function add(value) {\n        var _this2 = this;\n        checkIfStateModificationsAreAllowed(this.atom_);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: ADD,\n                object: this,\n                newValue: value\n            });\n            if (!change) {\n                return this;\n            }\n        // ideally, value = change.value would be done here, so that values can be\n        // changed by interceptor. Same applies for other Set and Map api's.\n        }\n        if (!this.has(value)) {\n            transaction(function() {\n                _this2.data_.add(_this2.enhancer_(value, undefined));\n                _this2.atom_.reportChanged();\n            });\n            var notifySpy =  true && isSpyEnabled();\n            var notify = hasListeners(this);\n            var _change = notify || notifySpy ? {\n                observableKind: \"set\",\n                debugObjectName: this.name_,\n                type: ADD,\n                object: this,\n                newValue: value\n            } : null;\n            if (notifySpy && \"development\" !== \"production\") {\n                spyReportStart(_change);\n            }\n            if (notify) {\n                notifyListeners(this, _change);\n            }\n            if (notifySpy && \"development\" !== \"production\") {\n                spyReportEnd();\n            }\n        }\n        return this;\n    };\n    _proto[\"delete\"] = function _delete(value) {\n        var _this3 = this;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: DELETE,\n                object: this,\n                oldValue: value\n            });\n            if (!change) {\n                return false;\n            }\n        }\n        if (this.has(value)) {\n            var notifySpy =  true && isSpyEnabled();\n            var notify = hasListeners(this);\n            var _change2 = notify || notifySpy ? {\n                observableKind: \"set\",\n                debugObjectName: this.name_,\n                type: DELETE,\n                object: this,\n                oldValue: value\n            } : null;\n            if (notifySpy && \"development\" !== \"production\") {\n                spyReportStart(_change2);\n            }\n            transaction(function() {\n                _this3.atom_.reportChanged();\n                _this3.data_[\"delete\"](value);\n            });\n            if (notify) {\n                notifyListeners(this, _change2);\n            }\n            if (notifySpy && \"development\" !== \"production\") {\n                spyReportEnd();\n            }\n            return true;\n        }\n        return false;\n    };\n    _proto.has = function has(value) {\n        this.atom_.reportObserved();\n        return this.data_.has(this.dehanceValue_(value));\n    };\n    _proto.entries = function entries() {\n        var nextIndex = 0;\n        var keys = Array.from(this.keys());\n        var values = Array.from(this.values());\n        return makeIterable({\n            next: function next() {\n                var index = nextIndex;\n                nextIndex += 1;\n                return index < values.length ? {\n                    value: [\n                        keys[index],\n                        values[index]\n                    ],\n                    done: false\n                } : {\n                    done: true\n                };\n            }\n        });\n    };\n    _proto.keys = function keys() {\n        return this.values();\n    };\n    _proto.values = function values() {\n        this.atom_.reportObserved();\n        var self1 = this;\n        var nextIndex = 0;\n        var observableValues = Array.from(this.data_.values());\n        return makeIterable({\n            next: function next() {\n                return nextIndex < observableValues.length ? {\n                    value: self1.dehanceValue_(observableValues[nextIndex++]),\n                    done: false\n                } : {\n                    done: true\n                };\n            }\n        });\n    };\n    _proto.replace = function replace(other) {\n        var _this4 = this;\n        if (isObservableSet(other)) {\n            other = new Set(other);\n        }\n        transaction(function() {\n            if (Array.isArray(other)) {\n                _this4.clear();\n                other.forEach(function(value) {\n                    return _this4.add(value);\n                });\n            } else if (isES6Set(other)) {\n                _this4.clear();\n                other.forEach(function(value) {\n                    return _this4.add(value);\n                });\n            } else if (other !== null && other !== undefined) {\n                die(\"Cannot initialize set from \" + other);\n            }\n        });\n        return this;\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n        // ... 'fireImmediately' could also be true?\n        if ( true && fireImmediately === true) {\n            die(\"`observe` doesn't support fireImmediately=true in combination with sets.\");\n        }\n        return registerListener(this, listener);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    _proto.toJSON = function toJSON() {\n        return Array.from(this);\n    };\n    _proto.toString = function toString() {\n        return \"[object ObservableSet]\";\n    };\n    _proto[_Symbol$iterator$1] = function() {\n        return this.values();\n    };\n    _createClass(ObservableSet, [\n        {\n            key: \"size\",\n            get: function get() {\n                this.atom_.reportObserved();\n                return this.data_.size;\n            }\n        },\n        {\n            key: _Symbol$toStringTag$1,\n            get: function get() {\n                return \"Set\";\n            }\n        }\n    ]);\n    return ObservableSet;\n}();\n// eslint-disable-next-line\nvar isObservableSet = /*#__PURE__*/ createInstanceofPredicate(\"ObservableSet\", ObservableSet);\nvar descriptorCache = /*#__PURE__*/ Object.create(null);\nvar REMOVE = \"remove\";\nvar ObservableObjectAdministration = /*#__PURE__*/ function() {\n    function ObservableObjectAdministration(target_, values_, name_, // Used anytime annotation is not explicitely provided\n    defaultAnnotation_) {\n        if (values_ === void 0) {\n            values_ = new Map();\n        }\n        if (defaultAnnotation_ === void 0) {\n            defaultAnnotation_ = autoAnnotation;\n        }\n        this.target_ = void 0;\n        this.values_ = void 0;\n        this.name_ = void 0;\n        this.defaultAnnotation_ = void 0;\n        this.keysAtom_ = void 0;\n        this.changeListeners_ = void 0;\n        this.interceptors_ = void 0;\n        this.proxy_ = void 0;\n        this.isPlainObject_ = void 0;\n        this.appliedAnnotations_ = void 0;\n        this.pendingKeys_ = void 0;\n        this.target_ = target_;\n        this.values_ = values_;\n        this.name_ = name_;\n        this.defaultAnnotation_ = defaultAnnotation_;\n        this.keysAtom_ = new Atom( true ? this.name_ + \".keys\" : 0);\n        // Optimization: we use this frequently\n        this.isPlainObject_ = isPlainObject(this.target_);\n        if ( true && !isAnnotation(this.defaultAnnotation_)) {\n            die(\"defaultAnnotation must be valid annotation\");\n        }\n        if (true) {\n            // Prepare structure for tracking which fields were already annotated\n            this.appliedAnnotations_ = {};\n        }\n    }\n    var _proto = ObservableObjectAdministration.prototype;\n    _proto.getObservablePropValue_ = function getObservablePropValue_(key) {\n        return this.values_.get(key).get();\n    };\n    _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {\n        var observable = this.values_.get(key);\n        if (observable instanceof ComputedValue) {\n            observable.set(newValue);\n            return true;\n        }\n        // intercept\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: UPDATE,\n                object: this.proxy_ || this.target_,\n                name: key,\n                newValue: newValue\n            });\n            if (!change) {\n                return null;\n            }\n            newValue = change.newValue;\n        }\n        newValue = observable.prepareNewValue_(newValue);\n        // notify spy & observers\n        if (newValue !== globalState.UNCHANGED) {\n            var notify = hasListeners(this);\n            var notifySpy =  true && isSpyEnabled();\n            var _change = notify || notifySpy ? {\n                type: UPDATE,\n                observableKind: \"object\",\n                debugObjectName: this.name_,\n                object: this.proxy_ || this.target_,\n                oldValue: observable.value_,\n                name: key,\n                newValue: newValue\n            } : null;\n            if ( true && notifySpy) {\n                spyReportStart(_change);\n            }\n            observable.setNewValue_(newValue);\n            if (notify) {\n                notifyListeners(this, _change);\n            }\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n        }\n        return true;\n    };\n    _proto.get_ = function get_(key) {\n        if (globalState.trackingDerivation && !hasProp(this.target_, key)) {\n            // Key doesn't exist yet, subscribe for it in case it's added later\n            this.has_(key);\n        }\n        return this.target_[key];\n    } /**\r\n   * @param {PropertyKey} key\r\n   * @param {any} value\r\n   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is\r\n   * @param {boolean} proxyTrap whether it's called from proxy trap\r\n   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\r\n   */ ;\n    _proto.set_ = function set_(key, value, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        // Don't use .has(key) - we care about own\n        if (hasProp(this.target_, key)) {\n            // Existing prop\n            if (this.values_.has(key)) {\n                // Observable (can be intercepted)\n                return this.setObservablePropValue_(key, value);\n            } else if (proxyTrap) {\n                // Non-observable - proxy\n                return Reflect.set(this.target_, key, value);\n            } else {\n                // Non-observable\n                this.target_[key] = value;\n                return true;\n            }\n        } else {\n            // New prop\n            return this.extend_(key, {\n                value: value,\n                enumerable: true,\n                writable: true,\n                configurable: true\n            }, this.defaultAnnotation_, proxyTrap);\n        }\n    };\n    _proto.has_ = function has_(key) {\n        if (!globalState.trackingDerivation) {\n            // Skip key subscription outside derivation\n            return key in this.target_;\n        }\n        this.pendingKeys_ || (this.pendingKeys_ = new Map());\n        var entry = this.pendingKeys_.get(key);\n        if (!entry) {\n            entry = new ObservableValue(key in this.target_, referenceEnhancer,  true ? this.name_ + \".\" + stringifyKey(key) + \"?\" : 0, false);\n            this.pendingKeys_.set(key, entry);\n        }\n        return entry.get();\n    } /**\r\n   * @param {PropertyKey} key\r\n   * @param {Annotation|boolean} annotation true - use default annotation, false - ignore prop\r\n   */ ;\n    _proto.make_ = function make_(key, annotation) {\n        if (annotation === true) {\n            annotation = this.defaultAnnotation_;\n        }\n        if (annotation === false) {\n            return;\n        }\n        assertAnnotable(this, annotation, key);\n        if (!(key in this.target_)) {\n            var _this$target_$storedA;\n            // Throw on missing key, except for decorators:\n            // Decorator annotations are collected from whole prototype chain.\n            // When called from super() some props may not exist yet.\n            // However we don't have to worry about missing prop,\n            // because the decorator must have been applied to something.\n            if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {\n                return; // will be annotated by subclass constructor\n            } else {\n                die(1, annotation.annotationType_, this.name_ + \".\" + key.toString());\n            }\n        }\n        var source = this.target_;\n        while(source && source !== objectPrototype){\n            var descriptor = getDescriptor(source, key);\n            if (descriptor) {\n                var outcome = annotation.make_(this, key, descriptor, source);\n                if (outcome === 0 /* Cancel */ ) {\n                    return;\n                }\n                if (outcome === 1 /* Break */ ) {\n                    break;\n                }\n            }\n            source = Object.getPrototypeOf(source);\n        }\n        recordAnnotationApplied(this, annotation, key);\n    } /**\r\n   * @param {PropertyKey} key\r\n   * @param {PropertyDescriptor} descriptor\r\n   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is\r\n   * @param {boolean} proxyTrap whether it's called from proxy trap\r\n   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\r\n   */ ;\n    _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        if (annotation === true) {\n            annotation = this.defaultAnnotation_;\n        }\n        if (annotation === false) {\n            return this.defineProperty_(key, descriptor, proxyTrap);\n        }\n        assertAnnotable(this, annotation, key);\n        var outcome = annotation.extend_(this, key, descriptor, proxyTrap);\n        if (outcome) {\n            recordAnnotationApplied(this, annotation, key);\n        }\n        return outcome;\n    } /**\r\n   * @param {PropertyKey} key\r\n   * @param {PropertyDescriptor} descriptor\r\n   * @param {boolean} proxyTrap whether it's called from proxy trap\r\n   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\r\n   */ ;\n    _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        try {\n            startBatch();\n            // Delete\n            var deleteOutcome = this.delete_(key);\n            if (!deleteOutcome) {\n                // Failure or intercepted\n                return deleteOutcome;\n            }\n            // ADD interceptor\n            if (hasInterceptors(this)) {\n                var change = interceptChange(this, {\n                    object: this.proxy_ || this.target_,\n                    name: key,\n                    type: ADD,\n                    newValue: descriptor.value\n                });\n                if (!change) {\n                    return null;\n                }\n                var newValue = change.newValue;\n                if (descriptor.value !== newValue) {\n                    descriptor = _extends({}, descriptor, {\n                        value: newValue\n                    });\n                }\n            }\n            // Define\n            if (proxyTrap) {\n                if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n                    return false;\n                }\n            } else {\n                defineProperty(this.target_, key, descriptor);\n            }\n            // Notify\n            this.notifyPropertyAddition_(key, descriptor.value);\n        } finally{\n            endBatch();\n        }\n        return true;\n    };\n    _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        try {\n            startBatch();\n            // Delete\n            var deleteOutcome = this.delete_(key);\n            if (!deleteOutcome) {\n                // Failure or intercepted\n                return deleteOutcome;\n            }\n            // ADD interceptor\n            if (hasInterceptors(this)) {\n                var change = interceptChange(this, {\n                    object: this.proxy_ || this.target_,\n                    name: key,\n                    type: ADD,\n                    newValue: value\n                });\n                if (!change) {\n                    return null;\n                }\n                value = change.newValue;\n            }\n            var cachedDescriptor = getCachedObservablePropDescriptor(key);\n            var descriptor = {\n                configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,\n                enumerable: true,\n                get: cachedDescriptor.get,\n                set: cachedDescriptor.set\n            };\n            // Define\n            if (proxyTrap) {\n                if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n                    return false;\n                }\n            } else {\n                defineProperty(this.target_, key, descriptor);\n            }\n            var observable = new ObservableValue(value, enhancer,  true ? this.name_ + \".\" + key.toString() : 0, false);\n            this.values_.set(key, observable);\n            // Notify (value possibly changed by ObservableValue)\n            this.notifyPropertyAddition_(key, observable.value_);\n        } finally{\n            endBatch();\n        }\n        return true;\n    };\n    _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        try {\n            startBatch();\n            // Delete\n            var deleteOutcome = this.delete_(key);\n            if (!deleteOutcome) {\n                // Failure or intercepted\n                return deleteOutcome;\n            }\n            // ADD interceptor\n            if (hasInterceptors(this)) {\n                var change = interceptChange(this, {\n                    object: this.proxy_ || this.target_,\n                    name: key,\n                    type: ADD,\n                    newValue: undefined\n                });\n                if (!change) {\n                    return null;\n                }\n            }\n            options.name || (options.name =  true ? this.name_ + \".\" + key.toString() : 0);\n            options.context = this.proxy_ || this.target_;\n            var cachedDescriptor = getCachedObservablePropDescriptor(key);\n            var descriptor = {\n                configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,\n                enumerable: false,\n                get: cachedDescriptor.get,\n                set: cachedDescriptor.set\n            };\n            // Define\n            if (proxyTrap) {\n                if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n                    return false;\n                }\n            } else {\n                defineProperty(this.target_, key, descriptor);\n            }\n            this.values_.set(key, new ComputedValue(options));\n            // Notify\n            this.notifyPropertyAddition_(key, undefined);\n        } finally{\n            endBatch();\n        }\n        return true;\n    } /**\r\n   * @param {PropertyKey} key\r\n   * @param {PropertyDescriptor} descriptor\r\n   * @param {boolean} proxyTrap whether it's called from proxy trap\r\n   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\r\n   */ ;\n    _proto.delete_ = function delete_(key, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        // No such prop\n        if (!hasProp(this.target_, key)) {\n            return true;\n        }\n        // Intercept\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.proxy_ || this.target_,\n                name: key,\n                type: REMOVE\n            });\n            // Cancelled\n            if (!change) {\n                return null;\n            }\n        }\n        // Delete\n        try {\n            var _this$pendingKeys_, _this$pendingKeys_$ge;\n            startBatch();\n            var notify = hasListeners(this);\n            var notifySpy =  true && isSpyEnabled();\n            var observable = this.values_.get(key);\n            // Value needed for spies/listeners\n            var value = undefined;\n            // Optimization: don't pull the value unless we will need it\n            if (!observable && (notify || notifySpy)) {\n                var _getDescriptor;\n                value = (_getDescriptor = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor.value;\n            }\n            // delete prop (do first, may fail)\n            if (proxyTrap) {\n                if (!Reflect.deleteProperty(this.target_, key)) {\n                    return false;\n                }\n            } else {\n                delete this.target_[key];\n            }\n            // Allow re-annotating this field\n            if (true) {\n                delete this.appliedAnnotations_[key];\n            }\n            // Clear observable\n            if (observable) {\n                this.values_[\"delete\"](key);\n                // for computed, value is undefined\n                if (observable instanceof ObservableValue) {\n                    value = observable.value_;\n                }\n                // Notify: autorun(() => obj[key]), see #1796\n                propagateChanged(observable);\n            }\n            // Notify \"keys/entries/values\" observers\n            this.keysAtom_.reportChanged();\n            // Notify \"has\" observers\n            // \"in\" as it may still exist in proto\n            (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_);\n            // Notify spies/listeners\n            if (notify || notifySpy) {\n                var _change2 = {\n                    type: REMOVE,\n                    observableKind: \"object\",\n                    object: this.proxy_ || this.target_,\n                    debugObjectName: this.name_,\n                    oldValue: value,\n                    name: key\n                };\n                if ( true && notifySpy) {\n                    spyReportStart(_change2);\n                }\n                if (notify) {\n                    notifyListeners(this, _change2);\n                }\n                if ( true && notifySpy) {\n                    spyReportEnd();\n                }\n            }\n        } finally{\n            endBatch();\n        }\n        return true;\n    } /**\r\n   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.\r\n   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe\r\n   * for callback details\r\n   */ ;\n    _proto.observe_ = function observe_(callback, fireImmediately) {\n        if ( true && fireImmediately === true) {\n            die(\"`observe` doesn't support the fire immediately property for observable objects.\");\n        }\n        return registerListener(this, callback);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {\n        var _this$pendingKeys_2, _this$pendingKeys_2$g;\n        var notify = hasListeners(this);\n        var notifySpy =  true && isSpyEnabled();\n        if (notify || notifySpy) {\n            var change = notify || notifySpy ? {\n                type: ADD,\n                observableKind: \"object\",\n                debugObjectName: this.name_,\n                object: this.proxy_ || this.target_,\n                name: key,\n                newValue: value\n            } : null;\n            if ( true && notifySpy) {\n                spyReportStart(change);\n            }\n            if (notify) {\n                notifyListeners(this, change);\n            }\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n        }\n        (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true);\n        // Notify \"keys/entries/values\" observers\n        this.keysAtom_.reportChanged();\n    };\n    _proto.ownKeys_ = function ownKeys_() {\n        this.keysAtom_.reportObserved();\n        return ownKeys(this.target_);\n    };\n    _proto.keys_ = function keys_() {\n        // Returns enumerable && own, but unfortunately keysAtom will report on ANY key change.\n        // There is no way to distinguish between Object.keys(object) and Reflect.ownKeys(object) - both are handled by ownKeys trap.\n        // We can either over-report in Object.keys(object) or under-report in Reflect.ownKeys(object)\n        // We choose to over-report in Object.keys(object), because:\n        // - typically it's used with simple data objects\n        // - when symbolic/non-enumerable keys are relevant Reflect.ownKeys works as expected\n        this.keysAtom_.reportObserved();\n        return Object.keys(this.target_);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, options) {\n    var _options$name;\n    if ( true && options && isObservableObject(target)) {\n        die(\"Options can't be provided for already observable objects.\");\n    }\n    if (hasProp(target, $mobx)) {\n        if ( true && !(getAdministration(target) instanceof ObservableObjectAdministration)) {\n            die(\"Cannot convert '\" + getDebugName(target) + \"' into observable object:\" + \"\\nThe target is already observable of different type.\" + \"\\nExtending builtins is not supported.\");\n        }\n        return target;\n    }\n    if ( true && !Object.isExtensible(target)) {\n        die(\"Cannot make the designated object observable; it is not extensible\");\n    }\n    var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name :  true ? (isPlainObject(target) ? \"ObservableObject\" : target.constructor.name) + \"@\" + getNextId() : 0;\n    var adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options));\n    addHiddenProp(target, $mobx, adm);\n    return target;\n}\nvar isObservableObjectAdministration = /*#__PURE__*/ createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction getCachedObservablePropDescriptor(key) {\n    return descriptorCache[key] || (descriptorCache[key] = {\n        get: function get() {\n            return this[$mobx].getObservablePropValue_(key);\n        },\n        set: function set(value) {\n            return this[$mobx].setObservablePropValue_(key, value);\n        }\n    });\n}\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        return isObservableObjectAdministration(thing[$mobx]);\n    }\n    return false;\n}\nfunction recordAnnotationApplied(adm, annotation, key) {\n    var _adm$target_$storedAn;\n    if (true) {\n        adm.appliedAnnotations_[key] = annotation;\n    }\n    // Remove applied decorator annotation so we don't try to apply it again in subclass constructor\n    (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];\n}\nfunction assertAnnotable(adm, annotation, key) {\n    // Valid annotation\n    if ( true && !isAnnotation(annotation)) {\n        die(\"Cannot annotate '\" + adm.name_ + \".\" + key.toString() + \"': Invalid annotation.\");\n    }\n    /*\r\n  // Configurable, not sealed, not frozen\r\n  // Possibly not needed, just a little better error then the one thrown by engine.\r\n  // Cases where this would be useful the most (subclass field initializer) are not interceptable by this.\r\n  if (__DEV__) {\r\n      const configurable = getDescriptor(adm.target_, key)?.configurable\r\n      const frozen = Object.isFrozen(adm.target_)\r\n      const sealed = Object.isSealed(adm.target_)\r\n      if (!configurable || frozen || sealed) {\r\n          const fieldName = `${adm.name_}.${key.toString()}`\r\n          const requestedAnnotationType = annotation.annotationType_\r\n          let error = `Cannot apply '${requestedAnnotationType}' to '${fieldName}':`\r\n          if (frozen) {\r\n              error += `\\nObject is frozen.`\r\n          }\r\n          if (sealed) {\r\n              error += `\\nObject is sealed.`\r\n          }\r\n          if (!configurable) {\r\n              error += `\\nproperty is not configurable.`\r\n              // Mention only if caused by us to avoid confusion\r\n              if (hasProp(adm.appliedAnnotations!, key)) {\r\n                  error += `\\nTo prevent accidental re-definition of a field by a subclass, `\r\n                  error += `all annotated fields of non-plain objects (classes) are not configurable.`\r\n              }\r\n          }\r\n          die(error)\r\n      }\r\n  }\r\n  */ // Not annotated\n    if ( true && !isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {\n        var fieldName = adm.name_ + \".\" + key.toString();\n        var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;\n        var requestedAnnotationType = annotation.annotationType_;\n        die(\"Cannot apply '\" + requestedAnnotationType + \"' to '\" + fieldName + \"':\" + (\"\\nThe field is already annotated with '\" + currentAnnotationType + \"'.\") + \"\\nRe-annotating fields is not allowed.\" + \"\\nUse 'override' annotation for methods overridden by subclass.\");\n    }\n}\n// Bug in safari 9.* (or iOS 9 safari mobile). See #364\nvar ENTRY_0 = /*#__PURE__*/ createArrayEntryDescriptor(0);\n/**\r\n * This array buffer contains two lists of properties, so that all arrays\r\n * can recycle their property definitions, which significantly improves performance of creating\r\n * properties on the fly.\r\n */ var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\n// Typescript workaround to make sure ObservableArray extends Array\nvar StubArray = function StubArray() {};\nfunction inherit(ctor, proto) {\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(ctor.prototype, proto);\n    } else if (ctor.prototype.__proto__ !== undefined) {\n        ctor.prototype.__proto__ = proto;\n    } else {\n        ctor.prototype = proto;\n    }\n}\ninherit(StubArray, Array.prototype);\n// Weex proto freeze protection was here,\n// but it is unclear why the hack is need as MobX never changed the prototype\n// anyway, so removed it in V6\nvar LegacyObservableArray = /*#__PURE__*/ function(_StubArray, _Symbol$toStringTag, _Symbol$iterator) {\n    _inheritsLoose(LegacyObservableArray, _StubArray);\n    function LegacyObservableArray(initialValues, enhancer, name, owned) {\n        var _this;\n        if (name === void 0) {\n            name =  true ? \"ObservableArray@\" + getNextId() : 0;\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        _this = _StubArray.call(this) || this;\n        var adm = new ObservableArrayAdministration(name, enhancer, owned, true);\n        adm.proxy_ = _assertThisInitialized(_this);\n        addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);\n        if (initialValues && initialValues.length) {\n            var prev = allowStateChangesStart(true);\n            // @ts-ignore\n            _this.spliceWithArray(0, 0, initialValues);\n            allowStateChangesEnd(prev);\n        }\n        {\n            // Seems that Safari won't use numeric prototype setter untill any * numeric property is\n            // defined on the instance. After that it works fine, even if this property is deleted.\n            Object.defineProperty(_assertThisInitialized(_this), \"0\", ENTRY_0);\n        }\n        return _this;\n    }\n    var _proto = LegacyObservableArray.prototype;\n    _proto.concat = function concat() {\n        this[$mobx].atom_.reportObserved();\n        for(var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++){\n            arrays[_key] = arguments[_key];\n        }\n        return Array.prototype.concat.apply(this.slice(), //@ts-ignore\n        arrays.map(function(a) {\n            return isObservableArray(a) ? a.slice() : a;\n        }));\n    };\n    _proto[_Symbol$iterator] = function() {\n        var self1 = this;\n        var nextIndex = 0;\n        return makeIterable({\n            next: function next() {\n                return nextIndex < self1.length ? {\n                    value: self1[nextIndex++],\n                    done: false\n                } : {\n                    done: true,\n                    value: undefined\n                };\n            }\n        });\n    };\n    _createClass(LegacyObservableArray, [\n        {\n            key: \"length\",\n            get: function get() {\n                return this[$mobx].getArrayLength_();\n            },\n            set: function set(newLength) {\n                this[$mobx].setArrayLength_(newLength);\n            }\n        },\n        {\n            key: _Symbol$toStringTag,\n            get: function get() {\n                return \"Array\";\n            }\n        }\n    ]);\n    return LegacyObservableArray;\n}(StubArray, Symbol.toStringTag, Symbol.iterator);\nObject.entries(arrayExtensions).forEach(function(_ref) {\n    var prop = _ref[0], fn = _ref[1];\n    if (prop !== \"concat\") {\n        addHiddenProp(LegacyObservableArray.prototype, prop, fn);\n    }\n});\nfunction createArrayEntryDescriptor(index) {\n    return {\n        enumerable: false,\n        configurable: true,\n        get: function get() {\n            return this[$mobx].get_(index);\n        },\n        set: function set(value) {\n            this[$mobx].set_(index, value);\n        }\n    };\n}\nfunction createArrayBufferItem(index) {\n    defineProperty(LegacyObservableArray.prototype, \"\" + index, createArrayEntryDescriptor(index));\n}\nfunction reserveArrayBuffer(max) {\n    if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {\n        for(var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++){\n            createArrayBufferItem(index);\n        }\n        OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n    }\n}\nreserveArrayBuffer(1000);\nfunction createLegacyArray(initialValues, enhancer, name) {\n    return new LegacyObservableArray(initialValues, enhancer, name);\n}\nfunction getAtom(thing, property) {\n    if (typeof thing === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            if (property !== undefined) {\n                die(23);\n            }\n            return thing[$mobx].atom_;\n        }\n        if (isObservableSet(thing)) {\n            return thing.atom_;\n        }\n        if (isObservableMap(thing)) {\n            if (property === undefined) {\n                return thing.keysAtom_;\n            }\n            var observable = thing.data_.get(property) || thing.hasMap_.get(property);\n            if (!observable) {\n                die(25, property, getDebugName(thing));\n            }\n            return observable;\n        }\n        if (isObservableObject(thing)) {\n            if (!property) {\n                return die(26);\n            }\n            var _observable = thing[$mobx].values_.get(property);\n            if (!_observable) {\n                die(27, property, getDebugName(thing));\n            }\n            return _observable;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    } else if (isFunction(thing)) {\n        if (isReaction(thing[$mobx])) {\n            // disposer function\n            return thing[$mobx];\n        }\n    }\n    die(28);\n}\nfunction getAdministration(thing, property) {\n    if (!thing) {\n        die(29);\n    }\n    if (property !== undefined) {\n        return getAdministration(getAtom(thing, property));\n    }\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n        return thing;\n    }\n    if (isObservableMap(thing) || isObservableSet(thing)) {\n        return thing;\n    }\n    if (thing[$mobx]) {\n        return thing[$mobx];\n    }\n    die(24, thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) {\n        named = getAtom(thing, property);\n    } else if (isAction(thing)) {\n        return thing.name;\n    } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {\n        named = getAdministration(thing);\n    } else {\n        // valid for arrays as well\n        named = getAtom(thing);\n    }\n    return named.name_;\n}\nvar toString = objectPrototype.toString;\nfunction deepEqual(a, b, depth) {\n    if (depth === void 0) {\n        depth = -1;\n    }\n    return eq(a, b, depth);\n}\n// Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289\n// Internal recursive comparison function for `isEqual`.\nfunction eq(a, b, depth, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) {\n        return a !== 0 || 1 / a === 1 / b;\n    }\n    // `null` or `undefined` only equal to itself (strict comparison).\n    if (a == null || b == null) {\n        return false;\n    }\n    // `NaN`s are equivalent, but non-reflexive.\n    if (a !== a) {\n        return b !== b;\n    }\n    // Exhaust primitive checks\n    var type = typeof a;\n    if (type !== \"function\" && type !== \"object\" && typeof b != \"object\") {\n        return false;\n    }\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) {\n        return false;\n    }\n    switch(className){\n        // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n        case \"[object RegExp]\":\n        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n        case \"[object String]\":\n            // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n            // equivalent to `new String(\"5\")`.\n            return \"\" + a === \"\" + b;\n        case \"[object Number]\":\n            // `NaN`s are equivalent, but non-reflexive.\n            // Object(NaN) is equivalent to NaN.\n            if (+a !== +a) {\n                return +b !== +b;\n            }\n            // An `egal` comparison is performed for other numeric values.\n            return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n        case \"[object Date]\":\n        case \"[object Boolean]\":\n            // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n            // millisecond representations. Note that invalid dates with millisecond representations\n            // of `NaN` are not equivalent.\n            return +a === +b;\n        case \"[object Symbol]\":\n            return typeof Symbol !== \"undefined\" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);\n        case \"[object Map]\":\n        case \"[object Set]\":\n            // Maps and Sets are unwrapped to arrays of entry-pairs, adding an incidental level.\n            // Hide this extra level by increasing the depth.\n            if (depth >= 0) {\n                depth++;\n            }\n            break;\n    }\n    // Unwrap any wrapped objects.\n    a = unwrap(a);\n    b = unwrap(b);\n    var areArrays = className === \"[object Array]\";\n    if (!areArrays) {\n        if (typeof a != \"object\" || typeof b != \"object\") {\n            return false;\n        }\n        // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n        // from different frames are.\n        var aCtor = a.constructor, bCtor = b.constructor;\n        if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && \"constructor\" in a && \"constructor\" in b) {\n            return false;\n        }\n    }\n    if (depth === 0) {\n        return false;\n    } else if (depth < 0) {\n        depth = -1;\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while(length--){\n        // Linear search. Performance is inversely proportional to the number of\n        // unique nested structures.\n        if (aStack[length] === a) {\n            return bStack[length] === b;\n        }\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n        // Compare array lengths to determine if a deep comparison is necessary.\n        length = a.length;\n        if (length !== b.length) {\n            return false;\n        }\n        // Deep compare the contents, ignoring non-numeric properties.\n        while(length--){\n            if (!eq(a[length], b[length], depth - 1, aStack, bStack)) {\n                return false;\n            }\n        }\n    } else {\n        // Deep compare objects.\n        var keys = Object.keys(a);\n        var key;\n        length = keys.length;\n        // Ensure that both objects contain the same number of properties before comparing deep equality.\n        if (Object.keys(b).length !== length) {\n            return false;\n        }\n        while(length--){\n            // Deep compare each member\n            key = keys[length];\n            if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) {\n                return false;\n            }\n        }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n}\nfunction unwrap(a) {\n    if (isObservableArray(a)) {\n        return a.slice();\n    }\n    if (isES6Map(a) || isObservableMap(a)) {\n        return Array.from(a.entries());\n    }\n    if (isES6Set(a) || isObservableSet(a)) {\n        return Array.from(a.entries());\n    }\n    return a;\n}\nfunction makeIterable(iterator) {\n    iterator[Symbol.iterator] = getSelf;\n    return iterator;\n}\nfunction getSelf() {\n    return this;\n}\nfunction isAnnotation(thing) {\n    return(// Can be function\n    thing instanceof Object && typeof thing.annotationType_ === \"string\" && isFunction(thing.make_) && isFunction(thing.extend_));\n}\n/**\r\n * (c) Michel Weststrate 2015 - 2020\r\n * MIT Licensed\r\n *\r\n * Welcome to the mobx sources! To get a global overview of how MobX internally works,\r\n * this is a good place to start:\r\n * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74\r\n *\r\n * Source folders:\r\n * ===============\r\n *\r\n * - api/     Most of the public static methods exposed by the module can be found here.\r\n * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.\r\n * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.\r\n * - utils/   Utility stuff.\r\n *\r\n */ [\n    \"Symbol\",\n    \"Map\",\n    \"Set\"\n].forEach(function(m) {\n    var g = getGlobal();\n    if (typeof g[m] === \"undefined\") {\n        die(\"MobX requires global '\" + m + \"' to be available or polyfilled\");\n    }\n});\nif (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"object\") {\n    // See: https://github.com/andykog/mobx-devtools/\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({\n        spy: spy,\n        extras: {\n            getDebugName: getDebugName\n        },\n        $mobx: $mobx\n    });\n}\n //# sourceMappingURL=mobx.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9ieC9kaXN0L21vYnguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsYUFBYTtJQUNmLEdBQUc7SUFDSCxHQUFHLFNBQVNDLEVBQUVDLGNBQWMsRUFBRUMsR0FBRztRQUMvQixPQUFPLG1CQUFtQkQsaUJBQWlCLFdBQVdDLElBQUlDLFFBQVEsS0FBSztJQUN6RTtJQUNBOzs7Ozs7Ozs7O0VBVUEsR0FDQSxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJLFNBQVNILEVBQUVJLEtBQUssRUFBRUMsTUFBTTtRQUMxQixPQUFPLHVDQUF1Q0QsUUFBUSxxQkFBcUJDO0lBQzdFO0lBQ0EsSUFBSTtJQUNKLElBQUksU0FBU0wsRUFBRU0sS0FBSztRQUNsQixPQUFPLDJEQUEyREEsTUFBTUMsV0FBVyxDQUFDQyxJQUFJO0lBQzFGO0lBQ0EsSUFBSSxTQUFTUixFQUFFTSxLQUFLO1FBQ2xCLE9BQU8sZ0NBQWdDQTtJQUN6QztJQUNBLElBQUksU0FBU04sRUFBRVMsYUFBYTtRQUMxQixPQUFPLGlDQUFpQ0EsZ0JBQWdCO0lBQzFEO0lBQ0EsSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJLFNBQVNULEVBQUVVLEtBQUs7UUFDbEIsT0FBTyx1Q0FBdUNBO0lBQ2hEO0lBQ0EsSUFBSSxTQUFTVixFQUFFVyxRQUFRLEVBQUVILElBQUk7UUFDM0IsT0FBTyxnQkFBZ0JHLFdBQVcsNkNBQTZDSCxPQUFPO0lBQ3hGO0lBQ0EsSUFBSTtJQUNKLElBQUksU0FBU1IsRUFBRVcsUUFBUSxFQUFFSCxJQUFJO1FBQzNCLE9BQU8sNkJBQTZCRyxTQUFT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Q0FBa0MsVUFBVTtJQUNyRCxpREFBaUQ7SUFDakRBLDhCQUE4QkMsVUFBVSxDQUFDO1FBQ3ZDbFUsS0FBS0E7UUFDTG1VLFFBQVE7WUFDTjdCLGNBQWNBO1FBQ2hCO1FBQ0E5ckIsT0FBT0E7SUFDVDtBQUNGO0FBRXlxQyxDQUN6cUMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL21vYngvZGlzdC9tb2J4LmVzbS5qcz83ZWFjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBuaWNlRXJyb3JzID0ge1xuICAwOiBcIkludmFsaWQgdmFsdWUgZm9yIGNvbmZpZ3VyYXRpb24gJ2VuZm9yY2VBY3Rpb25zJywgZXhwZWN0ZWQgJ25ldmVyJywgJ2Fsd2F5cycgb3IgJ29ic2VydmVkJ1wiLFxuICAxOiBmdW5jdGlvbiBfKGFubm90YXRpb25UeXBlLCBrZXkpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGUgKyBcIicgdG8gJ1wiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6IEZpZWxkIG5vdCBmb3VuZC5cIjtcbiAgfSxcbiAgLypcclxuICAyKHByb3ApIHtcclxuICAgICAgcmV0dXJuIGBpbnZhbGlkIGRlY29yYXRvciBmb3IgJyR7cHJvcC50b1N0cmluZygpfSdgXHJcbiAgfSxcclxuICAzKHByb3ApIHtcclxuICAgICAgcmV0dXJuIGBDYW5ub3QgZGVjb3JhdGUgJyR7cHJvcC50b1N0cmluZygpfSc6IGFjdGlvbiBjYW4gb25seSBiZSB1c2VkIG9uIHByb3BlcnRpZXMgd2l0aCBhIGZ1bmN0aW9uIHZhbHVlLmBcclxuICB9LFxyXG4gIDQocHJvcCkge1xyXG4gICAgICByZXR1cm4gYENhbm5vdCBkZWNvcmF0ZSAnJHtwcm9wLnRvU3RyaW5nKCl9JzogY29tcHV0ZWQgY2FuIG9ubHkgYmUgdXNlZCBvbiBnZXR0ZXIgcHJvcGVydGllcy5gXHJcbiAgfSxcclxuICAqL1xuICA1OiBcIidrZXlzKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMsIHNldHMgYW5kIG1hcHNcIixcbiAgNjogXCIndmFsdWVzKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMsIHNldHMgYW5kIG1hcHNcIixcbiAgNzogXCInZW50cmllcygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDg6IFwiJ3NldCgpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDk6IFwiJ3JlbW92ZSgpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDEwOiBcIidoYXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICAxMTogXCInZ2V0KCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgMTI6IFwiSW52YWxpZCBhbm5vdGF0aW9uXCIsXG4gIDEzOiBcIkR5bmFtaWMgb2JzZXJ2YWJsZSBvYmplY3RzIGNhbm5vdCBiZSBmcm96ZW4uIElmIHlvdSdyZSBwYXNzaW5nIG9ic2VydmFibGVzIHRvIDNyZCBwYXJ0eSBjb21wb25lbnQvZnVuY3Rpb24gdGhhdCBjYWxscyBPYmplY3QuZnJlZXplLCBwYXNzIGNvcHkgaW5zdGVhZDogdG9KUyhvYnNlcnZhYmxlKVwiLFxuICAxNDogXCJJbnRlcmNlcHQgaGFuZGxlcnMgc2hvdWxkIHJldHVybiBub3RoaW5nIG9yIGEgY2hhbmdlIG9iamVjdFwiLFxuICAxNTogXCJPYnNlcnZhYmxlIGFycmF5cyBjYW5ub3QgYmUgZnJvemVuLiBJZiB5b3UncmUgcGFzc2luZyBvYnNlcnZhYmxlcyB0byAzcmQgcGFydHkgY29tcG9uZW50L2Z1bmN0aW9uIHRoYXQgY2FsbHMgT2JqZWN0LmZyZWV6ZSwgcGFzcyBjb3B5IGluc3RlYWQ6IHRvSlMob2JzZXJ2YWJsZSlcIixcbiAgMTY6IFwiTW9kaWZpY2F0aW9uIGV4Y2VwdGlvbjogdGhlIGludGVybmFsIHN0cnVjdHVyZSBvZiBhbiBvYnNlcnZhYmxlIGFycmF5IHdhcyBjaGFuZ2VkLlwiLFxuICAxNzogZnVuY3Rpb24gXyhpbmRleCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFwiW21vYnguYXJyYXldIEluZGV4IG91dCBvZiBib3VuZHMsIFwiICsgaW5kZXggKyBcIiBpcyBsYXJnZXIgdGhhbiBcIiArIGxlbmd0aDtcbiAgfSxcbiAgMTg6IFwibW9ieC5tYXAgcmVxdWlyZXMgTWFwIHBvbHlmaWxsIGZvciB0aGUgY3VycmVudCBicm93c2VyLiBDaGVjayBiYWJlbC1wb2x5ZmlsbCBvciBjb3JlLWpzL2VzNi9tYXAuanNcIixcbiAgMTk6IGZ1bmN0aW9uIF8ob3RoZXIpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgaW5pdGlhbGl6ZSBmcm9tIGNsYXNzZXMgdGhhdCBpbmhlcml0IGZyb20gTWFwOiBcIiArIG90aGVyLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH0sXG4gIDIwOiBmdW5jdGlvbiBfKG90aGVyKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IGluaXRpYWxpemUgbWFwIGZyb20gXCIgKyBvdGhlcjtcbiAgfSxcbiAgMjE6IGZ1bmN0aW9uIF8oZGF0YVN0cnVjdHVyZSkge1xuICAgIHJldHVybiBcIkNhbm5vdCBjb252ZXJ0IHRvIG1hcCBmcm9tICdcIiArIGRhdGFTdHJ1Y3R1cmUgKyBcIidcIjtcbiAgfSxcbiAgMjI6IFwibW9ieC5zZXQgcmVxdWlyZXMgU2V0IHBvbHlmaWxsIGZvciB0aGUgY3VycmVudCBicm93c2VyLiBDaGVjayBiYWJlbC1wb2x5ZmlsbCBvciBjb3JlLWpzL2VzNi9zZXQuanNcIixcbiAgMjM6IFwiSXQgaXMgbm90IHBvc3NpYmxlIHRvIGdldCBpbmRleCBhdG9tcyBmcm9tIGFycmF5c1wiLFxuICAyNDogZnVuY3Rpb24gXyh0aGluZykge1xuICAgIHJldHVybiBcIkNhbm5vdCBvYnRhaW4gYWRtaW5pc3RyYXRpb24gZnJvbSBcIiArIHRoaW5nO1xuICB9LFxuICAyNTogZnVuY3Rpb24gXyhwcm9wZXJ0eSwgbmFtZSkge1xuICAgIHJldHVybiBcInRoZSBlbnRyeSAnXCIgKyBwcm9wZXJ0eSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgb2JzZXJ2YWJsZSBtYXAgJ1wiICsgbmFtZSArIFwiJ1wiO1xuICB9LFxuICAyNjogXCJwbGVhc2Ugc3BlY2lmeSBhIHByb3BlcnR5XCIsXG4gIDI3OiBmdW5jdGlvbiBfKHByb3BlcnR5LCBuYW1lKSB7XG4gICAgcmV0dXJuIFwibm8gb2JzZXJ2YWJsZSBwcm9wZXJ0eSAnXCIgKyBwcm9wZXJ0eS50b1N0cmluZygpICsgXCInIGZvdW5kIG9uIHRoZSBvYnNlcnZhYmxlIG9iamVjdCAnXCIgKyBuYW1lICsgXCInXCI7XG4gIH0sXG4gIDI4OiBmdW5jdGlvbiBfKHRoaW5nKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IG9idGFpbiBhdG9tIGZyb20gXCIgKyB0aGluZztcbiAgfSxcbiAgMjk6IFwiRXhwZWN0aW5nIHNvbWUgb2JqZWN0XCIsXG4gIDMwOiBcImludmFsaWQgYWN0aW9uIHN0YWNrLiBkaWQgeW91IGZvcmdldCB0byBmaW5pc2ggYW4gYWN0aW9uP1wiLFxuICAzMTogXCJtaXNzaW5nIG9wdGlvbiBmb3IgY29tcHV0ZWQ6IGdldFwiLFxuICAzMjogZnVuY3Rpb24gXyhuYW1lLCBkZXJpdmF0aW9uKSB7XG4gICAgcmV0dXJuIFwiQ3ljbGUgZGV0ZWN0ZWQgaW4gY29tcHV0YXRpb24gXCIgKyBuYW1lICsgXCI6IFwiICsgZGVyaXZhdGlvbjtcbiAgfSxcbiAgMzM6IGZ1bmN0aW9uIF8obmFtZSkge1xuICAgIHJldHVybiBcIlRoZSBzZXR0ZXIgb2YgY29tcHV0ZWQgdmFsdWUgJ1wiICsgbmFtZSArIFwiJyBpcyB0cnlpbmcgdG8gdXBkYXRlIGl0c2VsZi4gRGlkIHlvdSBpbnRlbmQgdG8gdXBkYXRlIGFuIF9vYnNlcnZhYmxlXyB2YWx1ZSwgaW5zdGVhZCBvZiB0aGUgY29tcHV0ZWQgcHJvcGVydHk/XCI7XG4gIH0sXG4gIDM0OiBmdW5jdGlvbiBfKG5hbWUpIHtcbiAgICByZXR1cm4gXCJbQ29tcHV0ZWRWYWx1ZSAnXCIgKyBuYW1lICsgXCInXSBJdCBpcyBub3QgcG9zc2libGUgdG8gYXNzaWduIGEgbmV3IHZhbHVlIHRvIGEgY29tcHV0ZWQgdmFsdWUuXCI7XG4gIH0sXG4gIDM1OiBcIlRoZXJlIGFyZSBtdWx0aXBsZSwgZGlmZmVyZW50IHZlcnNpb25zIG9mIE1vYlggYWN0aXZlLiBNYWtlIHN1cmUgTW9iWCBpcyBsb2FkZWQgb25seSBvbmNlIG9yIHVzZSBgY29uZmlndXJlKHsgaXNvbGF0ZUdsb2JhbFN0YXRlOiB0cnVlIH0pYFwiLFxuICAzNjogXCJpc29sYXRlR2xvYmFsU3RhdGUgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgTW9iWCBpcyBydW5uaW5nIGFueSByZWFjdGlvbnNcIixcbiAgMzc6IGZ1bmN0aW9uIF8obWV0aG9kKSB7XG4gICAgcmV0dXJuIFwiW21vYnhdIGBvYnNlcnZhYmxlQXJyYXkuXCIgKyBtZXRob2QgKyBcIigpYCBtdXRhdGVzIHRoZSBhcnJheSBpbi1wbGFjZSwgd2hpY2ggaXMgbm90IGFsbG93ZWQgaW5zaWRlIGEgZGVyaXZhdGlvbi4gVXNlIGBhcnJheS5zbGljZSgpLlwiICsgbWV0aG9kICsgXCIoKWAgaW5zdGVhZFwiO1xuICB9LFxuICAzODogXCInb3duS2V5cygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0c1wiLFxuICAzOTogXCInZGVmaW5lUHJvcGVydHkoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHNcIlxufTtcbnZhciBlcnJvcnMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBuaWNlRXJyb3JzIDoge307XG5mdW5jdGlvbiBkaWUoZXJyb3IpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgZSA9IHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIiA/IGVycm9yIDogZXJyb3JzW2Vycm9yXTtcbiAgICBpZiAodHlwZW9mIGUgPT09IFwiZnVuY3Rpb25cIikgZSA9IGUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW01vYlhdIFwiICsgZSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKHR5cGVvZiBlcnJvciA9PT0gXCJudW1iZXJcIiA/IFwiW01vYlhdIG1pbmlmaWVkIGVycm9yIG5yOiBcIiArIGVycm9yICsgKGFyZ3MubGVuZ3RoID8gXCIgXCIgKyBhcmdzLm1hcChTdHJpbmcpLmpvaW4oXCIsXCIpIDogXCJcIikgKyBcIi4gRmluZCB0aGUgZnVsbCBlcnJvciBhdDogaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L2Jsb2IvbWFpbi9wYWNrYWdlcy9tb2J4L3NyYy9lcnJvcnMudHNcIiA6IFwiW01vYlhdIFwiICsgZXJyb3IpO1xufVxuXG52YXIgbW9ja0dsb2JhbCA9IHt9O1xuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHJldHVybiBtb2NrR2xvYmFsO1xufVxuXG4vLyBXZSBzaG9ydGVuIGFueXRoaW5nIHVzZWQgPiA1IHRpbWVzXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbnZhciBnZXREZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEVNUFRZX0FSUkFZID0gW107XG5PYmplY3QuZnJlZXplKEVNUFRZX0FSUkFZKTtcbnZhciBFTVBUWV9PQkpFQ1QgPSB7fTtcbk9iamVjdC5mcmVlemUoRU1QVFlfT0JKRUNUKTtcbnZhciBoYXNQcm94eSA9IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBwbGFpbk9iamVjdFN0cmluZyA9IC8qI19fUFVSRV9fKi9PYmplY3QudG9TdHJpbmcoKTtcbmZ1bmN0aW9uIGFzc2VydFByb3hpZXMoKSB7XG4gIGlmICghaGFzUHJveHkpIHtcbiAgICBkaWUocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJgUHJveHlgIG9iamVjdHMgYXJlIG5vdCBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIFBsZWFzZSBjb25maWd1cmUgTW9iWCB0byBlbmFibGUgYSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbi5gXCIgOiBcIlByb3h5IG5vdCBhdmFpbGFibGVcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQobXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZ2xvYmFsU3RhdGUudmVyaWZ5UHJveGllcykge1xuICAgIGRpZShcIk1vYlggaXMgY3VycmVudGx5IGNvbmZpZ3VyZWQgdG8gYmUgYWJsZSB0byBydW4gaW4gRVM1IG1vZGUsIGJ1dCBpbiBFUzUgTW9iWCB3b24ndCBiZSBhYmxlIHRvIFwiICsgbXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TmV4dElkKCkge1xuICByZXR1cm4gKytnbG9iYWxTdGF0ZS5tb2J4R3VpZDtcbn1cbi8qKlxyXG4gKiBNYWtlcyBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGlzIGludm9rZWQgYXQgbW9zdCBvbmNlLlxyXG4gKi9cbmZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICB2YXIgaW52b2tlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpbnZva2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludm9rZWQgPSB0cnVlO1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNTdHJpbmdpc2godmFsdWUpIHtcbiAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgaWYgKHByb3RvID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgcHJvdG9Db25zdHJ1Y3RvciA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIHByb3RvQ29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBwcm90b0NvbnN0cnVjdG9yLnRvU3RyaW5nKCkgPT09IHBsYWluT2JqZWN0U3RyaW5nO1xufVxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM3ODY1MTcwXG5mdW5jdGlvbiBpc0dlbmVyYXRvcihvYmopIHtcbiAgdmFyIGNvbnN0cnVjdG9yID0gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmouY29uc3RydWN0b3I7XG4gIGlmICghY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gY29uc3RydWN0b3IubmFtZSB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYWRkSGlkZGVuUHJvcChvYmplY3QsIHByb3BOYW1lLCB2YWx1ZSkge1xuICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BOYW1lLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZEhpZGRlbkZpbmFsUHJvcChvYmplY3QsIHByb3BOYW1lLCB2YWx1ZSkge1xuICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BOYW1lLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKG5hbWUsIHRoZUNsYXNzKSB7XG4gIHZhciBwcm9wTmFtZSA9IFwiaXNNb2JYXCIgKyBuYW1lO1xuICB0aGVDbGFzcy5wcm90b3R5cGVbcHJvcE5hbWVdID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIHhbcHJvcE5hbWVdID09PSB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gaXNFUzZNYXAodGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nIGluc3RhbmNlb2YgTWFwO1xufVxuZnVuY3Rpb24gaXNFUzZTZXQodGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nIGluc3RhbmNlb2YgU2V0O1xufVxudmFyIGhhc0dldE93blByb3BlcnR5U3ltYm9scyA9IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSBcInVuZGVmaW5lZFwiO1xuLyoqXHJcbiAqIFJldHVybnMgdGhlIGZvbGxvd2luZzogb3duIGVudW1lcmFibGUga2V5cyBhbmQgc3ltYm9scy5cclxuICovXG5mdW5jdGlvbiBnZXRQbGFpbk9iamVjdEtleXMob2JqZWN0KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgLy8gTm90IHN1cHBvcnRlZCBpbiBJRSwgc28gdGhlcmUgYXJlIG5vdCBnb2luZyB0byBiZSBzeW1ib2wgcHJvcHMgYW55d2F5Li4uXG4gIGlmICghaGFzR2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cbiAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gIGlmICghc3ltYm9scy5sZW5ndGgpIHtcbiAgICByZXR1cm4ga2V5cztcbiAgfVxuICByZXR1cm4gW10uY29uY2F0KGtleXMsIHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIG9iamVjdFByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgcyk7XG4gIH0pKTtcbn1cbi8vIEZyb20gSW1tZXIgdXRpbHNcbi8vIFJldHVybnMgYWxsIG93biBrZXlzLCBpbmNsdWRpbmcgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbGljXG52YXIgb3duS2V5cyA9IHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Qub3duS2V5cyA/IFJlZmxlY3Qub3duS2V5cyA6IGhhc0dldE93blByb3BlcnR5U3ltYm9scyA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSk7XG59IDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbmZ1bmN0aW9uIHN0cmluZ2lmeUtleShrZXkpIHtcbiAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ga2V5O1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiKSB7XG4gICAgcmV0dXJuIGtleS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBuZXcgU3RyaW5nKGtleSkudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgPyBcIlwiICsgdmFsdWUgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGhhc1Byb3AodGFyZ2V0LCBwcm9wKSB7XG4gIHJldHVybiBvYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHByb3ApO1xufVxuLy8gRnJvbSBJbW1lciB1dGlsc1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRhcmdldCkge1xuICAvLyBQb2x5ZmlsbCBuZWVkZWQgZm9yIEhlcm1lcyBhbmQgSUUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svaGVybWVzL2lzc3Vlcy8yNzRcbiAgdmFyIHJlcyA9IHt9O1xuICAvLyBOb3RlOiB3aXRob3V0IHBvbHlmaWxsIGZvciBvd25LZXlzLCBzeW1ib2xzIHdvbid0IGJlIHBpY2tlZCB1cFxuICBvd25LZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmVzW2tleV0gPSBnZXREZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgfSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChpdCkgbyA9IGl0O1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbnZhciBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCA9IC8qI19fUFVSRV9fKi9TeW1ib2woXCJtb2J4LXN0b3JlZC1hbm5vdGF0aW9uc1wiKTtcbi8qKlxyXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY3RzIGFzXHJcbiAqIC0gZGVjb3JhdG9yXHJcbiAqIC0gYW5ub3RhdGlvbiBvYmplY3RcclxuICovXG5mdW5jdGlvbiBjcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGFubm90YXRpb24pIHtcbiAgZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICBzdG9yZUFubm90YXRpb24odGFyZ2V0LCBwcm9wZXJ0eSwgYW5ub3RhdGlvbik7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVjb3JhdG9yLCBhbm5vdGF0aW9uKTtcbn1cbi8qKlxyXG4gKiBTdG9yZXMgYW5ub3RhdGlvbiB0byBwcm90b3R5cGUsXHJcbiAqIHNvIGl0IGNhbiBiZSBpbnNwZWN0ZWQgbGF0ZXIgYnkgYG1ha2VPYnNlcnZhYmxlYCBjYWxsZWQgZnJvbSBjb25zdHJ1Y3RvclxyXG4gKi9cbmZ1bmN0aW9uIHN0b3JlQW5ub3RhdGlvbihwcm90b3R5cGUsIGtleSwgYW5ub3RhdGlvbikge1xuICBpZiAoIWhhc1Byb3AocHJvdG90eXBlLCBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCkpIHtcbiAgICBhZGRIaWRkZW5Qcm9wKHByb3RvdHlwZSwgc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2wsIF9leHRlbmRzKHt9LCBwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSk7XG4gIH1cbiAgLy8gQG92ZXJyaWRlIG11c3Qgb3ZlcnJpZGUgc29tZXRoaW5nXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNPdmVycmlkZShhbm5vdGF0aW9uKSAmJiAhaGFzUHJvcChwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdLCBrZXkpKSB7XG4gICAgdmFyIGZpZWxkTmFtZSA9IHByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lICsgXCIucHJvdG90eXBlLlwiICsga2V5LnRvU3RyaW5nKCk7XG4gICAgZGllKFwiJ1wiICsgZmllbGROYW1lICsgXCInIGlzIGRlY29yYXRlZCB3aXRoICdvdmVycmlkZScsIFwiICsgXCJidXQgbm8gc3VjaCBkZWNvcmF0ZWQgbWVtYmVyIHdhcyBmb3VuZCBvbiBwcm90b3R5cGUuXCIpO1xuICB9XG4gIC8vIENhbm5vdCByZS1kZWNvcmF0ZVxuICBhc3NlcnROb3REZWNvcmF0ZWQocHJvdG90eXBlLCBhbm5vdGF0aW9uLCBrZXkpO1xuICAvLyBJZ25vcmUgb3ZlcnJpZGVcbiAgaWYgKCFpc092ZXJyaWRlKGFubm90YXRpb24pKSB7XG4gICAgcHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXVtrZXldID0gYW5ub3RhdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Tm90RGVjb3JhdGVkKHByb3RvdHlwZSwgYW5ub3RhdGlvbiwga2V5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzT3ZlcnJpZGUoYW5ub3RhdGlvbikgJiYgaGFzUHJvcChwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdLCBrZXkpKSB7XG4gICAgdmFyIGZpZWxkTmFtZSA9IHByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lICsgXCIucHJvdG90eXBlLlwiICsga2V5LnRvU3RyaW5nKCk7XG4gICAgdmFyIGN1cnJlbnRBbm5vdGF0aW9uVHlwZSA9IHByb3RvdHlwZVtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF1ba2V5XS5hbm5vdGF0aW9uVHlwZV87XG4gICAgdmFyIHJlcXVlc3RlZEFubm90YXRpb25UeXBlID0gYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV87XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdAXCIgKyByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSArIFwiJyB0byAnXCIgKyBmaWVsZE5hbWUgKyBcIic6XCIgKyAoXCJcXG5UaGUgZmllbGQgaXMgYWxyZWFkeSBkZWNvcmF0ZWQgd2l0aCAnQFwiICsgY3VycmVudEFubm90YXRpb25UeXBlICsgXCInLlwiKSArIFwiXFxuUmUtZGVjb3JhdGluZyBmaWVsZHMgaXMgbm90IGFsbG93ZWQuXCIgKyBcIlxcblVzZSAnQG92ZXJyaWRlJyBkZWNvcmF0b3IgZm9yIG1ldGhvZHMgb3ZlcnJpZGRlbiBieSBzdWJjbGFzcy5cIik7XG4gIH1cbn1cbi8qKlxyXG4gKiBDb2xsZWN0cyBhbm5vdGF0aW9ucyBmcm9tIHByb3RvdHlwZXMgYW5kIHN0b3JlcyB0aGVtIG9uIHRhcmdldCAoaW5zdGFuY2UpXHJcbiAqL1xuZnVuY3Rpb24gY29sbGVjdFN0b3JlZEFubm90YXRpb25zKHRhcmdldCkge1xuICBpZiAoIWhhc1Byb3AodGFyZ2V0LCBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICF0YXJnZXRbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSB7XG4gICAgICBkaWUoXCJObyBhbm5vdGF0aW9ucyB3ZXJlIHBhc3NlZCB0byBtYWtlT2JzZXJ2YWJsZSwgYnV0IG5vIGRlY29yYXRlZCBtZW1iZXJzIGhhdmUgYmVlbiBmb3VuZCBlaXRoZXJcIik7XG4gICAgfVxuICAgIC8vIFdlIG5lZWQgYSBjb3B5IGFzIHdlIHdpbGwgcmVtb3ZlIGFubm90YXRpb24gZnJvbSB0aGUgbGlzdCBvbmNlIGl0J3MgYXBwbGllZC5cbiAgICBhZGRIaWRkZW5Qcm9wKHRhcmdldCwgc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2wsIF9leHRlbmRzKHt9LCB0YXJnZXRbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldFtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF07XG59XG5cbnZhciAkbW9ieCA9IC8qI19fUFVSRV9fKi9TeW1ib2woXCJtb2J4IGFkbWluaXN0cmF0aW9uXCIpO1xudmFyIEF0b20gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBmb3IgZWZmZWN0aXZlIHVub2JzZXJ2aW5nLiBCYXNlQXRvbSBoYXMgdHJ1ZSwgZm9yIGV4dHJhIG9wdGltaXphdGlvbiwgc28gaXRzIG9uQmVjb21lVW5vYnNlcnZlZCBuZXZlciBnZXRzIGNhbGxlZCwgYmVjYXVzZSBpdCdzIG5vdCBuZWVkZWRcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgYXRvbS4gRm9yIGRlYnVnZ2luZyBwdXJwb3NlcyBpdCBpcyByZWNvbW1lbmRlZCB0byBnaXZlIGl0IGEgbmFtZS5cclxuICAgKiBUaGUgb25CZWNvbWVPYnNlcnZlZCBhbmQgb25CZWNvbWVVbm9ic2VydmVkIGNhbGxiYWNrcyBjYW4gYmUgdXNlZCBmb3IgcmVzb3VyY2UgbWFuYWdlbWVudC5cclxuICAgKi9cbiAgZnVuY3Rpb24gQXRvbShuYW1lXykge1xuICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lXyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiQXRvbUBcIiArIGdldE5leHRJZCgpIDogXCJBdG9tXCI7XG4gICAgfVxuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5pc1BlbmRpbmdVbm9ic2VydmF0aW9uXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNCZWluZ09ic2VydmVkXyA9IGZhbHNlO1xuICAgIHRoaXMub2JzZXJ2ZXJzXyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmRpZmZWYWx1ZV8gPSAwO1xuICAgIHRoaXMubGFzdEFjY2Vzc2VkQnlfID0gMDtcbiAgICB0aGlzLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbiAgICB0aGlzLm9uQk9MID0gdm9pZCAwO1xuICAgIHRoaXMub25CVU9MID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcbiAgfVxuICAvLyBvbkJlY29tZU9ic2VydmVkTGlzdGVuZXJzXG4gIHZhciBfcHJvdG8gPSBBdG9tLnByb3RvdHlwZTtcbiAgX3Byb3RvLm9uQk8gPSBmdW5jdGlvbiBvbkJPKCkge1xuICAgIGlmICh0aGlzLm9uQk9MKSB7XG4gICAgICB0aGlzLm9uQk9MLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ub25CVU8gPSBmdW5jdGlvbiBvbkJVTygpIHtcbiAgICBpZiAodGhpcy5vbkJVT0wpIHtcbiAgICAgIHRoaXMub25CVU9MLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEludm9rZSB0aGlzIG1ldGhvZCB0byBub3RpZnkgbW9ieCB0aGF0IHlvdXIgYXRvbSBoYXMgYmVlbiB1c2VkIHNvbWVob3cuXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGN1cnJlbnRseSBhIHJlYWN0aXZlIGNvbnRleHQuXHJcbiAgICovO1xuICBfcHJvdG8ucmVwb3J0T2JzZXJ2ZWQgPSBmdW5jdGlvbiByZXBvcnRPYnNlcnZlZCQxKCkge1xuICAgIHJldHVybiByZXBvcnRPYnNlcnZlZCh0aGlzKTtcbiAgfVxuICAvKipcclxuICAgKiBJbnZva2UgdGhpcyBtZXRob2QgX2FmdGVyXyB0aGlzIG1ldGhvZCBoYXMgY2hhbmdlZCB0byBzaWduYWwgbW9ieCB0aGF0IGFsbCBpdHMgb2JzZXJ2ZXJzIHNob3VsZCBpbnZhbGlkYXRlLlxyXG4gICAqLztcbiAgX3Byb3RvLnJlcG9ydENoYW5nZWQgPSBmdW5jdGlvbiByZXBvcnRDaGFuZ2VkKCkge1xuICAgIHN0YXJ0QmF0Y2goKTtcbiAgICBwcm9wYWdhdGVDaGFuZ2VkKHRoaXMpO1xuICAgIGVuZEJhdGNoKCk7XG4gIH07XG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVfO1xuICB9O1xuICByZXR1cm4gQXRvbTtcbn0oKTtcbnZhciBpc0F0b20gPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIkF0b21cIiwgQXRvbSk7XG5mdW5jdGlvbiBjcmVhdGVBdG9tKG5hbWUsIG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyLCBvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyKSB7XG4gIGlmIChvbkJlY29tZU9ic2VydmVkSGFuZGxlciA9PT0gdm9pZCAwKSB7XG4gICAgb25CZWNvbWVPYnNlcnZlZEhhbmRsZXIgPSBub29wO1xuICB9XG4gIGlmIChvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyID09PSB2b2lkIDApIHtcbiAgICBvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyID0gbm9vcDtcbiAgfVxuICB2YXIgYXRvbSA9IG5ldyBBdG9tKG5hbWUpO1xuICAvLyBkZWZhdWx0IGBub29wYCBsaXN0ZW5lciB3aWxsIG5vdCBpbml0aWFsaXplIHRoZSBob29rIFNldFxuICBpZiAob25CZWNvbWVPYnNlcnZlZEhhbmRsZXIgIT09IG5vb3ApIHtcbiAgICBvbkJlY29tZU9ic2VydmVkKGF0b20sIG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyKTtcbiAgfVxuICBpZiAob25CZWNvbWVVbm9ic2VydmVkSGFuZGxlciAhPT0gbm9vcCkge1xuICAgIG9uQmVjb21lVW5vYnNlcnZlZChhdG9tLCBvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyKTtcbiAgfVxuICByZXR1cm4gYXRvbTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHlDb21wYXJlcihhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gc3RydWN0dXJhbENvbXBhcmVyKGEsIGIpIHtcbiAgcmV0dXJuIGRlZXBFcXVhbChhLCBiKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dDb21wYXJlcihhLCBiKSB7XG4gIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgMSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZXIoYSwgYikge1xuICBpZiAoT2JqZWN0LmlzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5pcyhhLCBiKTtcbiAgfVxuICByZXR1cm4gYSA9PT0gYiA/IGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiIDogYSAhPT0gYSAmJiBiICE9PSBiO1xufVxudmFyIGNvbXBhcmVyID0ge1xuICBpZGVudGl0eTogaWRlbnRpdHlDb21wYXJlcixcbiAgc3RydWN0dXJhbDogc3RydWN0dXJhbENvbXBhcmVyLFxuICBcImRlZmF1bHRcIjogZGVmYXVsdENvbXBhcmVyLFxuICBzaGFsbG93OiBzaGFsbG93Q29tcGFyZXJcbn07XG5cbmZ1bmN0aW9uIGRlZXBFbmhhbmNlcih2LCBfLCBuYW1lKSB7XG4gIC8vIGl0IGlzIGFuIG9ic2VydmFibGUgYWxyZWFkeSwgZG9uZVxuICBpZiAoaXNPYnNlcnZhYmxlKHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgLy8gc29tZXRoaW5nIHRoYXQgY2FuIGJlIGNvbnZlcnRlZCBhbmQgbXV0YXRlZD9cbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5hcnJheSh2LCB7XG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzUGxhaW5PYmplY3QodikpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5vYmplY3QodiwgdW5kZWZpbmVkLCB7XG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzRVM2TWFwKHYpKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUubWFwKHYsIHtcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNFUzZTZXQodikpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5zZXQodiwge1xuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiICYmICFpc0FjdGlvbih2KSAmJiAhaXNGbG93KHYpKSB7XG4gICAgaWYgKGlzR2VuZXJhdG9yKHYpKSB7XG4gICAgICByZXR1cm4gZmxvdyh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF1dG9BY3Rpb24obmFtZSwgdik7XG4gICAgfVxuICB9XG4gIHJldHVybiB2O1xufVxuZnVuY3Rpb24gc2hhbGxvd0VuaGFuY2VyKHYsIF8sIG5hbWUpIHtcbiAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh2KSB8fCBpc09ic2VydmFibGVBcnJheSh2KSB8fCBpc09ic2VydmFibGVNYXAodikgfHwgaXNPYnNlcnZhYmxlU2V0KHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5hcnJheSh2LCB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGVlcDogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNQbGFpbk9iamVjdCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdCh2LCB1bmRlZmluZWQsIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkZWVwOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGlmIChpc0VTNk1hcCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGVlcDogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNFUzZTZXQodikpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5zZXQodiwge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGRlZXA6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGRpZShcIlRoZSBzaGFsbG93IG1vZGlmaWVyIC8gZGVjb3JhdG9yIGNhbiBvbmx5IHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBhcnJheXMsIG9iamVjdHMsIG1hcHMgYW5kIHNldHNcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZmVyZW5jZUVuaGFuY2VyKG5ld1ZhbHVlKSB7XG4gIC8vIG5ldmVyIHR1cm4gaW50byBhbiBvYnNlcnZhYmxlXG4gIHJldHVybiBuZXdWYWx1ZTtcbn1cbmZ1bmN0aW9uIHJlZlN0cnVjdEVuaGFuY2VyKHYsIG9sZFZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNPYnNlcnZhYmxlKHYpKSB7XG4gICAgZGllKFwib2JzZXJ2YWJsZS5zdHJ1Y3Qgc2hvdWxkIG5vdCBiZSB1c2VkIHdpdGggb2JzZXJ2YWJsZSB2YWx1ZXNcIik7XG4gIH1cbiAgaWYgKGRlZXBFcXVhbCh2LCBvbGRWYWx1ZSkpIHtcbiAgICByZXR1cm4gb2xkVmFsdWU7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5cbnZhciBPVkVSUklERSA9IFwib3ZlcnJpZGVcIjtcbnZhciBvdmVycmlkZSA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKHtcbiAgYW5ub3RhdGlvblR5cGVfOiBPVkVSUklERSxcbiAgbWFrZV86IG1ha2VfLFxuICBleHRlbmRfOiBleHRlbmRfXG59KTtcbmZ1bmN0aW9uIGlzT3ZlcnJpZGUoYW5ub3RhdGlvbikge1xuICByZXR1cm4gYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV8gPT09IE9WRVJSSURFO1xufVxuZnVuY3Rpb24gbWFrZV8oYWRtLCBrZXkpIHtcbiAgLy8gTXVzdCBub3QgYmUgcGxhaW4gb2JqZWN0XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgYWRtLmlzUGxhaW5PYmplY3RfKSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIHRoaXMuYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyB0aGlzLmFubm90YXRpb25UeXBlXyArIFwiJyBjYW5ub3QgYmUgdXNlZCBvbiBwbGFpbiBvYmplY3RzLlwiKSk7XG4gIH1cbiAgLy8gTXVzdCBvdmVycmlkZSBzb21ldGhpbmdcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaGFzUHJvcChhZG0uYXBwbGllZEFubm90YXRpb25zXywga2V5KSkge1xuICAgIGRpZShcIidcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIicgaXMgYW5ub3RhdGVkIHdpdGggJ1wiICsgdGhpcy5hbm5vdGF0aW9uVHlwZV8gKyBcIicsIFwiICsgXCJidXQgbm8gc3VjaCBhbm5vdGF0ZWQgbWVtYmVyIHdhcyBmb3VuZCBvbiBwcm90b3R5cGUuXCIpO1xuICB9XG4gIHJldHVybiAwIC8qIENhbmNlbCAqLztcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIGRpZShcIidcIiArIHRoaXMuYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCAnbWFrZU9ic2VydmFibGUnXCIpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IG5hbWUsXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDEsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQxXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlXyQxKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfO1xuICAvLyBib3VuZFxuICBpZiAoKF90aGlzJG9wdGlvbnNfID0gdGhpcy5vcHRpb25zXykgIT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zXy5ib3VuZCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCA/IDAgLyogQ2FuY2VsICovIDogMSAvKiBCcmVhayAqLztcbiAgfVxuICAvLyBvd25cbiAgaWYgKHNvdXJjZSA9PT0gYWRtLnRhcmdldF8pIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwgPyAwIC8qIENhbmNlbCAqLyA6IDIgLyogQ29udGludWUgKi87XG4gIH1cbiAgLy8gcHJvdG90eXBlXG4gIGlmIChpc0FjdGlvbihkZXNjcmlwdG9yLnZhbHVlKSkge1xuICAgIC8vIEEgcHJvdG90eXBlIGNvdWxkIGhhdmUgYmVlbiBhbm5vdGF0ZWQgYWxyZWFkeSBieSBvdGhlciBjb25zdHJ1Y3RvcixcbiAgICAvLyByZXN0IG9mIHRoZSBwcm90byBjaGFpbiBtdXN0IGJlIGFubm90YXRlZCBhbHJlYWR5XG4gICAgcmV0dXJuIDEgLyogQnJlYWsgKi87XG4gIH1cblxuICB2YXIgYWN0aW9uRGVzY3JpcHRvciA9IGNyZWF0ZUFjdGlvbkRlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKTtcbiAgZGVmaW5lUHJvcGVydHkoc291cmNlLCBrZXksIGFjdGlvbkRlc2NyaXB0b3IpO1xuICByZXR1cm4gMiAvKiBDb250aW51ZSAqLztcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyQxKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgdmFyIGFjdGlvbkRlc2NyaXB0b3IgPSBjcmVhdGVBY3Rpb25EZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCBhY3Rpb25EZXNjcmlwdG9yLCBwcm94eVRyYXApO1xufVxuZnVuY3Rpb24gYXNzZXJ0QWN0aW9uRGVzY3JpcHRvcihhZG0sIF9yZWYsIGtleSwgX3JlZjIpIHtcbiAgdmFyIGFubm90YXRpb25UeXBlXyA9IF9yZWYuYW5ub3RhdGlvblR5cGVfO1xuICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCBvbiBwcm9wZXJ0aWVzIHdpdGggYSBmdW5jdGlvbiB2YWx1ZS5cIikpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25EZXNjcmlwdG9yKGFkbSwgYW5ub3RhdGlvbiwga2V5LCBkZXNjcmlwdG9yLFxuLy8gcHJvdmlkZXMgYWJpbGl0eSB0byBkaXNhYmxlIHNhZmVEZXNjcmlwdG9ycyBmb3IgcHJvdG90eXBlc1xuc2FmZURlc2NyaXB0b3JzKSB7XG4gIHZhciBfYW5ub3RhdGlvbiRvcHRpb25zXywgX2Fubm90YXRpb24kb3B0aW9uc18kLCBfYW5ub3RhdGlvbiRvcHRpb25zXzIsIF9hbm5vdGF0aW9uJG9wdGlvbnNfJDIsIF9hbm5vdGF0aW9uJG9wdGlvbnNfMywgX2Fubm90YXRpb24kb3B0aW9uc180LCBfYWRtJHByb3h5XzI7XG4gIGlmIChzYWZlRGVzY3JpcHRvcnMgPT09IHZvaWQgMCkge1xuICAgIHNhZmVEZXNjcmlwdG9ycyA9IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycztcbiAgfVxuICBhc3NlcnRBY3Rpb25EZXNjcmlwdG9yKGFkbSwgYW5ub3RhdGlvbiwga2V5LCBkZXNjcmlwdG9yKTtcbiAgdmFyIHZhbHVlID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgaWYgKChfYW5ub3RhdGlvbiRvcHRpb25zXyA9IGFubm90YXRpb24ub3B0aW9uc18pICE9IG51bGwgJiYgX2Fubm90YXRpb24kb3B0aW9uc18uYm91bmQpIHtcbiAgICB2YXIgX2FkbSRwcm94eV87XG4gICAgdmFsdWUgPSB2YWx1ZS5iaW5kKChfYWRtJHByb3h5XyA9IGFkbS5wcm94eV8pICE9IG51bGwgPyBfYWRtJHByb3h5XyA6IGFkbS50YXJnZXRfKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBjcmVhdGVBY3Rpb24oKF9hbm5vdGF0aW9uJG9wdGlvbnNfJCA9IChfYW5ub3RhdGlvbiRvcHRpb25zXzIgPSBhbm5vdGF0aW9uLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX2Fubm90YXRpb24kb3B0aW9uc18yLm5hbWUpICE9IG51bGwgPyBfYW5ub3RhdGlvbiRvcHRpb25zXyQgOiBrZXkudG9TdHJpbmcoKSwgdmFsdWUsIChfYW5ub3RhdGlvbiRvcHRpb25zXyQyID0gKF9hbm5vdGF0aW9uJG9wdGlvbnNfMyA9IGFubm90YXRpb24ub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfYW5ub3RhdGlvbiRvcHRpb25zXzMuYXV0b0FjdGlvbikgIT0gbnVsbCA/IF9hbm5vdGF0aW9uJG9wdGlvbnNfJDIgOiBmYWxzZSxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvZGlzY3Vzc2lvbnMvMzE0MFxuICAgIChfYW5ub3RhdGlvbiRvcHRpb25zXzQgPSBhbm5vdGF0aW9uLm9wdGlvbnNfKSAhPSBudWxsICYmIF9hbm5vdGF0aW9uJG9wdGlvbnNfNC5ib3VuZCA/IChfYWRtJHByb3h5XzIgPSBhZG0ucHJveHlfKSAhPSBudWxsID8gX2FkbSRwcm94eV8yIDogYWRtLnRhcmdldF8gOiB1bmRlZmluZWQpLFxuICAgIC8vIE5vbi1jb25maWd1cmFibGUgZm9yIGNsYXNzZXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsIGZpZWxkIHJlZGVmaW5pdGlvbiBpbiBzdWJjbGFzc1xuICAgIGNvbmZpZ3VyYWJsZTogc2FmZURlc2NyaXB0b3JzID8gYWRtLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvcHVsbC8yNjQxI2lzc3VlY29tbWVudC03MzcyOTIwNThcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAvLyBOb24tb2JzZXZhYmxlLCB0aGVyZWZvcmUgbm9uLXdyaXRhYmxlXG4gICAgLy8gQWxzbyBwcmV2ZW50cyByZXdyaXRpbmcgaW4gc3ViY2xhc3MgY29uc3RydWN0b3JcbiAgICB3cml0YWJsZTogc2FmZURlc2NyaXB0b3JzID8gZmFsc2UgOiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZsb3dBbm5vdGF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IG5hbWUsXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDIsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQyXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlXyQyKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfO1xuICAvLyBvd25cbiAgaWYgKHNvdXJjZSA9PT0gYWRtLnRhcmdldF8pIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwgPyAwIC8qIENhbmNlbCAqLyA6IDIgLyogQ29udGludWUgKi87XG4gIH1cbiAgLy8gcHJvdG90eXBlXG4gIC8vIGJvdW5kIC0gbXVzdCBhbm5vdGF0ZSBwcm90b3MgdG8gc3VwcG9ydCBzdXBlci5mbG93KClcbiAgaWYgKChfdGhpcyRvcHRpb25zXyA9IHRoaXMub3B0aW9uc18pICE9IG51bGwgJiYgX3RoaXMkb3B0aW9uc18uYm91bmQgJiYgKCFoYXNQcm9wKGFkbS50YXJnZXRfLCBrZXkpIHx8ICFpc0Zsb3coYWRtLnRhcmdldF9ba2V5XSkpKSB7XG4gICAgaWYgKHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMCAvKiBDYW5jZWwgKi87XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzRmxvdyhkZXNjcmlwdG9yLnZhbHVlKSkge1xuICAgIC8vIEEgcHJvdG90eXBlIGNvdWxkIGhhdmUgYmVlbiBhbm5vdGF0ZWQgYWxyZWFkeSBieSBvdGhlciBjb25zdHJ1Y3RvcixcbiAgICAvLyByZXN0IG9mIHRoZSBwcm90byBjaGFpbiBtdXN0IGJlIGFubm90YXRlZCBhbHJlYWR5XG4gICAgcmV0dXJuIDEgLyogQnJlYWsgKi87XG4gIH1cblxuICB2YXIgZmxvd0Rlc2NyaXB0b3IgPSBjcmVhdGVGbG93RGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvciwgZmFsc2UsIGZhbHNlKTtcbiAgZGVmaW5lUHJvcGVydHkoc291cmNlLCBrZXksIGZsb3dEZXNjcmlwdG9yKTtcbiAgcmV0dXJuIDIgLyogQ29udGludWUgKi87XG59XG5cbmZ1bmN0aW9uIGV4dGVuZF8kMihhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zXzI7XG4gIHZhciBmbG93RGVzY3JpcHRvciA9IGNyZWF0ZUZsb3dEZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yLCAoX3RoaXMkb3B0aW9uc18yID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfMi5ib3VuZCk7XG4gIHJldHVybiBhZG0uZGVmaW5lUHJvcGVydHlfKGtleSwgZmxvd0Rlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG59XG5mdW5jdGlvbiBhc3NlcnRGbG93RGVzY3JpcHRvcihhZG0sIF9yZWYsIGtleSwgX3JlZjIpIHtcbiAgdmFyIGFubm90YXRpb25UeXBlXyA9IF9yZWYuYW5ub3RhdGlvblR5cGVfO1xuICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCBvbiBwcm9wZXJ0aWVzIHdpdGggYSBnZW5lcmF0b3IgZnVuY3Rpb24gdmFsdWUuXCIpKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRmxvd0Rlc2NyaXB0b3IoYWRtLCBhbm5vdGF0aW9uLCBrZXksIGRlc2NyaXB0b3IsIGJvdW5kLFxuLy8gcHJvdmlkZXMgYWJpbGl0eSB0byBkaXNhYmxlIHNhZmVEZXNjcmlwdG9ycyBmb3IgcHJvdG90eXBlc1xuc2FmZURlc2NyaXB0b3JzKSB7XG4gIGlmIChzYWZlRGVzY3JpcHRvcnMgPT09IHZvaWQgMCkge1xuICAgIHNhZmVEZXNjcmlwdG9ycyA9IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycztcbiAgfVxuICBhc3NlcnRGbG93RGVzY3JpcHRvcihhZG0sIGFubm90YXRpb24sIGtleSwgZGVzY3JpcHRvcik7XG4gIHZhciB2YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gIC8vIEluIGNhc2Ugb2YgZmxvdy5ib3VuZCwgdGhlIGRlc2NyaXB0b3IgY2FuIGJlIGZyb20gYWxyZWFkeSBhbm5vdGF0ZWQgcHJvdG90eXBlXG4gIGlmICghaXNGbG93KHZhbHVlKSkge1xuICAgIHZhbHVlID0gZmxvdyh2YWx1ZSk7XG4gIH1cbiAgaWYgKGJvdW5kKSB7XG4gICAgdmFyIF9hZG0kcHJveHlfO1xuICAgIC8vIFdlIGRvIG5vdCBrZWVwIG9yaWdpbmFsIGZ1bmN0aW9uIGFyb3VuZCwgc28gd2UgYmluZCB0aGUgZXhpc3RpbmcgZmxvd1xuICAgIHZhbHVlID0gdmFsdWUuYmluZCgoX2FkbSRwcm94eV8gPSBhZG0ucHJveHlfKSAhPSBudWxsID8gX2FkbSRwcm94eV8gOiBhZG0udGFyZ2V0Xyk7XG4gICAgLy8gVGhpcyBpcyBub3JtYWxseSBzZXQgYnkgYGZsb3dgLCBidXQgYGJpbmRgIHJldHVybnMgbmV3IGZ1bmN0aW9uLi4uXG4gICAgdmFsdWUuaXNNb2JYRmxvdyA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgLy8gTm9uLWNvbmZpZ3VyYWJsZSBmb3IgY2xhc3Nlc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWwgZmllbGQgcmVkZWZpbml0aW9uIGluIHN1YmNsYXNzXG4gICAgY29uZmlndXJhYmxlOiBzYWZlRGVzY3JpcHRvcnMgPyBhZG0uaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9wdWxsLzI2NDEjaXNzdWVjb21tZW50LTczNzI5MjA1OFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIC8vIE5vbi1vYnNldmFibGUsIHRoZXJlZm9yZSBub24td3JpdGFibGVcbiAgICAvLyBBbHNvIHByZXZlbnRzIHJld3JpdGluZyBpbiBzdWJjbGFzcyBjb25zdHJ1Y3RvclxuICAgIHdyaXRhYmxlOiBzYWZlRGVzY3JpcHRvcnMgPyBmYWxzZSA6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRBbm5vdGF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IG5hbWUsXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDMsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQzXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlXyQzKGFkbSwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIHJldHVybiB0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCA/IDAgLyogQ2FuY2VsICovIDogMSAvKiBCcmVhayAqLztcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyQzKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgYXNzZXJ0Q29tcHV0ZWREZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVDb21wdXRlZFByb3BlcnR5XyhrZXksIF9leHRlbmRzKHt9LCB0aGlzLm9wdGlvbnNfLCB7XG4gICAgZ2V0OiBkZXNjcmlwdG9yLmdldCxcbiAgICBzZXQ6IGRlc2NyaXB0b3Iuc2V0XG4gIH0pLCBwcm94eVRyYXApO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q29tcHV0ZWREZXNjcmlwdG9yKGFkbSwgX3JlZiwga2V5LCBfcmVmMikge1xuICB2YXIgYW5ub3RhdGlvblR5cGVfID0gX3JlZi5hbm5vdGF0aW9uVHlwZV87XG4gIHZhciBnZXQgPSBfcmVmMi5nZXQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWdldCkge1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgdG8gJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzpcIiArIChcIlxcbidcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyBjYW4gb25seSBiZSB1c2VkIG9uIGdldHRlcigrc2V0dGVyKSBwcm9wZXJ0aWVzLlwiKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24obmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogbmFtZSxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kNCxcbiAgICBleHRlbmRfOiBleHRlbmRfJDRcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VfJDQoYWRtLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMCAvKiBDYW5jZWwgKi8gOiAxIC8qIEJyZWFrICovO1xufVxuXG5mdW5jdGlvbiBleHRlbmRfJDQoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICB2YXIgX3RoaXMkb3B0aW9uc18kZW5oYW5jLCBfdGhpcyRvcHRpb25zXztcbiAgYXNzZXJ0T2JzZXJ2YWJsZURlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IpO1xuICByZXR1cm4gYWRtLmRlZmluZU9ic2VydmFibGVQcm9wZXJ0eV8oa2V5LCBkZXNjcmlwdG9yLnZhbHVlLCAoX3RoaXMkb3B0aW9uc18kZW5oYW5jID0gKF90aGlzJG9wdGlvbnNfID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfLmVuaGFuY2VyKSAhPSBudWxsID8gX3RoaXMkb3B0aW9uc18kZW5oYW5jIDogZGVlcEVuaGFuY2VyLCBwcm94eVRyYXApO1xufVxuZnVuY3Rpb24gYXNzZXJ0T2JzZXJ2YWJsZURlc2NyaXB0b3IoYWRtLCBfcmVmLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgdmFyIGFubm90YXRpb25UeXBlXyA9IF9yZWYuYW5ub3RhdGlvblR5cGVfO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICEoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpKSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyB0byAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOlwiICsgKFwiXFxuJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbm5vdCBiZSB1c2VkIG9uIGdldHRlci9zZXR0ZXIgcHJvcGVydGllc1wiKSk7XG4gIH1cbn1cblxudmFyIEFVVE8gPSBcInRydWVcIjtcbnZhciBhdXRvQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBdXRvQW5ub3RhdGlvbigpO1xuZnVuY3Rpb24gY3JlYXRlQXV0b0Fubm90YXRpb24ob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogQVVUTyxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kNSxcbiAgICBleHRlbmRfOiBleHRlbmRfJDVcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VfJDUoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSkge1xuICB2YXIgX3RoaXMkb3B0aW9uc18zLCBfdGhpcyRvcHRpb25zXzQ7XG4gIC8vIGdldHRlciAtPiBjb21wdXRlZFxuICBpZiAoZGVzY3JpcHRvci5nZXQpIHtcbiAgICByZXR1cm4gY29tcHV0ZWQubWFrZV8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG4gIH1cbiAgLy8gbG9uZSBzZXR0ZXIgLT4gYWN0aW9uIHNldHRlclxuICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcbiAgICAvLyBUT0RPIG1ha2UgYWN0aW9uIGFwcGxpY2FibGUgdG8gc2V0dGVyIGFuZCBkZWxlZ2F0ZSB0byBhY3Rpb24ubWFrZV9cbiAgICB2YXIgc2V0ID0gY3JlYXRlQWN0aW9uKGtleS50b1N0cmluZygpLCBkZXNjcmlwdG9yLnNldCk7XG4gICAgLy8gb3duXG4gICAgaWYgKHNvdXJjZSA9PT0gYWRtLnRhcmdldF8pIHtcbiAgICAgIHJldHVybiBhZG0uZGVmaW5lUHJvcGVydHlfKGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycyA/IGFkbS5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgICAgIHNldDogc2V0XG4gICAgICB9KSA9PT0gbnVsbCA/IDAgLyogQ2FuY2VsICovIDogMiAvKiBDb250aW51ZSAqLztcbiAgICB9XG4gICAgLy8gcHJvdG9cbiAgICBkZWZpbmVQcm9wZXJ0eShzb3VyY2UsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgc2V0OiBzZXRcbiAgICB9KTtcbiAgICByZXR1cm4gMiAvKiBDb250aW51ZSAqLztcbiAgfVxuICAvLyBmdW5jdGlvbiBvbiBwcm90byAtPiBhdXRvQWN0aW9uL2Zsb3dcbiAgaWYgKHNvdXJjZSAhPT0gYWRtLnRhcmdldF8gJiYgdHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBfdGhpcyRvcHRpb25zXzI7XG4gICAgaWYgKGlzR2VuZXJhdG9yKGRlc2NyaXB0b3IudmFsdWUpKSB7XG4gICAgICB2YXIgX3RoaXMkb3B0aW9uc187XG4gICAgICB2YXIgZmxvd0Fubm90YXRpb24gPSAoX3RoaXMkb3B0aW9uc18gPSB0aGlzLm9wdGlvbnNfKSAhPSBudWxsICYmIF90aGlzJG9wdGlvbnNfLmF1dG9CaW5kID8gZmxvdy5ib3VuZCA6IGZsb3c7XG4gICAgICByZXR1cm4gZmxvd0Fubm90YXRpb24ubWFrZV8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG4gICAgfVxuICAgIHZhciBhY3Rpb25Bbm5vdGF0aW9uID0gKF90aGlzJG9wdGlvbnNfMiA9IHRoaXMub3B0aW9uc18pICE9IG51bGwgJiYgX3RoaXMkb3B0aW9uc18yLmF1dG9CaW5kID8gYXV0b0FjdGlvbi5ib3VuZCA6IGF1dG9BY3Rpb247XG4gICAgcmV0dXJuIGFjdGlvbkFubm90YXRpb24ubWFrZV8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG4gIH1cbiAgLy8gb3RoZXIgLT4gb2JzZXJ2YWJsZVxuICAvLyBDb3B5IHByb3BzIGZyb20gcHJvdG8gYXMgd2VsbCwgc2VlIHRlc3Q6XG4gIC8vIFwiZGVjb3JhdGUgc2hvdWxkIHdvcmsgd2l0aCBPYmplY3QuY3JlYXRlXCJcbiAgdmFyIG9ic2VydmFibGVBbm5vdGF0aW9uID0gKChfdGhpcyRvcHRpb25zXzMgPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc18zLmRlZXApID09PSBmYWxzZSA/IG9ic2VydmFibGUucmVmIDogb2JzZXJ2YWJsZTtcbiAgLy8gaWYgZnVuY3Rpb24gcmVzcGVjdCBhdXRvQmluZCBvcHRpb25cbiAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgKF90aGlzJG9wdGlvbnNfNCA9IHRoaXMub3B0aW9uc18pICE9IG51bGwgJiYgX3RoaXMkb3B0aW9uc180LmF1dG9CaW5kKSB7XG4gICAgdmFyIF9hZG0kcHJveHlfO1xuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlLmJpbmQoKF9hZG0kcHJveHlfID0gYWRtLnByb3h5XykgIT0gbnVsbCA/IF9hZG0kcHJveHlfIDogYWRtLnRhcmdldF8pO1xuICB9XG4gIHJldHVybiBvYnNlcnZhYmxlQW5ub3RhdGlvbi5tYWtlXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcbn1cbmZ1bmN0aW9uIGV4dGVuZF8kNShhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zXzUsIF90aGlzJG9wdGlvbnNfNjtcbiAgLy8gZ2V0dGVyIC0+IGNvbXB1dGVkXG4gIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgIHJldHVybiBjb21wdXRlZC5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApO1xuICB9XG4gIC8vIGxvbmUgc2V0dGVyIC0+IGFjdGlvbiBzZXR0ZXJcbiAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgLy8gVE9ETyBtYWtlIGFjdGlvbiBhcHBsaWNhYmxlIHRvIHNldHRlciBhbmQgZGVsZWdhdGUgdG8gYWN0aW9uLmV4dGVuZF9cbiAgICByZXR1cm4gYWRtLmRlZmluZVByb3BlcnR5XyhrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZ2xvYmFsU3RhdGUuc2FmZURlc2NyaXB0b3JzID8gYWRtLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAgIHNldDogY3JlYXRlQWN0aW9uKGtleS50b1N0cmluZygpLCBkZXNjcmlwdG9yLnNldClcbiAgICB9LCBwcm94eVRyYXApO1xuICB9XG4gIC8vIG90aGVyIC0+IG9ic2VydmFibGVcbiAgLy8gaWYgZnVuY3Rpb24gcmVzcGVjdCBhdXRvQmluZCBvcHRpb25cbiAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgKF90aGlzJG9wdGlvbnNfNSA9IHRoaXMub3B0aW9uc18pICE9IG51bGwgJiYgX3RoaXMkb3B0aW9uc181LmF1dG9CaW5kKSB7XG4gICAgdmFyIF9hZG0kcHJveHlfMjtcbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZGVzY3JpcHRvci52YWx1ZS5iaW5kKChfYWRtJHByb3h5XzIgPSBhZG0ucHJveHlfKSAhPSBudWxsID8gX2FkbSRwcm94eV8yIDogYWRtLnRhcmdldF8pO1xuICB9XG4gIHZhciBvYnNlcnZhYmxlQW5ub3RhdGlvbiA9ICgoX3RoaXMkb3B0aW9uc182ID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfNi5kZWVwKSA9PT0gZmFsc2UgPyBvYnNlcnZhYmxlLnJlZiA6IG9ic2VydmFibGU7XG4gIHJldHVybiBvYnNlcnZhYmxlQW5ub3RhdGlvbi5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApO1xufVxuXG52YXIgT0JTRVJWQUJMRSA9IFwib2JzZXJ2YWJsZVwiO1xudmFyIE9CU0VSVkFCTEVfUkVGID0gXCJvYnNlcnZhYmxlLnJlZlwiO1xudmFyIE9CU0VSVkFCTEVfU0hBTExPVyA9IFwib2JzZXJ2YWJsZS5zaGFsbG93XCI7XG52YXIgT0JTRVJWQUJMRV9TVFJVQ1QgPSBcIm9ic2VydmFibGUuc3RydWN0XCI7XG4vLyBQcmVkZWZpbmVkIGJhZ3Mgb2YgY3JlYXRlIG9ic2VydmFibGUgb3B0aW9ucywgdG8gYXZvaWQgYWxsb2NhdGluZyB0ZW1wb3JhcmlseSBvcHRpb24gb2JqZWN0c1xuLy8gaW4gdGhlIG1ham9yaXR5IG9mIGNhc2VzXG52YXIgZGVmYXVsdENyZWF0ZU9ic2VydmFibGVPcHRpb25zID0ge1xuICBkZWVwOiB0cnVlLFxuICBuYW1lOiB1bmRlZmluZWQsXG4gIGRlZmF1bHREZWNvcmF0b3I6IHVuZGVmaW5lZCxcbiAgcHJveHk6IHRydWVcbn07XG5PYmplY3QuZnJlZXplKGRlZmF1bHRDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyk7XG5mdW5jdGlvbiBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKHRoaW5nKSB7XG4gIHJldHVybiB0aGluZyB8fCBkZWZhdWx0Q3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnM7XG59XG52YXIgb2JzZXJ2YWJsZUFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oT0JTRVJWQUJMRSk7XG52YXIgb2JzZXJ2YWJsZVJlZkFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oT0JTRVJWQUJMRV9SRUYsIHtcbiAgZW5oYW5jZXI6IHJlZmVyZW5jZUVuaGFuY2VyXG59KTtcbnZhciBvYnNlcnZhYmxlU2hhbGxvd0Fubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oT0JTRVJWQUJMRV9TSEFMTE9XLCB7XG4gIGVuaGFuY2VyOiBzaGFsbG93RW5oYW5jZXJcbn0pO1xudmFyIG9ic2VydmFibGVTdHJ1Y3RBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZU9ic2VydmFibGVBbm5vdGF0aW9uKE9CU0VSVkFCTEVfU1RSVUNULCB7XG4gIGVuaGFuY2VyOiByZWZTdHJ1Y3RFbmhhbmNlclxufSk7XG52YXIgb2JzZXJ2YWJsZURlY29yYXRvckFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlQW5ub3RhdGlvbik7XG5mdW5jdGlvbiBnZXRFbmhhbmNlckZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZGVlcCA9PT0gdHJ1ZSA/IGRlZXBFbmhhbmNlciA6IG9wdGlvbnMuZGVlcCA9PT0gZmFsc2UgPyByZWZlcmVuY2VFbmhhbmNlciA6IGdldEVuaGFuY2VyRnJvbUFubm90YXRpb24ob3B0aW9ucy5kZWZhdWx0RGVjb3JhdG9yKTtcbn1cbmZ1bmN0aW9uIGdldEFubm90YXRpb25Gcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRkZWZhdWx0RGVjb3I7XG4gIHJldHVybiBvcHRpb25zID8gKF9vcHRpb25zJGRlZmF1bHREZWNvciA9IG9wdGlvbnMuZGVmYXVsdERlY29yYXRvcikgIT0gbnVsbCA/IF9vcHRpb25zJGRlZmF1bHREZWNvciA6IGNyZWF0ZUF1dG9Bbm5vdGF0aW9uKG9wdGlvbnMpIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0RW5oYW5jZXJGcm9tQW5ub3RhdGlvbihhbm5vdGF0aW9uKSB7XG4gIHZhciBfYW5ub3RhdGlvbiRvcHRpb25zXyQsIF9hbm5vdGF0aW9uJG9wdGlvbnNfO1xuICByZXR1cm4gIWFubm90YXRpb24gPyBkZWVwRW5oYW5jZXIgOiAoX2Fubm90YXRpb24kb3B0aW9uc18kID0gKF9hbm5vdGF0aW9uJG9wdGlvbnNfID0gYW5ub3RhdGlvbi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9uJG9wdGlvbnNfLmVuaGFuY2VyKSAhPSBudWxsID8gX2Fubm90YXRpb24kb3B0aW9uc18kIDogZGVlcEVuaGFuY2VyO1xufVxuLyoqXHJcbiAqIFR1cm5zIGFuIG9iamVjdCwgYXJyYXkgb3IgZnVuY3Rpb24gaW50byBhIHJlYWN0aXZlIHN0cnVjdHVyZS5cclxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHdoaWNoIHNob3VsZCBiZWNvbWUgb2JzZXJ2YWJsZS5cclxuICovXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlKHYsIGFyZzIsIGFyZzMpIHtcbiAgLy8gQG9ic2VydmFibGUgc29tZVByb3A7XG4gIGlmIChpc1N0cmluZ2lzaChhcmcyKSkge1xuICAgIHN0b3JlQW5ub3RhdGlvbih2LCBhcmcyLCBvYnNlcnZhYmxlQW5ub3RhdGlvbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGFscmVhZHkgb2JzZXJ2YWJsZSAtIGlnbm9yZVxuICBpZiAoaXNPYnNlcnZhYmxlKHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgLy8gcGxhaW4gb2JqZWN0XG4gIGlmIChpc1BsYWluT2JqZWN0KHYpKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUub2JqZWN0KHYsIGFyZzIsIGFyZzMpO1xuICB9XG4gIC8vIEFycmF5XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUuYXJyYXkodiwgYXJnMik7XG4gIH1cbiAgLy8gTWFwXG4gIGlmIChpc0VTNk1hcCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCBhcmcyKTtcbiAgfVxuICAvLyBTZXRcbiAgaWYgKGlzRVM2U2V0KHYpKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUuc2V0KHYsIGFyZzIpO1xuICB9XG4gIC8vIG90aGVyIG9iamVjdCAtIGlnbm9yZVxuICBpZiAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPT0gbnVsbCkge1xuICAgIHJldHVybiB2O1xuICB9XG4gIC8vIGFueXRoaW5nIGVsc2VcbiAgcmV0dXJuIG9ic2VydmFibGUuYm94KHYsIGFyZzIpO1xufVxuYXNzaWduKGNyZWF0ZU9ic2VydmFibGUsIG9ic2VydmFibGVEZWNvcmF0b3JBbm5vdGF0aW9uKTtcbnZhciBvYnNlcnZhYmxlRmFjdG9yaWVzID0ge1xuICBib3g6IGZ1bmN0aW9uIGJveCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVWYWx1ZSh2YWx1ZSwgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lLCB0cnVlLCBvLmVxdWFscyk7XG4gIH0sXG4gIGFycmF5OiBmdW5jdGlvbiBhcnJheShpbml0aWFsVmFsdWVzLCBvcHRpb25zKSB7XG4gICAgdmFyIG8gPSBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiAoZ2xvYmFsU3RhdGUudXNlUHJveGllcyA9PT0gZmFsc2UgfHwgby5wcm94eSA9PT0gZmFsc2UgPyBjcmVhdGVMZWdhY3lBcnJheSA6IGNyZWF0ZU9ic2VydmFibGVBcnJheSkoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgbWFwOiBmdW5jdGlvbiBtYXAoaW5pdGlhbFZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVNYXAoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoaW5pdGlhbFZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTZXQoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3QocHJvcHMsIGRlY29yYXRvcnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZXh0ZW5kT2JzZXJ2YWJsZShnbG9iYWxTdGF0ZS51c2VQcm94aWVzID09PSBmYWxzZSB8fCAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wcm94eSkgPT09IGZhbHNlID8gYXNPYnNlcnZhYmxlT2JqZWN0KHt9LCBvcHRpb25zKSA6IGFzRHluYW1pY09ic2VydmFibGVPYmplY3Qoe30sIG9wdGlvbnMpLCBwcm9wcywgZGVjb3JhdG9ycyk7XG4gIH0sXG4gIHJlZjogLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24ob2JzZXJ2YWJsZVJlZkFubm90YXRpb24pLFxuICBzaGFsbG93OiAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlU2hhbGxvd0Fubm90YXRpb24pLFxuICBkZWVwOiBvYnNlcnZhYmxlRGVjb3JhdG9yQW5ub3RhdGlvbixcbiAgc3RydWN0OiAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlU3RydWN0QW5ub3RhdGlvbilcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbnZhciBvYnNlcnZhYmxlID0gLyojX19QVVJFX18qL2Fzc2lnbihjcmVhdGVPYnNlcnZhYmxlLCBvYnNlcnZhYmxlRmFjdG9yaWVzKTtcblxudmFyIENPTVBVVEVEID0gXCJjb21wdXRlZFwiO1xudmFyIENPTVBVVEVEX1NUUlVDVCA9IFwiY29tcHV0ZWQuc3RydWN0XCI7XG52YXIgY29tcHV0ZWRBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbXB1dGVkQW5ub3RhdGlvbihDT01QVVRFRCk7XG52YXIgY29tcHV0ZWRTdHJ1Y3RBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbXB1dGVkQW5ub3RhdGlvbihDT01QVVRFRF9TVFJVQ1QsIHtcbiAgZXF1YWxzOiBjb21wYXJlci5zdHJ1Y3R1cmFsXG59KTtcbi8qKlxyXG4gKiBEZWNvcmF0b3IgZm9yIGNsYXNzIHByb3BlcnRpZXM6IEBjb21wdXRlZCBnZXQgdmFsdWUoKSB7IHJldHVybiBleHByOyB9LlxyXG4gKiBGb3IgbGVnYWN5IHB1cnBvc2VzIGFsc28gaW52b2thYmxlIGFzIEVTNSBvYnNlcnZhYmxlIGNyZWF0ZWQ6IGBjb21wdXRlZCgoKSA9PiBleHByKWA7XHJcbiAqL1xudmFyIGNvbXB1dGVkID0gZnVuY3Rpb24gY29tcHV0ZWQoYXJnMSwgYXJnMikge1xuICBpZiAoaXNTdHJpbmdpc2goYXJnMikpIHtcbiAgICAvLyBAY29tcHV0ZWRcbiAgICByZXR1cm4gc3RvcmVBbm5vdGF0aW9uKGFyZzEsIGFyZzIsIGNvbXB1dGVkQW5ub3RhdGlvbik7XG4gIH1cbiAgaWYgKGlzUGxhaW5PYmplY3QoYXJnMSkpIHtcbiAgICAvLyBAY29tcHV0ZWQoeyBvcHRpb25zIH0pXG4gICAgcmV0dXJuIGNyZWF0ZURlY29yYXRvckFubm90YXRpb24oY3JlYXRlQ29tcHV0ZWRBbm5vdGF0aW9uKENPTVBVVEVELCBhcmcxKSk7XG4gIH1cbiAgLy8gY29tcHV0ZWQoZXhwciwgb3B0aW9ucz8pXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oYXJnMSkpIHtcbiAgICAgIGRpZShcIkZpcnN0IGFyZ3VtZW50IHRvIGBjb21wdXRlZGAgc2hvdWxkIGJlIGFuIGV4cHJlc3Npb24uXCIpO1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbihhcmcyKSkge1xuICAgICAgZGllKFwiQSBzZXR0ZXIgYXMgc2Vjb25kIGFyZ3VtZW50IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHVzZSBgeyBzZXQ6IGZuIH1gIG9wdGlvbiBpbnN0ZWFkXCIpO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0cyA9IGlzUGxhaW5PYmplY3QoYXJnMikgPyBhcmcyIDoge307XG4gIG9wdHMuZ2V0ID0gYXJnMTtcbiAgb3B0cy5uYW1lIHx8IChvcHRzLm5hbWUgPSBhcmcxLm5hbWUgfHwgXCJcIik7IC8qIGZvciBnZW5lcmF0ZWQgbmFtZSAqL1xuICByZXR1cm4gbmV3IENvbXB1dGVkVmFsdWUob3B0cyk7XG59O1xuT2JqZWN0LmFzc2lnbihjb21wdXRlZCwgY29tcHV0ZWRBbm5vdGF0aW9uKTtcbmNvbXB1dGVkLnN0cnVjdCA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGNvbXB1dGVkU3RydWN0QW5ub3RhdGlvbik7XG5cbnZhciBfZ2V0RGVzY3JpcHRvciRjb25maWcsIF9nZXREZXNjcmlwdG9yO1xuLy8gd2UgZG9uJ3QgdXNlIGdsb2JhbFN0YXRlIGZvciB0aGVzZSBpbiBvcmRlciB0byBhdm9pZCBwb3NzaWJsZSBpc3N1ZXMgd2l0aCBtdWx0aXBsZVxuLy8gbW9ieCB2ZXJzaW9uc1xudmFyIGN1cnJlbnRBY3Rpb25JZCA9IDA7XG52YXIgbmV4dEFjdGlvbklkID0gMTtcbnZhciBpc0Z1bmN0aW9uTmFtZUNvbmZpZ3VyYWJsZSA9IChfZ2V0RGVzY3JpcHRvciRjb25maWcgPSAoX2dldERlc2NyaXB0b3IgPSAvKiNfX1BVUkVfXyovZ2V0RGVzY3JpcHRvcihmdW5jdGlvbiAoKSB7fSwgXCJuYW1lXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX2dldERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSAhPSBudWxsID8gX2dldERlc2NyaXB0b3IkY29uZmlnIDogZmFsc2U7XG4vLyB3ZSBjYW4gc2FmZWx5IHJlY3ljbGUgdGhpcyBvYmplY3RcbnZhciB0bXBOYW1lRGVzY3JpcHRvciA9IHtcbiAgdmFsdWU6IFwiYWN0aW9uXCIsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbihhY3Rpb25OYW1lLCBmbiwgYXV0b0FjdGlvbiwgcmVmKSB7XG4gIGlmIChhdXRvQWN0aW9uID09PSB2b2lkIDApIHtcbiAgICBhdXRvQWN0aW9uID0gZmFsc2U7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIGRpZShcImBhY3Rpb25gIGNhbiBvbmx5IGJlIGludm9rZWQgb24gZnVuY3Rpb25zXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjdGlvbk5hbWUgIT09IFwic3RyaW5nXCIgfHwgIWFjdGlvbk5hbWUpIHtcbiAgICAgIGRpZShcImFjdGlvbnMgc2hvdWxkIGhhdmUgdmFsaWQgbmFtZXMsIGdvdDogJ1wiICsgYWN0aW9uTmFtZSArIFwiJ1wiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVzKCkge1xuICAgIHJldHVybiBleGVjdXRlQWN0aW9uKGFjdGlvbk5hbWUsIGF1dG9BY3Rpb24sIGZuLCByZWYgfHwgdGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICByZXMuaXNNb2J4QWN0aW9uID0gdHJ1ZTtcbiAgaWYgKGlzRnVuY3Rpb25OYW1lQ29uZmlndXJhYmxlKSB7XG4gICAgdG1wTmFtZURlc2NyaXB0b3IudmFsdWUgPSBhY3Rpb25OYW1lO1xuICAgIGRlZmluZVByb3BlcnR5KHJlcywgXCJuYW1lXCIsIHRtcE5hbWVEZXNjcmlwdG9yKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZXhlY3V0ZUFjdGlvbihhY3Rpb25OYW1lLCBjYW5SdW5Bc0Rlcml2YXRpb24sIGZuLCBzY29wZSwgYXJncykge1xuICB2YXIgcnVuSW5mbyA9IF9zdGFydEFjdGlvbihhY3Rpb25OYW1lLCBjYW5SdW5Bc0Rlcml2YXRpb24sIHNjb3BlLCBhcmdzKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4uYXBwbHkoc2NvcGUsIGFyZ3MpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBydW5JbmZvLmVycm9yXyA9IGVycjtcbiAgICB0aHJvdyBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgX2VuZEFjdGlvbihydW5JbmZvKTtcbiAgfVxufVxuZnVuY3Rpb24gX3N0YXJ0QWN0aW9uKGFjdGlvbk5hbWUsIGNhblJ1bkFzRGVyaXZhdGlvbixcbi8vIHRydWUgZm9yIGF1dG9BY3Rpb25cbnNjb3BlLCBhcmdzKSB7XG4gIHZhciBub3RpZnlTcHlfID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpICYmICEhYWN0aW9uTmFtZTtcbiAgdmFyIHN0YXJ0VGltZV8gPSAwO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweV8pIHtcbiAgICBzdGFydFRpbWVfID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgZmxhdHRlbmVkQXJncyA9IGFyZ3MgPyBBcnJheS5mcm9tKGFyZ3MpIDogRU1QVFlfQVJSQVk7XG4gICAgc3B5UmVwb3J0U3RhcnQoe1xuICAgICAgdHlwZTogQUNUSU9OLFxuICAgICAgbmFtZTogYWN0aW9uTmFtZSxcbiAgICAgIG9iamVjdDogc2NvcGUsXG4gICAgICBhcmd1bWVudHM6IGZsYXR0ZW5lZEFyZ3NcbiAgICB9KTtcbiAgfVxuICB2YXIgcHJldkRlcml2YXRpb25fID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuICB2YXIgcnVuQXNBY3Rpb24gPSAhY2FuUnVuQXNEZXJpdmF0aW9uIHx8ICFwcmV2RGVyaXZhdGlvbl87XG4gIHN0YXJ0QmF0Y2goKTtcbiAgdmFyIHByZXZBbGxvd1N0YXRlQ2hhbmdlc18gPSBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlczsgLy8gYnkgZGVmYXVsdCBwcmVzZXJ2ZSBwcmV2aW91cyBhbGxvd1xuICBpZiAocnVuQXNBY3Rpb24pIHtcbiAgICB1bnRyYWNrZWRTdGFydCgpO1xuICAgIHByZXZBbGxvd1N0YXRlQ2hhbmdlc18gPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KHRydWUpO1xuICB9XG4gIHZhciBwcmV2QWxsb3dTdGF0ZVJlYWRzXyA9IGFsbG93U3RhdGVSZWFkc1N0YXJ0KHRydWUpO1xuICB2YXIgcnVuSW5mbyA9IHtcbiAgICBydW5Bc0FjdGlvbl86IHJ1bkFzQWN0aW9uLFxuICAgIHByZXZEZXJpdmF0aW9uXzogcHJldkRlcml2YXRpb25fLFxuICAgIHByZXZBbGxvd1N0YXRlQ2hhbmdlc186IHByZXZBbGxvd1N0YXRlQ2hhbmdlc18sXG4gICAgcHJldkFsbG93U3RhdGVSZWFkc186IHByZXZBbGxvd1N0YXRlUmVhZHNfLFxuICAgIG5vdGlmeVNweV86IG5vdGlmeVNweV8sXG4gICAgc3RhcnRUaW1lXzogc3RhcnRUaW1lXyxcbiAgICBhY3Rpb25JZF86IG5leHRBY3Rpb25JZCsrLFxuICAgIHBhcmVudEFjdGlvbklkXzogY3VycmVudEFjdGlvbklkXG4gIH07XG4gIGN1cnJlbnRBY3Rpb25JZCA9IHJ1bkluZm8uYWN0aW9uSWRfO1xuICByZXR1cm4gcnVuSW5mbztcbn1cbmZ1bmN0aW9uIF9lbmRBY3Rpb24ocnVuSW5mbykge1xuICBpZiAoY3VycmVudEFjdGlvbklkICE9PSBydW5JbmZvLmFjdGlvbklkXykge1xuICAgIGRpZSgzMCk7XG4gIH1cbiAgY3VycmVudEFjdGlvbklkID0gcnVuSW5mby5wYXJlbnRBY3Rpb25JZF87XG4gIGlmIChydW5JbmZvLmVycm9yXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2xvYmFsU3RhdGUuc3VwcHJlc3NSZWFjdGlvbkVycm9ycyA9IHRydWU7XG4gIH1cbiAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocnVuSW5mby5wcmV2QWxsb3dTdGF0ZUNoYW5nZXNfKTtcbiAgYWxsb3dTdGF0ZVJlYWRzRW5kKHJ1bkluZm8ucHJldkFsbG93U3RhdGVSZWFkc18pO1xuICBlbmRCYXRjaCgpO1xuICBpZiAocnVuSW5mby5ydW5Bc0FjdGlvbl8pIHtcbiAgICB1bnRyYWNrZWRFbmQocnVuSW5mby5wcmV2RGVyaXZhdGlvbl8pO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgcnVuSW5mby5ub3RpZnlTcHlfKSB7XG4gICAgc3B5UmVwb3J0RW5kKHtcbiAgICAgIHRpbWU6IERhdGUubm93KCkgLSBydW5JbmZvLnN0YXJ0VGltZV9cbiAgICB9KTtcbiAgfVxuICBnbG9iYWxTdGF0ZS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzID0gZmFsc2U7XG59XG5mdW5jdGlvbiBhbGxvd1N0YXRlQ2hhbmdlcyhhbGxvd1N0YXRlQ2hhbmdlcywgZnVuYykge1xuICB2YXIgcHJldiA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQoYWxsb3dTdGF0ZUNoYW5nZXMpO1xuICB0cnkge1xuICAgIHJldHVybiBmdW5jKCk7XG4gIH0gZmluYWxseSB7XG4gICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldik7XG4gIH1cbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQoYWxsb3dTdGF0ZUNoYW5nZXMpIHtcbiAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcztcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSBhbGxvd1N0YXRlQ2hhbmdlcztcbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KSB7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzID0gcHJldjtcbn1cblxudmFyIF9TeW1ib2wkdG9QcmltaXRpdmU7XG52YXIgQ1JFQVRFID0gXCJjcmVhdGVcIjtcbl9TeW1ib2wkdG9QcmltaXRpdmUgPSBTeW1ib2wudG9QcmltaXRpdmU7XG52YXIgT2JzZXJ2YWJsZVZhbHVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXRvbSkge1xuICBfaW5oZXJpdHNMb29zZShPYnNlcnZhYmxlVmFsdWUsIF9BdG9tKTtcbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZVZhbHVlKHZhbHVlLCBlbmhhbmNlciwgbmFtZV8sIG5vdGlmeVNweSwgZXF1YWxzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lXyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiT2JzZXJ2YWJsZVZhbHVlQFwiICsgZ2V0TmV4dElkKCkgOiBcIk9ic2VydmFibGVWYWx1ZVwiO1xuICAgIH1cbiAgICBpZiAobm90aWZ5U3B5ID09PSB2b2lkIDApIHtcbiAgICAgIG5vdGlmeVNweSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChlcXVhbHMgPT09IHZvaWQgMCkge1xuICAgICAgZXF1YWxzID0gY29tcGFyZXJbXCJkZWZhdWx0XCJdO1xuICAgIH1cbiAgICBfdGhpcyA9IF9BdG9tLmNhbGwodGhpcywgbmFtZV8pIHx8IHRoaXM7XG4gICAgX3RoaXMuZW5oYW5jZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgX3RoaXMuZXF1YWxzID0gdm9pZCAwO1xuICAgIF90aGlzLmhhc1VucmVwb3J0ZWRDaGFuZ2VfID0gZmFsc2U7XG4gICAgX3RoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICBfdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIF90aGlzLnZhbHVlXyA9IHZvaWQgMDtcbiAgICBfdGhpcy5kZWhhbmNlciA9IHZvaWQgMDtcbiAgICBfdGhpcy5lbmhhbmNlciA9IGVuaGFuY2VyO1xuICAgIF90aGlzLm5hbWVfID0gbmFtZV87XG4gICAgX3RoaXMuZXF1YWxzID0gZXF1YWxzO1xuICAgIF90aGlzLnZhbHVlXyA9IGVuaGFuY2VyKHZhbHVlLCB1bmRlZmluZWQsIG5hbWVfKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSAmJiBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgLy8gb25seSBub3RpZnkgc3B5IGlmIHRoaXMgaXMgYSBzdGFuZC1hbG9uZSBvYnNlcnZhYmxlXG4gICAgICBzcHlSZXBvcnQoe1xuICAgICAgICB0eXBlOiBDUkVBVEUsXG4gICAgICAgIG9iamVjdDogX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInZhbHVlXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogX3RoaXMubmFtZV8sXG4gICAgICAgIG5ld1ZhbHVlOiBcIlwiICsgX3RoaXMudmFsdWVfXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfcHJvdG8gPSBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlO1xuICBfcHJvdG8uZGVoYW5jZVZhbHVlID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXztcbiAgICBuZXdWYWx1ZSA9IHRoaXMucHJlcGFyZU5ld1ZhbHVlXyhuZXdWYWx1ZSk7XG4gICAgaWYgKG5ld1ZhbHVlICE9PSBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydFN0YXJ0KHtcbiAgICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgIG9ic2VydmFibGVLaW5kOiBcInZhbHVlXCIsXG4gICAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldE5ld1ZhbHVlXyhuZXdWYWx1ZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5wcmVwYXJlTmV3VmFsdWVfID0gZnVuY3Rpb24gcHJlcGFyZU5ld1ZhbHVlXyhuZXdWYWx1ZSkge1xuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMpO1xuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQ7XG4gICAgICB9XG4gICAgICBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICB9XG4gICAgLy8gYXBwbHkgbW9kaWZpZXJcbiAgICBuZXdWYWx1ZSA9IHRoaXMuZW5oYW5jZXIobmV3VmFsdWUsIHRoaXMudmFsdWVfLCB0aGlzLm5hbWVfKTtcbiAgICByZXR1cm4gdGhpcy5lcXVhbHModGhpcy52YWx1ZV8sIG5ld1ZhbHVlKSA/IGdsb2JhbFN0YXRlLlVOQ0hBTkdFRCA6IG5ld1ZhbHVlO1xuICB9O1xuICBfcHJvdG8uc2V0TmV3VmFsdWVfID0gZnVuY3Rpb24gc2V0TmV3VmFsdWVfKG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgdGhpcy52YWx1ZV8gPSBuZXdWYWx1ZTtcbiAgICB0aGlzLnJlcG9ydENoYW5nZWQoKTtcbiAgICBpZiAoaGFzTGlzdGVuZXJzKHRoaXMpKSB7XG4gICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywge1xuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB0aGlzLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlKHRoaXMudmFsdWVfKTtcbiAgfTtcbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIGlmIChmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwidmFsdWVcIixcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgbmV3VmFsdWU6IHRoaXMudmFsdWVfLFxuICAgICAgICBvbGRWYWx1ZTogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xuICB9O1xuICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KCkge1xuICAgIC8vIHVzZWQgYnkgTVNUIG90IGdldCB1bmRlaGFuY2VkIHZhbHVlXG4gICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICB9O1xuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgpO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXyArIFwiW1wiICsgdGhpcy52YWx1ZV8gKyBcIl1cIjtcbiAgfTtcbiAgX3Byb3RvLnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0b1ByaW1pdGl2ZSh0aGlzLmdldCgpKTtcbiAgfTtcbiAgX3Byb3RvW19TeW1ib2wkdG9QcmltaXRpdmVdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcbiAgfTtcbiAgcmV0dXJuIE9ic2VydmFibGVWYWx1ZTtcbn0oQXRvbSk7XG52YXIgaXNPYnNlcnZhYmxlVmFsdWUgPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVWYWx1ZVwiLCBPYnNlcnZhYmxlVmFsdWUpO1xuXG52YXIgX1N5bWJvbCR0b1ByaW1pdGl2ZSQxO1xuLyoqXHJcbiAqIEEgbm9kZSBpbiB0aGUgc3RhdGUgZGVwZW5kZW5jeSByb290IHRoYXQgb2JzZXJ2ZXMgb3RoZXIgbm9kZXMsIGFuZCBjYW4gYmUgb2JzZXJ2ZWQgaXRzZWxmLlxyXG4gKlxyXG4gKiBDb21wdXRlZFZhbHVlIHdpbGwgcmVtZW1iZXIgdGhlIHJlc3VsdCBvZiB0aGUgY29tcHV0YXRpb24gZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgYmF0Y2gsIG9yXHJcbiAqIHdoaWxlIGJlaW5nIG9ic2VydmVkLlxyXG4gKlxyXG4gKiBEdXJpbmcgdGhpcyB0aW1lIGl0IHdpbGwgcmVjb21wdXRlIG9ubHkgd2hlbiBvbmUgb2YgaXRzIGRpcmVjdCBkZXBlbmRlbmNpZXMgY2hhbmdlZCxcclxuICogYnV0IG9ubHkgd2hlbiBpdCBpcyBiZWluZyBhY2Nlc3NlZCB3aXRoIGBDb21wdXRlZFZhbHVlLmdldCgpYC5cclxuICpcclxuICogSW1wbGVtZW50YXRpb24gZGVzY3JpcHRpb246XHJcbiAqIDEuIEZpcnN0IHRpbWUgaXQncyBiZWluZyBhY2Nlc3NlZCBpdCB3aWxsIGNvbXB1dGUgYW5kIHJlbWVtYmVyIHJlc3VsdFxyXG4gKiAgICBnaXZlIGJhY2sgcmVtZW1iZXJlZCByZXN1bHQgdW50aWwgMi4gaGFwcGVuc1xyXG4gKiAyLiBGaXJzdCB0aW1lIGFueSBkZWVwIGRlcGVuZGVuY3kgY2hhbmdlLCBwcm9wYWdhdGUgUE9TU0lCTFlfU1RBTEUgdG8gYWxsIG9ic2VydmVycywgd2FpdCBmb3IgMy5cclxuICogMy4gV2hlbiBpdCdzIGJlaW5nIGFjY2Vzc2VkLCByZWNvbXB1dGUgaWYgYW55IHNoYWxsb3cgZGVwZW5kZW5jeSBjaGFuZ2VkLlxyXG4gKiAgICBpZiByZXN1bHQgY2hhbmdlZDogcHJvcGFnYXRlIFNUQUxFIHRvIGFsbCBvYnNlcnZlcnMsIHRoYXQgd2VyZSBQT1NTSUJMWV9TVEFMRSBmcm9tIHRoZSBsYXN0IHN0ZXAuXHJcbiAqICAgIGdvIHRvIHN0ZXAgMi4gZWl0aGVyIHdheVxyXG4gKlxyXG4gKiBJZiBhdCBhbnkgcG9pbnQgaXQncyBvdXRzaWRlIGJhdGNoIGFuZCBpdCBpc24ndCBvYnNlcnZlZDogcmVzZXQgZXZlcnl0aGluZyBhbmQgZ28gdG8gMS5cclxuICovXG5fU3ltYm9sJHRvUHJpbWl0aXZlJDEgPSBTeW1ib2wudG9QcmltaXRpdmU7XG52YXIgQ29tcHV0ZWRWYWx1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIG5vZGVzIHdlIGFyZSBsb29raW5nIGF0LiBPdXIgdmFsdWUgZGVwZW5kcyBvbiB0aGVzZSBub2Rlc1xuICAvLyBkdXJpbmcgdHJhY2tpbmcgaXQncyBhbiBhcnJheSB3aXRoIG5ldyBvYnNlcnZlZCBvYnNlcnZlcnNcblxuICAvLyB0byBjaGVjayBmb3IgY3ljbGVzXG5cbiAgLy8gTi5COiB1bm1pbmlmaWVkIGFzIGl0IGlzIHVzZWQgYnkgTVNUXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGNvbXB1dGVkIHZhbHVlIGJhc2VkIG9uIGEgZnVuY3Rpb24gZXhwcmVzc2lvbi5cclxuICAgKlxyXG4gICAqIFRoZSBgbmFtZWAgcHJvcGVydHkgaXMgZm9yIGRlYnVnIHB1cnBvc2VzIG9ubHkuXHJcbiAgICpcclxuICAgKiBUaGUgYGVxdWFsc2AgcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBjb21wYXJlciBmdW5jdGlvbiB0byB1c2UgdG8gZGV0ZXJtaW5lIGlmIGEgbmV3bHkgcHJvZHVjZWRcclxuICAgKiB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHByZXZpb3VzIHZhbHVlLiBUd28gY29tcGFyZXJzIGFyZSBwcm92aWRlZCBpbiB0aGUgbGlicmFyeTsgYGRlZmF1bHRDb21wYXJlcmBcclxuICAgKiBjb21wYXJlcyBiYXNlZCBvbiBpZGVudGl0eSBjb21wYXJpc29uICg9PT0pLCBhbmQgYHN0cnVjdHVyYWxDb21wYXJlcmAgZGVlcGx5IGNvbXBhcmVzIHRoZSBzdHJ1Y3R1cmUuXHJcbiAgICogU3RydWN0dXJhbCBjb21wYXJpc29uIGNhbiBiZSBjb252ZW5pZW50IGlmIHlvdSBhbHdheXMgcHJvZHVjZSBhIG5ldyBhZ2dyZWdhdGVkIG9iamVjdCBhbmRcclxuICAgKiBkb24ndCB3YW50IHRvIG5vdGlmeSBvYnNlcnZlcnMgaWYgaXQgaXMgc3RydWN0dXJhbGx5IHRoZSBzYW1lLlxyXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciB3b3JraW5nIHdpdGggdmVjdG9ycywgbW91c2UgY29vcmRpbmF0ZXMgZXRjLlxyXG4gICAqL1xuICBmdW5jdGlvbiBDb21wdXRlZFZhbHVlKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR187XG4gICAgdGhpcy5vYnNlcnZpbmdfID0gW107XG4gICAgdGhpcy5uZXdPYnNlcnZpbmdfID0gbnVsbDtcbiAgICB0aGlzLmlzQmVpbmdPYnNlcnZlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb25fID0gZmFsc2U7XG4gICAgdGhpcy5vYnNlcnZlcnNfID0gbmV3IFNldCgpO1xuICAgIHRoaXMuZGlmZlZhbHVlXyA9IDA7XG4gICAgdGhpcy5ydW5JZF8gPSAwO1xuICAgIHRoaXMubGFzdEFjY2Vzc2VkQnlfID0gMDtcbiAgICB0aGlzLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gICAgdGhpcy51bmJvdW5kRGVwc0NvdW50XyA9IDA7XG4gICAgdGhpcy52YWx1ZV8gPSBuZXcgQ2F1Z2h0RXhjZXB0aW9uKG51bGwpO1xuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpcy50cmlnZ2VyZWRCeV8gPSB2b2lkIDA7XG4gICAgdGhpcy5pc0NvbXB1dGluZ18gPSBmYWxzZTtcbiAgICB0aGlzLmlzUnVubmluZ1NldHRlcl8gPSBmYWxzZTtcbiAgICB0aGlzLmRlcml2YXRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5zZXR0ZXJfID0gdm9pZCAwO1xuICAgIHRoaXMuaXNUcmFjaW5nXyA9IFRyYWNlTW9kZS5OT05FO1xuICAgIHRoaXMuc2NvcGVfID0gdm9pZCAwO1xuICAgIHRoaXMuZXF1YWxzXyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlcXVpcmVzUmVhY3Rpb25fID0gdm9pZCAwO1xuICAgIHRoaXMua2VlcEFsaXZlXyA9IHZvaWQgMDtcbiAgICB0aGlzLm9uQk9MID0gdm9pZCAwO1xuICAgIHRoaXMub25CVU9MID0gdm9pZCAwO1xuICAgIGlmICghb3B0aW9ucy5nZXQpIHtcbiAgICAgIGRpZSgzMSk7XG4gICAgfVxuICAgIHRoaXMuZGVyaXZhdGlvbiA9IG9wdGlvbnMuZ2V0O1xuICAgIHRoaXMubmFtZV8gPSBvcHRpb25zLm5hbWUgfHwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiQ29tcHV0ZWRWYWx1ZUBcIiArIGdldE5leHRJZCgpIDogXCJDb21wdXRlZFZhbHVlXCIpO1xuICAgIGlmIChvcHRpb25zLnNldCkge1xuICAgICAgdGhpcy5zZXR0ZXJfID0gY3JlYXRlQWN0aW9uKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi1zZXR0ZXJcIiA6IFwiQ29tcHV0ZWRWYWx1ZS1zZXR0ZXJcIiwgb3B0aW9ucy5zZXQpO1xuICAgIH1cbiAgICB0aGlzLmVxdWFsc18gPSBvcHRpb25zLmVxdWFscyB8fCAob3B0aW9ucy5jb21wYXJlU3RydWN0dXJhbCB8fCBvcHRpb25zLnN0cnVjdCA/IGNvbXBhcmVyLnN0cnVjdHVyYWwgOiBjb21wYXJlcltcImRlZmF1bHRcIl0pO1xuICAgIHRoaXMuc2NvcGVfID0gb3B0aW9ucy5jb250ZXh0O1xuICAgIHRoaXMucmVxdWlyZXNSZWFjdGlvbl8gPSBvcHRpb25zLnJlcXVpcmVzUmVhY3Rpb247XG4gICAgdGhpcy5rZWVwQWxpdmVfID0gISFvcHRpb25zLmtlZXBBbGl2ZTtcbiAgfVxuICB2YXIgX3Byb3RvID0gQ29tcHV0ZWRWYWx1ZS5wcm90b3R5cGU7XG4gIF9wcm90by5vbkJlY29tZVN0YWxlXyA9IGZ1bmN0aW9uIG9uQmVjb21lU3RhbGVfKCkge1xuICAgIHByb3BhZ2F0ZU1heWJlQ2hhbmdlZCh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLm9uQk8gPSBmdW5jdGlvbiBvbkJPKCkge1xuICAgIGlmICh0aGlzLm9uQk9MKSB7XG4gICAgICB0aGlzLm9uQk9MLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ub25CVU8gPSBmdW5jdGlvbiBvbkJVTygpIHtcbiAgICBpZiAodGhpcy5vbkJVT0wpIHtcbiAgICAgIHRoaXMub25CVU9MLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcyBjb21wdXRlZCB2YWx1ZS5cclxuICAgKiBXaWxsIGV2YWx1YXRlIGl0cyBjb21wdXRhdGlvbiBmaXJzdCBpZiBuZWVkZWQuXHJcbiAgICovO1xuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLmlzQ29tcHV0aW5nXykge1xuICAgICAgZGllKDMyLCB0aGlzLm5hbWVfLCB0aGlzLmRlcml2YXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2xvYmFsU3RhdGUuaW5CYXRjaCA9PT0gMCAmJlxuICAgIC8vICFnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRwaW9uICYmXG4gICAgdGhpcy5vYnNlcnZlcnNfLnNpemUgPT09IDAgJiYgIXRoaXMua2VlcEFsaXZlXykge1xuICAgICAgaWYgKHNob3VsZENvbXB1dGUodGhpcykpIHtcbiAgICAgICAgdGhpcy53YXJuQWJvdXRVbnRyYWNrZWRSZWFkXygpO1xuICAgICAgICBzdGFydEJhdGNoKCk7IC8vIFNlZSBwZXJmIHRlc3QgJ2NvbXB1dGVkIG1lbW9pemF0aW9uJ1xuICAgICAgICB0aGlzLnZhbHVlXyA9IHRoaXMuY29tcHV0ZVZhbHVlXyhmYWxzZSk7XG4gICAgICAgIGVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcG9ydE9ic2VydmVkKHRoaXMpO1xuICAgICAgaWYgKHNob3VsZENvbXB1dGUodGhpcykpIHtcbiAgICAgICAgdmFyIHByZXZUcmFja2luZ0NvbnRleHQgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQ7XG4gICAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZV8gJiYgIXByZXZUcmFja2luZ0NvbnRleHQpIHtcbiAgICAgICAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYWNrQW5kQ29tcHV0ZSgpKSB7XG4gICAgICAgICAgcHJvcGFnYXRlQ2hhbmdlQ29uZmlybWVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHByZXZUcmFja2luZ0NvbnRleHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0aGlzLnZhbHVlXztcbiAgICBpZiAoaXNDYXVnaHRFeGNlcHRpb24ocmVzdWx0KSkge1xuICAgICAgdGhyb3cgcmVzdWx0LmNhdXNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc2V0dGVyXykge1xuICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nU2V0dGVyXykge1xuICAgICAgICBkaWUoMzMsIHRoaXMubmFtZV8pO1xuICAgICAgfVxuICAgICAgdGhpcy5pc1J1bm5pbmdTZXR0ZXJfID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2V0dGVyXy5jYWxsKHRoaXMuc2NvcGVfLCB2YWx1ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmlzUnVubmluZ1NldHRlcl8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGllKDM0LCB0aGlzLm5hbWVfKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by50cmFja0FuZENvbXB1dGUgPSBmdW5jdGlvbiB0cmFja0FuZENvbXB1dGUoKSB7XG4gICAgLy8gTi5COiB1bm1pbmlmaWVkIGFzIGl0IGlzIHVzZWQgYnkgTVNUXG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgdmFyIHdhc1N1c3BlbmRlZCA9IC8qIHNlZSAjMTIwOCAqL3RoaXMuZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfO1xuICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuY29tcHV0ZVZhbHVlXyh0cnVlKTtcbiAgICB2YXIgY2hhbmdlZCA9IHdhc1N1c3BlbmRlZCB8fCBpc0NhdWdodEV4Y2VwdGlvbihvbGRWYWx1ZSkgfHwgaXNDYXVnaHRFeGNlcHRpb24obmV3VmFsdWUpIHx8ICF0aGlzLmVxdWFsc18ob2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy52YWx1ZV8gPSBuZXdWYWx1ZTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJjb21wdXRlZFwiLFxuICAgICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgICBvYmplY3Q6IHRoaXMuc2NvcGVfLFxuICAgICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH07XG4gIF9wcm90by5jb21wdXRlVmFsdWVfID0gZnVuY3Rpb24gY29tcHV0ZVZhbHVlXyh0cmFjaykge1xuICAgIHRoaXMuaXNDb21wdXRpbmdfID0gdHJ1ZTtcbiAgICAvLyBkb24ndCBhbGxvdyBzdGF0ZSBjaGFuZ2VzIGR1cmluZyBjb21wdXRhdGlvblxuICAgIHZhciBwcmV2ID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydChmYWxzZSk7XG4gICAgdmFyIHJlcztcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJlcyA9IHRyYWNrRGVyaXZlZEZ1bmN0aW9uKHRoaXMsIHRoaXMuZGVyaXZhdGlvbiwgdGhpcy5zY29wZV8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9PT0gdHJ1ZSkge1xuICAgICAgICByZXMgPSB0aGlzLmRlcml2YXRpb24uY2FsbCh0aGlzLnNjb3BlXyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuZGVyaXZhdGlvbi5jYWxsKHRoaXMuc2NvcGVfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlcyA9IG5ldyBDYXVnaHRFeGNlcHRpb24oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldik7XG4gICAgdGhpcy5pc0NvbXB1dGluZ18gPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICBfcHJvdG8uc3VzcGVuZF8gPSBmdW5jdGlvbiBzdXNwZW5kXygpIHtcbiAgICBpZiAoIXRoaXMua2VlcEFsaXZlXykge1xuICAgICAgY2xlYXJPYnNlcnZpbmcodGhpcyk7XG4gICAgICB0aGlzLnZhbHVlXyA9IHVuZGVmaW5lZDsgLy8gZG9uJ3QgaG9sZCBvbiB0byBjb21wdXRlZCB2YWx1ZSFcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSBDb21wdXRlZCB2YWx1ZSAnXCIgKyB0aGlzLm5hbWVfICsgXCInIHdhcyBzdXNwZW5kZWQgYW5kIGl0IHdpbGwgcmVjb21wdXRlIG9uIHRoZSBuZXh0IGFjY2Vzcy5cIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcbiAgICB2YXIgcHJldlZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBhdXRvcnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRPRE86IHdoeSBpcyB0aGlzIGluIGEgZGlmZmVyZW50IHBsYWNlIHRoYW4gdGhlIHNweVJlcG9ydCgpIGZ1bmN0aW9uPyBpbiBhbGwgb3RoZXIgb2JzZXJ2YWJsZXMgaXQncyBjYWxsZWQgaW4gdGhlIHNhbWUgcGxhY2VcbiAgICAgIHZhciBuZXdWYWx1ZSA9IF90aGlzLmdldCgpO1xuICAgICAgaWYgKCFmaXJzdFRpbWUgfHwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHZhciBwcmV2VSA9IHVudHJhY2tlZFN0YXJ0KCk7XG4gICAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJjb21wdXRlZFwiLFxuICAgICAgICAgIGRlYnVnT2JqZWN0TmFtZTogX3RoaXMubmFtZV8sXG4gICAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICAgIG9iamVjdDogX3RoaXMsXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlOiBwcmV2VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHVudHJhY2tlZEVuZChwcmV2VSk7XG4gICAgICB9XG4gICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgIHByZXZWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8ud2FybkFib3V0VW50cmFja2VkUmVhZF8gPSBmdW5jdGlvbiB3YXJuQWJvdXRVbnRyYWNrZWRSZWFkXygpIHtcbiAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVHJhY2luZ18gIT09IFRyYWNlTW9kZS5OT05FKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSBDb21wdXRlZCB2YWx1ZSAnXCIgKyB0aGlzLm5hbWVfICsgXCInIGlzIGJlaW5nIHJlYWQgb3V0c2lkZSBhIHJlYWN0aXZlIGNvbnRleHQuIERvaW5nIGEgZnVsbCByZWNvbXB1dGUuXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMucmVxdWlyZXNSZWFjdGlvbl8gPT09IFwiYm9vbGVhblwiID8gdGhpcy5yZXF1aXJlc1JlYWN0aW9uXyA6IGdsb2JhbFN0YXRlLmNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvbikge1xuICAgICAgY29uc29sZS53YXJuKFwiW21vYnhdIENvbXB1dGVkIHZhbHVlICdcIiArIHRoaXMubmFtZV8gKyBcIicgaXMgYmVpbmcgcmVhZCBvdXRzaWRlIGEgcmVhY3RpdmUgY29udGV4dC4gRG9pbmcgYSBmdWxsIHJlY29tcHV0ZS5cIik7XG4gICAgfVxuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXyArIFwiW1wiICsgdGhpcy5kZXJpdmF0aW9uLnRvU3RyaW5nKCkgKyBcIl1cIjtcbiAgfTtcbiAgX3Byb3RvLnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0b1ByaW1pdGl2ZSh0aGlzLmdldCgpKTtcbiAgfTtcbiAgX3Byb3RvW19TeW1ib2wkdG9QcmltaXRpdmUkMV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuICB9O1xuICByZXR1cm4gQ29tcHV0ZWRWYWx1ZTtcbn0oKTtcbnZhciBpc0NvbXB1dGVkVmFsdWUgPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIkNvbXB1dGVkVmFsdWVcIiwgQ29tcHV0ZWRWYWx1ZSk7XG5cbnZhciBJRGVyaXZhdGlvblN0YXRlXztcbihmdW5jdGlvbiAoSURlcml2YXRpb25TdGF0ZV8pIHtcbiAgLy8gYmVmb3JlIGJlaW5nIHJ1biBvciAob3V0c2lkZSBiYXRjaCBhbmQgbm90IGJlaW5nIG9ic2VydmVkKVxuICAvLyBhdCB0aGlzIHBvaW50IGRlcml2YXRpb24gaXMgbm90IGhvbGRpbmcgYW55IGRhdGEgYWJvdXQgZGVwZW5kZW5jeSB0cmVlXG4gIElEZXJpdmF0aW9uU3RhdGVfW0lEZXJpdmF0aW9uU3RhdGVfW1wiTk9UX1RSQUNLSU5HX1wiXSA9IC0xXSA9IFwiTk9UX1RSQUNLSU5HX1wiO1xuICAvLyBubyBzaGFsbG93IGRlcGVuZGVuY3kgY2hhbmdlZCBzaW5jZSBsYXN0IGNvbXB1dGF0aW9uXG4gIC8vIHdvbid0IHJlY2FsY3VsYXRlIGRlcml2YXRpb25cbiAgLy8gdGhpcyBpcyB3aGF0IG1ha2VzIG1vYnggZmFzdFxuICBJRGVyaXZhdGlvblN0YXRlX1tJRGVyaXZhdGlvblN0YXRlX1tcIlVQX1RPX0RBVEVfXCJdID0gMF0gPSBcIlVQX1RPX0RBVEVfXCI7XG4gIC8vIHNvbWUgZGVlcCBkZXBlbmRlbmN5IGNoYW5nZWQsIGJ1dCBkb24ndCBrbm93IGlmIHNoYWxsb3cgZGVwZW5kZW5jeSBjaGFuZ2VkXG4gIC8vIHdpbGwgcmVxdWlyZSB0byBjaGVjayBmaXJzdCBpZiBVUF9UT19EQVRFIG9yIFBPU1NJQkxZX1NUQUxFXG4gIC8vIGN1cnJlbnRseSBvbmx5IENvbXB1dGVkVmFsdWUgd2lsbCBwcm9wYWdhdGUgUE9TU0lCTFlfU1RBTEVcbiAgLy9cbiAgLy8gaGF2aW5nIHRoaXMgc3RhdGUgaXMgc2Vjb25kIGJpZyBvcHRpbWl6YXRpb246XG4gIC8vIGRvbid0IGhhdmUgdG8gcmVjb21wdXRlIG9uIGV2ZXJ5IGRlcGVuZGVuY3kgY2hhbmdlLCBidXQgb25seSB3aGVuIGl0J3MgbmVlZGVkXG4gIElEZXJpdmF0aW9uU3RhdGVfW0lEZXJpdmF0aW9uU3RhdGVfW1wiUE9TU0lCTFlfU1RBTEVfXCJdID0gMV0gPSBcIlBPU1NJQkxZX1NUQUxFX1wiO1xuICAvLyBBIHNoYWxsb3cgZGVwZW5kZW5jeSBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IGNvbXB1dGF0aW9uIGFuZCB0aGUgZGVyaXZhdGlvblxuICAvLyB3aWxsIG5lZWQgdG8gcmVjb21wdXRlIHdoZW4gaXQncyBuZWVkZWQgbmV4dC5cbiAgSURlcml2YXRpb25TdGF0ZV9bSURlcml2YXRpb25TdGF0ZV9bXCJTVEFMRV9cIl0gPSAyXSA9IFwiU1RBTEVfXCI7XG59KShJRGVyaXZhdGlvblN0YXRlXyB8fCAoSURlcml2YXRpb25TdGF0ZV8gPSB7fSkpO1xudmFyIFRyYWNlTW9kZTtcbihmdW5jdGlvbiAoVHJhY2VNb2RlKSB7XG4gIFRyYWNlTW9kZVtUcmFjZU1vZGVbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgVHJhY2VNb2RlW1RyYWNlTW9kZVtcIkxPR1wiXSA9IDFdID0gXCJMT0dcIjtcbiAgVHJhY2VNb2RlW1RyYWNlTW9kZVtcIkJSRUFLXCJdID0gMl0gPSBcIkJSRUFLXCI7XG59KShUcmFjZU1vZGUgfHwgKFRyYWNlTW9kZSA9IHt9KSk7XG52YXIgQ2F1Z2h0RXhjZXB0aW9uID0gZnVuY3Rpb24gQ2F1Z2h0RXhjZXB0aW9uKGNhdXNlKSB7XG4gIHRoaXMuY2F1c2UgPSB2b2lkIDA7XG4gIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgLy8gRW1wdHlcbn07XG5cbmZ1bmN0aW9uIGlzQ2F1Z2h0RXhjZXB0aW9uKGUpIHtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBDYXVnaHRFeGNlcHRpb247XG59XG4vKipcclxuICogRmluZHMgb3V0IHdoZXRoZXIgYW55IGRlcGVuZGVuY3kgb2YgdGhlIGRlcml2YXRpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXHJcbiAqIElmIGRlcGVuZGVuY2llc1N0YXRlIGlzIDEgdGhlbiBpdCB3aWxsIHJlY2FsY3VsYXRlIGRlcGVuZGVuY2llcyxcclxuICogaWYgYW55IGRlcGVuZGVuY3kgY2hhbmdlZCBpdCB3aWxsIHByb3BhZ2F0ZSBpdCBieSBjaGFuZ2luZyBkZXBlbmRlbmNpZXNTdGF0ZSB0byAyLlxyXG4gKlxyXG4gKiBCeSBpdGVyYXRpbmcgb3ZlciB0aGUgZGVwZW5kZW5jaWVzIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSB3ZXJlIHJlcG9ydGVkIGFuZFxyXG4gKiBzdG9wcGluZyBvbiB0aGUgZmlyc3QgY2hhbmdlLCBhbGwgdGhlIHJlY2FsY3VsYXRpb25zIGFyZSBvbmx5IGNhbGxlZCBmb3IgQ29tcHV0ZWRWYWx1ZXNcclxuICogdGhhdCB3aWxsIGJlIHRyYWNrZWQgYnkgZGVyaXZhdGlvbi4gVGhhdCBpcyBiZWNhdXNlIHdlIGFzc3VtZSB0aGF0IGlmIHRoZSBmaXJzdCB4XHJcbiAqIGRlcGVuZGVuY2llcyBvZiB0aGUgZGVyaXZhdGlvbiBkb2Vzbid0IGNoYW5nZSB0aGVuIHRoZSBkZXJpdmF0aW9uIHNob3VsZCBydW4gdGhlIHNhbWUgd2F5XHJcbiAqIHVwIHVudGlsIGFjY2Vzc2luZyB4LXRoIGRlcGVuZGVuY3kuXHJcbiAqL1xuZnVuY3Rpb24gc2hvdWxkQ29tcHV0ZShkZXJpdmF0aW9uKSB7XG4gIHN3aXRjaCAoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8pIHtcbiAgICBjYXNlIElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXzpcbiAgICBjYXNlIElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgSURlcml2YXRpb25TdGF0ZV8uUE9TU0lCTFlfU1RBTEVfOlxuICAgICAge1xuICAgICAgICAvLyBzdGF0ZSBwcm9wYWdhdGlvbiBjYW4gb2NjdXIgb3V0c2lkZSBvZiBhY3Rpb24vcmVhY3RpdmUgY29udGV4dCAjMjE5NVxuICAgICAgICB2YXIgcHJldkFsbG93U3RhdGVSZWFkcyA9IGFsbG93U3RhdGVSZWFkc1N0YXJ0KHRydWUpO1xuICAgICAgICB2YXIgcHJldlVudHJhY2tlZCA9IHVudHJhY2tlZFN0YXJ0KCk7IC8vIG5vIG5lZWQgZm9yIHRob3NlIGNvbXB1dGVkcyB0byBiZSByZXBvcnRlZCwgdGhleSB3aWxsIGJlIHBpY2tlZCB1cCBpbiB0cmFja0Rlcml2ZWRGdW5jdGlvbi5cbiAgICAgICAgdmFyIG9icyA9IGRlcml2YXRpb24ub2JzZXJ2aW5nXyxcbiAgICAgICAgICBsID0gb2JzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgb2JqID0gb2JzW2ldO1xuICAgICAgICAgIGlmIChpc0NvbXB1dGVkVmFsdWUob2JqKSkge1xuICAgICAgICAgICAgaWYgKGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMpIHtcbiAgICAgICAgICAgICAgb2JqLmdldCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvYmouZ2V0KCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgbm90IGludGVyZXN0ZWQgaW4gdGhlIHZhbHVlICpvciogZXhjZXB0aW9uIGF0IHRoaXMgbW9tZW50LCBidXQgaWYgdGhlcmUgaXMgb25lLCBub3RpZnkgYWxsXG4gICAgICAgICAgICAgICAgdW50cmFja2VkRW5kKHByZXZVbnRyYWNrZWQpO1xuICAgICAgICAgICAgICAgIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2QWxsb3dTdGF0ZVJlYWRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgQ29tcHV0ZWRWYWx1ZSBgb2JqYCBhY3R1YWxseSBjaGFuZ2VkIGl0IHdpbGwgYmUgY29tcHV0ZWQgYW5kIHByb3BhZ2F0ZWQgdG8gaXRzIG9ic2VydmVycy5cbiAgICAgICAgICAgIC8vIGFuZCBgZGVyaXZhdGlvbmAgaXMgYW4gb2JzZXJ2ZXIgb2YgYG9iamBcbiAgICAgICAgICAgIC8vIGludmFyaWFudFNob3VsZENvbXB1dGUoZGVyaXZhdGlvbilcbiAgICAgICAgICAgIGlmIChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfKSB7XG4gICAgICAgICAgICAgIHVudHJhY2tlZEVuZChwcmV2VW50cmFja2VkKTtcbiAgICAgICAgICAgICAgYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXZBbGxvd1N0YXRlUmVhZHMpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlRGVwZW5kZW5jaWVzU3RhdGVUbzAoZGVyaXZhdGlvbik7XG4gICAgICAgIHVudHJhY2tlZEVuZChwcmV2VW50cmFja2VkKTtcbiAgICAgICAgYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXZBbGxvd1N0YXRlUmVhZHMpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQ29tcHV0aW5nRGVyaXZhdGlvbigpIHtcbiAgcmV0dXJuIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiAhPT0gbnVsbDsgLy8gZmlsdGVyIG91dCBhY3Rpb25zIGluc2lkZSBjb21wdXRhdGlvbnNcbn1cblxuZnVuY3Rpb24gY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQoYXRvbSkge1xuICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBoYXNPYnNlcnZlcnMgPSBhdG9tLm9ic2VydmVyc18uc2l6ZSA+IDA7XG4gIC8vIFNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gY2hhbmdlIG9ic2VydmVkIHN0YXRlIG91dHNpZGUgc3RyaWN0IG1vZGUsIGV4Y2VwdCBkdXJpbmcgaW5pdGlhbGl6YXRpb24sIHNlZSAjNTYzXG4gIGlmICghZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgJiYgKGhhc09ic2VydmVycyB8fCBnbG9iYWxTdGF0ZS5lbmZvcmNlQWN0aW9ucyA9PT0gXCJhbHdheXNcIikpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbTW9iWF0gXCIgKyAoZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnMgPyBcIlNpbmNlIHN0cmljdC1tb2RlIGlzIGVuYWJsZWQsIGNoYW5naW5nIChvYnNlcnZlZCkgb2JzZXJ2YWJsZSB2YWx1ZXMgd2l0aG91dCB1c2luZyBhbiBhY3Rpb24gaXMgbm90IGFsbG93ZWQuIFRyaWVkIHRvIG1vZGlmeTogXCIgOiBcIlNpZGUgZWZmZWN0cyBsaWtlIGNoYW5naW5nIHN0YXRlIGFyZSBub3QgYWxsb3dlZCBhdCB0aGlzIHBvaW50LiBBcmUgeW91IHRyeWluZyB0byBtb2RpZnkgc3RhdGUgZnJvbSwgZm9yIGV4YW1wbGUsIGEgY29tcHV0ZWQgdmFsdWUgb3IgdGhlIHJlbmRlciBmdW5jdGlvbiBvZiBhIFJlYWN0IGNvbXBvbmVudD8gWW91IGNhbiB3cmFwIHNpZGUgZWZmZWN0cyBpbiAncnVuSW5BY3Rpb24nIChvciBkZWNvcmF0ZSBmdW5jdGlvbnMgd2l0aCAnYWN0aW9uJykgaWYgbmVlZGVkLiBUcmllZCB0byBtb2RpZnk6IFwiKSArIGF0b20ubmFtZV8pO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja0lmU3RhdGVSZWFkc0FyZUFsbG93ZWQob2JzZXJ2YWJsZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlUmVhZHMgJiYgZ2xvYmFsU3RhdGUub2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oXCJbbW9ieF0gT2JzZXJ2YWJsZSAnXCIgKyBvYnNlcnZhYmxlLm5hbWVfICsgXCInIGJlaW5nIHJlYWQgb3V0c2lkZSBhIHJlYWN0aXZlIGNvbnRleHQuXCIpO1xuICB9XG59XG4vKipcclxuICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGBmYCBhbmQgdHJhY2tzIHdoaWNoIG9ic2VydmFibGVzIGFyZSBiZWluZyBhY2Nlc3NlZC5cclxuICogVGhlIHRyYWNraW5nIGluZm9ybWF0aW9uIGlzIHN0b3JlZCBvbiB0aGUgYGRlcml2YXRpb25gIG9iamVjdCBhbmQgdGhlIGRlcml2YXRpb24gaXMgcmVnaXN0ZXJlZFxyXG4gKiBhcyBvYnNlcnZlciBvZiBhbnkgb2YgdGhlIGFjY2Vzc2VkIG9ic2VydmFibGVzLlxyXG4gKi9cbmZ1bmN0aW9uIHRyYWNrRGVyaXZlZEZ1bmN0aW9uKGRlcml2YXRpb24sIGYsIGNvbnRleHQpIHtcbiAgdmFyIHByZXZBbGxvd1N0YXRlUmVhZHMgPSBhbGxvd1N0YXRlUmVhZHNTdGFydCh0cnVlKTtcbiAgLy8gcHJlIGFsbG9jYXRlIGFycmF5IGFsbG9jYXRpb24gKyByb29tIGZvciB2YXJpYXRpb24gaW4gZGVwc1xuICAvLyBhcnJheSB3aWxsIGJlIHRyaW1tZWQgYnkgYmluZERlcGVuZGVuY2llc1xuICBjaGFuZ2VEZXBlbmRlbmNpZXNTdGF0ZVRvMChkZXJpdmF0aW9uKTtcbiAgZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmdfID0gbmV3IEFycmF5KGRlcml2YXRpb24ub2JzZXJ2aW5nXy5sZW5ndGggKyAxMDApO1xuICBkZXJpdmF0aW9uLnVuYm91bmREZXBzQ291bnRfID0gMDtcbiAgZGVyaXZhdGlvbi5ydW5JZF8gPSArK2dsb2JhbFN0YXRlLnJ1bklkO1xuICB2YXIgcHJldlRyYWNraW5nID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBkZXJpdmF0aW9uO1xuICBnbG9iYWxTdGF0ZS5pbkJhdGNoKys7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzID09PSB0cnVlKSB7XG4gICAgcmVzdWx0ID0gZi5jYWxsKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBmLmNhbGwoY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVzdWx0ID0gbmV3IENhdWdodEV4Y2VwdGlvbihlKTtcbiAgICB9XG4gIH1cbiAgZ2xvYmFsU3RhdGUuaW5CYXRjaC0tO1xuICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBwcmV2VHJhY2tpbmc7XG4gIGJpbmREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbik7XG4gIHdhcm5BYm91dERlcml2YXRpb25XaXRob3V0RGVwZW5kZW5jaWVzKGRlcml2YXRpb24pO1xuICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3YXJuQWJvdXREZXJpdmF0aW9uV2l0aG91dERlcGVuZGVuY2llcyhkZXJpdmF0aW9uKSB7XG4gIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGRlcml2YXRpb24ub2JzZXJ2aW5nXy5sZW5ndGggIT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBkZXJpdmF0aW9uLnJlcXVpcmVzT2JzZXJ2YWJsZV8gPT09IFwiYm9vbGVhblwiID8gZGVyaXZhdGlvbi5yZXF1aXJlc09ic2VydmFibGVfIDogZ2xvYmFsU3RhdGUucmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbbW9ieF0gRGVyaXZhdGlvbiAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInIGlzIGNyZWF0ZWQvdXBkYXRlZCB3aXRob3V0IHJlYWRpbmcgYW55IG9ic2VydmFibGUgdmFsdWUuXCIpO1xuICB9XG59XG4vKipcclxuICogZGlmZnMgbmV3T2JzZXJ2aW5nIHdpdGggb2JzZXJ2aW5nLlxyXG4gKiB1cGRhdGUgb2JzZXJ2aW5nIHRvIGJlIG5ld09ic2VydmluZyB3aXRoIHVuaXF1ZSBvYnNlcnZhYmxlc1xyXG4gKiBub3RpZnkgb2JzZXJ2ZXJzIHRoYXQgYmVjb21lIG9ic2VydmVkL3Vub2JzZXJ2ZWRcclxuICovXG5mdW5jdGlvbiBiaW5kRGVwZW5kZW5jaWVzKGRlcml2YXRpb24pIHtcbiAgLy8gaW52YXJpYW50KGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGUgIT09IElEZXJpdmF0aW9uU3RhdGUuTk9UX1RSQUNLSU5HLCBcIklOVEVSTkFMIEVSUk9SIGJpbmREZXBlbmRlbmNpZXMgZXhwZWN0cyBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlICE9PSAtMVwiKTtcbiAgdmFyIHByZXZPYnNlcnZpbmcgPSBkZXJpdmF0aW9uLm9ic2VydmluZ187XG4gIHZhciBvYnNlcnZpbmcgPSBkZXJpdmF0aW9uLm9ic2VydmluZ18gPSBkZXJpdmF0aW9uLm5ld09ic2VydmluZ187XG4gIHZhciBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUgPSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXztcbiAgLy8gR28gdGhyb3VnaCBhbGwgbmV3IG9ic2VydmFibGVzIGFuZCBjaGVjayBkaWZmVmFsdWU6ICh0aGlzIGxpc3QgY2FuIGNvbnRhaW4gZHVwbGljYXRlcyk6XG4gIC8vICAgMDogZmlyc3Qgb2NjdXJyZW5jZSwgY2hhbmdlIHRvIDEgYW5kIGtlZXAgaXRcbiAgLy8gICAxOiBleHRyYSBvY2N1cnJlbmNlLCBkcm9wIGl0XG4gIHZhciBpMCA9IDAsXG4gICAgbCA9IGRlcml2YXRpb24udW5ib3VuZERlcHNDb3VudF87XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGRlcCA9IG9ic2VydmluZ1tpXTtcbiAgICBpZiAoZGVwLmRpZmZWYWx1ZV8gPT09IDApIHtcbiAgICAgIGRlcC5kaWZmVmFsdWVfID0gMTtcbiAgICAgIGlmIChpMCAhPT0gaSkge1xuICAgICAgICBvYnNlcnZpbmdbaTBdID0gZGVwO1xuICAgICAgfVxuICAgICAgaTArKztcbiAgICB9XG4gICAgLy8gVXBjYXN0IGlzICdzYWZlJyBoZXJlLCBiZWNhdXNlIGlmIGRlcCBpcyBJT2JzZXJ2YWJsZSwgYGRlcGVuZGVuY2llc1N0YXRlYCB3aWxsIGJlIHVuZGVmaW5lZCxcbiAgICAvLyBub3QgaGl0dGluZyB0aGUgY29uZGl0aW9uXG4gICAgaWYgKGRlcC5kZXBlbmRlbmNpZXNTdGF0ZV8gPiBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUpIHtcbiAgICAgIGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSA9IGRlcC5kZXBlbmRlbmNpZXNTdGF0ZV87XG4gICAgfVxuICB9XG4gIG9ic2VydmluZy5sZW5ndGggPSBpMDtcbiAgZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmdfID0gbnVsbDsgLy8gbmV3T2JzZXJ2aW5nIHNob3VsZG4ndCBiZSBuZWVkZWQgb3V0c2lkZSB0cmFja2luZyAoc3RhdGVtZW50IG1vdmVkIGRvd24gdG8gd29yayBhcm91bmQgRkYgYnVnLCBzZWUgIzYxNClcbiAgLy8gR28gdGhyb3VnaCBhbGwgb2xkIG9ic2VydmFibGVzIGFuZCBjaGVjayBkaWZmVmFsdWU6IChpdCBpcyB1bmlxdWUgYWZ0ZXIgbGFzdCBiaW5kRGVwZW5kZW5jaWVzKVxuICAvLyAgIDA6IGl0J3Mgbm90IGluIG5ldyBvYnNlcnZhYmxlcywgdW5vYnNlcnZlIGl0XG4gIC8vICAgMTogaXQga2VlcHMgYmVpbmcgb2JzZXJ2ZWQsIGRvbid0IHdhbnQgdG8gbm90aWZ5IGl0LiBjaGFuZ2UgdG8gMFxuICBsID0gcHJldk9ic2VydmluZy5sZW5ndGg7XG4gIHdoaWxlIChsLS0pIHtcbiAgICB2YXIgX2RlcCA9IHByZXZPYnNlcnZpbmdbbF07XG4gICAgaWYgKF9kZXAuZGlmZlZhbHVlXyA9PT0gMCkge1xuICAgICAgcmVtb3ZlT2JzZXJ2ZXIoX2RlcCwgZGVyaXZhdGlvbik7XG4gICAgfVxuICAgIF9kZXAuZGlmZlZhbHVlXyA9IDA7XG4gIH1cbiAgLy8gR28gdGhyb3VnaCBhbGwgbmV3IG9ic2VydmFibGVzIGFuZCBjaGVjayBkaWZmVmFsdWU6IChub3cgaXQgc2hvdWxkIGJlIHVuaXF1ZSlcbiAgLy8gICAwOiBpdCB3YXMgc2V0IHRvIDAgaW4gbGFzdCBsb29wLiBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAvLyAgIDE6IGl0IHdhc24ndCBvYnNlcnZlZCwgbGV0J3Mgb2JzZXJ2ZSBpdC4gc2V0IGJhY2sgdG8gMFxuICB3aGlsZSAoaTAtLSkge1xuICAgIHZhciBfZGVwMiA9IG9ic2VydmluZ1tpMF07XG4gICAgaWYgKF9kZXAyLmRpZmZWYWx1ZV8gPT09IDEpIHtcbiAgICAgIF9kZXAyLmRpZmZWYWx1ZV8gPSAwO1xuICAgICAgYWRkT2JzZXJ2ZXIoX2RlcDIsIGRlcml2YXRpb24pO1xuICAgIH1cbiAgfVxuICAvLyBTb21lIG5ldyBvYnNlcnZlZCBkZXJpdmF0aW9ucyBtYXkgYmVjb21lIHN0YWxlIGR1cmluZyB0aGlzIGRlcml2YXRpb24gY29tcHV0YXRpb25cbiAgLy8gc28gdGhleSBoYXZlIGhhZCBubyBjaGFuY2UgdG8gcHJvcGFnYXRlIHN0YWxlbmVzcyAoIzkxNilcbiAgaWYgKGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSAhPT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9IGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZTtcbiAgICBkZXJpdmF0aW9uLm9uQmVjb21lU3RhbGVfKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFyT2JzZXJ2aW5nKGRlcml2YXRpb24pIHtcbiAgLy8gaW52YXJpYW50KGdsb2JhbFN0YXRlLmluQmF0Y2ggPiAwLCBcIklOVEVSTkFMIEVSUk9SIGNsZWFyT2JzZXJ2aW5nIHNob3VsZCBiZSBjYWxsZWQgb25seSBpbnNpZGUgYmF0Y2hcIik7XG4gIHZhciBvYnMgPSBkZXJpdmF0aW9uLm9ic2VydmluZ187XG4gIGRlcml2YXRpb24ub2JzZXJ2aW5nXyA9IFtdO1xuICB2YXIgaSA9IG9icy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZW1vdmVPYnNlcnZlcihvYnNbaV0sIGRlcml2YXRpb24pO1xuICB9XG4gIGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbn1cbmZ1bmN0aW9uIHVudHJhY2tlZChhY3Rpb24pIHtcbiAgdmFyIHByZXYgPSB1bnRyYWNrZWRTdGFydCgpO1xuICB0cnkge1xuICAgIHJldHVybiBhY3Rpb24oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB1bnRyYWNrZWRFbmQocHJldik7XG4gIH1cbn1cbmZ1bmN0aW9uIHVudHJhY2tlZFN0YXJ0KCkge1xuICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uID0gbnVsbDtcbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiB1bnRyYWNrZWRFbmQocHJldikge1xuICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBwcmV2O1xufVxuZnVuY3Rpb24gYWxsb3dTdGF0ZVJlYWRzU3RhcnQoYWxsb3dTdGF0ZVJlYWRzKSB7XG4gIHZhciBwcmV2ID0gZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzO1xuICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlUmVhZHMgPSBhbGxvd1N0YXRlUmVhZHM7XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXYpIHtcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzID0gcHJldjtcbn1cbi8qKlxyXG4gKiBuZWVkZWQgdG8ga2VlcCBgbG93ZXN0T2JzZXJ2ZXJTdGF0ZWAgY29ycmVjdC4gd2hlbiBjaGFuZ2luZyBmcm9tICgyIG9yIDEpIHRvIDBcclxuICpcclxuICovXG5mdW5jdGlvbiBjaGFuZ2VEZXBlbmRlbmNpZXNTdGF0ZVRvMChkZXJpdmF0aW9uKSB7XG4gIGlmIChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXztcbiAgdmFyIG9icyA9IGRlcml2YXRpb24ub2JzZXJ2aW5nXztcbiAgdmFyIGkgPSBvYnMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb2JzW2ldLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gIH1cbn1cblxuLyoqXHJcbiAqIFRoZXNlIHZhbHVlcyB3aWxsIHBlcnNpc3QgaWYgZ2xvYmFsIHN0YXRlIGlzIHJlc2V0XHJcbiAqL1xudmFyIHBlcnNpc3RlbnRLZXlzID0gW1wibW9ieEd1aWRcIiwgXCJzcHlMaXN0ZW5lcnNcIiwgXCJlbmZvcmNlQWN0aW9uc1wiLCBcImNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvblwiLCBcInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlXCIsIFwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb25cIiwgXCJhbGxvd1N0YXRlUmVhZHNcIiwgXCJkaXNhYmxlRXJyb3JCb3VuZGFyaWVzXCIsIFwicnVuSWRcIiwgXCJVTkNIQU5HRURcIiwgXCJ1c2VQcm94aWVzXCJdO1xudmFyIE1vYlhHbG9iYWxzID0gZnVuY3Rpb24gTW9iWEdsb2JhbHMoKSB7XG4gIHRoaXMudmVyc2lvbiA9IDY7XG4gIHRoaXMuVU5DSEFOR0VEID0ge307XG4gIHRoaXMudHJhY2tpbmdEZXJpdmF0aW9uID0gbnVsbDtcbiAgdGhpcy50cmFja2luZ0NvbnRleHQgPSBudWxsO1xuICB0aGlzLnJ1bklkID0gMDtcbiAgdGhpcy5tb2J4R3VpZCA9IDA7XG4gIHRoaXMuaW5CYXRjaCA9IDA7XG4gIHRoaXMucGVuZGluZ1Vub2JzZXJ2YXRpb25zID0gW107XG4gIHRoaXMucGVuZGluZ1JlYWN0aW9ucyA9IFtdO1xuICB0aGlzLmlzUnVubmluZ1JlYWN0aW9ucyA9IGZhbHNlO1xuICB0aGlzLmFsbG93U3RhdGVDaGFuZ2VzID0gZmFsc2U7XG4gIHRoaXMuYWxsb3dTdGF0ZVJlYWRzID0gdHJ1ZTtcbiAgdGhpcy5lbmZvcmNlQWN0aW9ucyA9IHRydWU7XG4gIHRoaXMuc3B5TGlzdGVuZXJzID0gW107XG4gIHRoaXMuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzID0gW107XG4gIHRoaXMuY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uID0gZmFsc2U7XG4gIHRoaXMucmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGUgPSBmYWxzZTtcbiAgdGhpcy5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbiA9IGZhbHNlO1xuICB0aGlzLmRpc2FibGVFcnJvckJvdW5kYXJpZXMgPSBmYWxzZTtcbiAgdGhpcy5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzID0gZmFsc2U7XG4gIHRoaXMudXNlUHJveGllcyA9IHRydWU7XG4gIHRoaXMudmVyaWZ5UHJveGllcyA9IGZhbHNlO1xuICB0aGlzLnNhZmVEZXNjcmlwdG9ycyA9IHRydWU7XG59O1xudmFyIGNhbk1lcmdlR2xvYmFsU3RhdGUgPSB0cnVlO1xudmFyIGlzb2xhdGVDYWxsZWQgPSBmYWxzZTtcbnZhciBnbG9iYWxTdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBnbG9iYWwgPSAvKiNfX1BVUkVfXyovZ2V0R2xvYmFsKCk7XG4gIGlmIChnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCA+IDAgJiYgIWdsb2JhbC5fX21vYnhHbG9iYWxzKSB7XG4gICAgY2FuTWVyZ2VHbG9iYWxTdGF0ZSA9IGZhbHNlO1xuICB9XG4gIGlmIChnbG9iYWwuX19tb2J4R2xvYmFscyAmJiBnbG9iYWwuX19tb2J4R2xvYmFscy52ZXJzaW9uICE9PSBuZXcgTW9iWEdsb2JhbHMoKS52ZXJzaW9uKSB7XG4gICAgY2FuTWVyZ2VHbG9iYWxTdGF0ZSA9IGZhbHNlO1xuICB9XG4gIGlmICghY2FuTWVyZ2VHbG9iYWxTdGF0ZSkge1xuICAgIC8vIEJlY2F1c2UgdGhpcyBpcyBhIElJRkUgd2UgbmVlZCB0byBsZXQgaXNvbGF0ZUNhbGxlZCBhIGNoYW5jZSB0byBjaGFuZ2VcbiAgICAvLyBzbyB3ZSBydW4gaXQgYWZ0ZXIgdGhlIGV2ZW50IGxvb3AgY29tcGxldGVkIGF0IGxlYXN0IDEgaXRlcmF0aW9uXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWlzb2xhdGVDYWxsZWQpIHtcbiAgICAgICAgZGllKDM1KTtcbiAgICAgIH1cbiAgICB9LCAxKTtcbiAgICByZXR1cm4gbmV3IE1vYlhHbG9iYWxzKCk7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLl9fbW9ieEdsb2JhbHMpIHtcbiAgICBnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCArPSAxO1xuICAgIGlmICghZ2xvYmFsLl9fbW9ieEdsb2JhbHMuVU5DSEFOR0VEKSB7XG4gICAgICBnbG9iYWwuX19tb2J4R2xvYmFscy5VTkNIQU5HRUQgPSB7fTtcbiAgICB9IC8vIG1ha2UgbWVyZ2UgYmFja3dhcmQgY29tcGF0aWJsZVxuICAgIHJldHVybiBnbG9iYWwuX19tb2J4R2xvYmFscztcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCA9IDE7XG4gICAgcmV0dXJuIGdsb2JhbC5fX21vYnhHbG9iYWxzID0gLyojX19QVVJFX18qL25ldyBNb2JYR2xvYmFscygpO1xuICB9XG59KCk7XG5mdW5jdGlvbiBpc29sYXRlR2xvYmFsU3RhdGUoKSB7XG4gIGlmIChnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zLmxlbmd0aCB8fCBnbG9iYWxTdGF0ZS5pbkJhdGNoIHx8IGdsb2JhbFN0YXRlLmlzUnVubmluZ1JlYWN0aW9ucykge1xuICAgIGRpZSgzNik7XG4gIH1cbiAgaXNvbGF0ZUNhbGxlZCA9IHRydWU7XG4gIGlmIChjYW5NZXJnZUdsb2JhbFN0YXRlKSB7XG4gICAgdmFyIGdsb2JhbCA9IGdldEdsb2JhbCgpO1xuICAgIGlmICgtLWdsb2JhbC5fX21vYnhJbnN0YW5jZUNvdW50ID09PSAwKSB7XG4gICAgICBnbG9iYWwuX19tb2J4R2xvYmFscyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2xvYmFsU3RhdGUgPSBuZXcgTW9iWEdsb2JhbHMoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0R2xvYmFsU3RhdGUoKSB7XG4gIHJldHVybiBnbG9iYWxTdGF0ZTtcbn1cbi8qKlxyXG4gKiBGb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5OyB0aGlzIHdpbGwgYnJlYWsgdGhlIGludGVybmFsIHN0YXRlIG9mIGV4aXN0aW5nIG9ic2VydmFibGVzLFxyXG4gKiBidXQgY2FuIGJlIHVzZWQgdG8gZ2V0IGJhY2sgYXQgYSBzdGFibGUgc3RhdGUgYWZ0ZXIgdGhyb3dpbmcgZXJyb3JzXHJcbiAqL1xuZnVuY3Rpb24gcmVzZXRHbG9iYWxTdGF0ZSgpIHtcbiAgdmFyIGRlZmF1bHRHbG9iYWxzID0gbmV3IE1vYlhHbG9iYWxzKCk7XG4gIGZvciAodmFyIGtleSBpbiBkZWZhdWx0R2xvYmFscykge1xuICAgIGlmIChwZXJzaXN0ZW50S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICBnbG9iYWxTdGF0ZVtrZXldID0gZGVmYXVsdEdsb2JhbHNba2V5XTtcbiAgICB9XG4gIH1cbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSAhZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGhhc09ic2VydmVycyhvYnNlcnZhYmxlKSB7XG4gIHJldHVybiBvYnNlcnZhYmxlLm9ic2VydmVyc18gJiYgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLnNpemUgPiAwO1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJzKG9ic2VydmFibGUpIHtcbiAgcmV0dXJuIG9ic2VydmFibGUub2JzZXJ2ZXJzXztcbn1cbi8vIGZ1bmN0aW9uIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlOiBJT2JzZXJ2YWJsZSkge1xuLy8gICAgIGNvbnN0IGxpc3QgPSBvYnNlcnZhYmxlLm9ic2VydmVyc1xuLy8gICAgIGNvbnN0IG1hcCA9IG9ic2VydmFibGUub2JzZXJ2ZXJzSW5kZXhlc1xuLy8gICAgIGNvbnN0IGwgPSBsaXN0Lmxlbmd0aFxuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4vLyAgICAgICAgIGNvbnN0IGlkID0gbGlzdFtpXS5fX21hcGlkXG4vLyAgICAgICAgIGlmIChpKSB7XG4vLyAgICAgICAgICAgICBpbnZhcmlhbnQobWFwW2lkXSA9PT0gaSwgXCJJTlRFUk5BTCBFUlJPUiBtYXBzIGRlcml2YXRpb24uX19tYXBpZCB0byBpbmRleCBpbiBsaXN0XCIpIC8vIGZvciBwZXJmb3JtYW5jZVxuLy8gICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgaW52YXJpYW50KCEoaWQgaW4gbWFwKSwgXCJJTlRFUk5BTCBFUlJPUiBvYnNlcnZlciBvbiBpbmRleCAwIHNob3VsZG4ndCBiZSBoZWxkIGluIG1hcC5cIikgLy8gZm9yIHBlcmZvcm1hbmNlXG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vLyAgICAgaW52YXJpYW50KFxuLy8gICAgICAgICBsaXN0Lmxlbmd0aCA9PT0gMCB8fCBPYmplY3Qua2V5cyhtYXApLmxlbmd0aCA9PT0gbGlzdC5sZW5ndGggLSAxLFxuLy8gICAgICAgICBcIklOVEVSTkFMIEVSUk9SIHRoZXJlIGlzIG5vIGp1bmsgaW4gbWFwXCJcbi8vICAgICApXG4vLyB9XG5mdW5jdGlvbiBhZGRPYnNlcnZlcihvYnNlcnZhYmxlLCBub2RlKSB7XG4gIC8vIGludmFyaWFudChub2RlLmRlcGVuZGVuY2llc1N0YXRlICE9PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiwgY2FuIGFkZCBvbmx5IGRlcGVuZGVuY2llc1N0YXRlICE9PSAtMVwiKTtcbiAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpID09PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiBhZGQgYWxyZWFkeSBhZGRlZCBub2RlXCIpO1xuICAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5hZGQobm9kZSk7XG4gIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID4gbm9kZS5kZXBlbmRlbmNpZXNTdGF0ZV8pIHtcbiAgICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gbm9kZS5kZXBlbmRlbmNpZXNTdGF0ZV87XG4gIH1cbiAgLy8gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGUpO1xuICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmluZGV4T2Yobm9kZSkgIT09IC0xLCBcIklOVEVSTkFMIEVSUk9SIGRpZG4ndCBhZGQgbm9kZVwiKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2YWJsZSwgbm9kZSkge1xuICAvLyBpbnZhcmlhbnQoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAsIFwiSU5URVJOQUwgRVJST1IsIHJlbW92ZSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgaW5zaWRlIGJhdGNoXCIpO1xuICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmluZGV4T2Yobm9kZSkgIT09IC0xLCBcIklOVEVSTkFMIEVSUk9SIHJlbW92ZSBhbHJlYWR5IHJlbW92ZWQgbm9kZVwiKTtcbiAgLy8gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGUpO1xuICBvYnNlcnZhYmxlLm9ic2VydmVyc19bXCJkZWxldGVcIl0obm9kZSk7XG4gIGlmIChvYnNlcnZhYmxlLm9ic2VydmVyc18uc2l6ZSA9PT0gMCkge1xuICAgIC8vIGRlbGV0aW5nIGxhc3Qgb2JzZXJ2ZXJcbiAgICBxdWV1ZUZvclVub2JzZXJ2YXRpb24ob2JzZXJ2YWJsZSk7XG4gIH1cbiAgLy8gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGUpO1xuICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmluZGV4T2Yobm9kZSkgPT09IC0xLCBcIklOVEVSTkFMIEVSUk9SIHJlbW92ZSBhbHJlYWR5IHJlbW92ZWQgbm9kZTJcIik7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlRm9yVW5vYnNlcnZhdGlvbihvYnNlcnZhYmxlKSB7XG4gIGlmIChvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb25fID09PSBmYWxzZSkge1xuICAgIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMubGVuZ3RoID09PSAwLCBcIklOVEVSTkFMIEVSUk9SLCBzaG91bGQgb25seSBxdWV1ZSBmb3IgdW5vYnNlcnZhdGlvbiB1bm9ic2VydmVkIG9ic2VydmFibGVzXCIpO1xuICAgIG9ic2VydmFibGUuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbl8gPSB0cnVlO1xuICAgIGdsb2JhbFN0YXRlLnBlbmRpbmdVbm9ic2VydmF0aW9ucy5wdXNoKG9ic2VydmFibGUpO1xuICB9XG59XG4vKipcclxuICogQmF0Y2ggc3RhcnRzIGEgdHJhbnNhY3Rpb24sIGF0IGxlYXN0IGZvciBwdXJwb3NlcyBvZiBtZW1vaXppbmcgQ29tcHV0ZWRWYWx1ZXMgd2hlbiBub3RoaW5nIGVsc2UgZG9lcy5cclxuICogRHVyaW5nIGEgYmF0Y2ggYG9uQmVjb21lVW5vYnNlcnZlZGAgd2lsbCBiZSBjYWxsZWQgYXQgbW9zdCBvbmNlIHBlciBvYnNlcnZhYmxlLlxyXG4gKiBBdm9pZHMgdW5uZWNlc3NhcnkgcmVjYWxjdWxhdGlvbnMuXHJcbiAqL1xuZnVuY3Rpb24gc3RhcnRCYXRjaCgpIHtcbiAgZ2xvYmFsU3RhdGUuaW5CYXRjaCsrO1xufVxuZnVuY3Rpb24gZW5kQmF0Y2goKSB7XG4gIGlmICgtLWdsb2JhbFN0YXRlLmluQmF0Y2ggPT09IDApIHtcbiAgICBydW5SZWFjdGlvbnMoKTtcbiAgICAvLyB0aGUgYmF0Y2ggaXMgYWN0dWFsbHkgYWJvdXQgdG8gZmluaXNoLCBhbGwgdW5vYnNlcnZpbmcgc2hvdWxkIGhhcHBlbiBoZXJlLlxuICAgIHZhciBsaXN0ID0gZ2xvYmFsU3RhdGUucGVuZGluZ1Vub2JzZXJ2YXRpb25zO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBsaXN0W2ldO1xuICAgICAgb2JzZXJ2YWJsZS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uXyA9IGZhbHNlO1xuICAgICAgaWYgKG9ic2VydmFibGUub2JzZXJ2ZXJzXy5zaXplID09PSAwKSB7XG4gICAgICAgIGlmIChvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZF8pIHtcbiAgICAgICAgICAvLyBpZiB0aGlzIG9ic2VydmFibGUgaGFkIHJlYWN0aXZlIG9ic2VydmVycywgdHJpZ2dlciB0aGUgaG9va3NcbiAgICAgICAgICBvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZF8gPSBmYWxzZTtcbiAgICAgICAgICBvYnNlcnZhYmxlLm9uQlVPKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ic2VydmFibGUgaW5zdGFuY2VvZiBDb21wdXRlZFZhbHVlKSB7XG4gICAgICAgICAgLy8gY29tcHV0ZWQgdmFsdWVzIGFyZSBhdXRvbWF0aWNhbGx5IHRlYXJlZCBkb3duIHdoZW4gdGhlIGxhc3Qgb2JzZXJ2ZXIgbGVhdmVzXG4gICAgICAgICAgLy8gdGhpcyBwcm9jZXNzIGhhcHBlbnMgcmVjdXJzaXZlbHksIHRoaXMgY29tcHV0ZWQgbWlnaHQgYmUgdGhlIGxhc3Qgb2JzZXJ2YWJlIG9mIGFub3RoZXIsIGV0Yy4uXG4gICAgICAgICAgb2JzZXJ2YWJsZS5zdXNwZW5kXygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdsb2JhbFN0YXRlLnBlbmRpbmdVbm9ic2VydmF0aW9ucyA9IFtdO1xuICB9XG59XG5mdW5jdGlvbiByZXBvcnRPYnNlcnZlZChvYnNlcnZhYmxlKSB7XG4gIGNoZWNrSWZTdGF0ZVJlYWRzQXJlQWxsb3dlZChvYnNlcnZhYmxlKTtcbiAgdmFyIGRlcml2YXRpb24gPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG4gIGlmIChkZXJpdmF0aW9uICE9PSBudWxsKSB7XG4gICAgLyoqXHJcbiAgICAgKiBTaW1wbGUgb3B0aW1pemF0aW9uLCBnaXZlIGVhY2ggZGVyaXZhdGlvbiBydW4gYW4gdW5pcXVlIGlkIChydW5JZClcclxuICAgICAqIENoZWNrIGlmIGxhc3QgdGltZSB0aGlzIG9ic2VydmFibGUgd2FzIGFjY2Vzc2VkIHRoZSBzYW1lIHJ1bklkIGlzIHVzZWRcclxuICAgICAqIGlmIHRoaXMgaXMgdGhlIGNhc2UsIHRoZSByZWxhdGlvbiBpcyBhbHJlYWR5IGtub3duXHJcbiAgICAgKi9cbiAgICBpZiAoZGVyaXZhdGlvbi5ydW5JZF8gIT09IG9ic2VydmFibGUubGFzdEFjY2Vzc2VkQnlfKSB7XG4gICAgICBvYnNlcnZhYmxlLmxhc3RBY2Nlc3NlZEJ5XyA9IGRlcml2YXRpb24ucnVuSWRfO1xuICAgICAgLy8gVHJpZWQgc3RvcmluZyBuZXdPYnNlcnZpbmcsIG9yIG9ic2VydmluZywgb3IgYm90aCBhcyBTZXQsIGJ1dCBwZXJmb3JtYW5jZSBkaWRuJ3QgY29tZSBjbG9zZS4uLlxuICAgICAgZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmdfW2Rlcml2YXRpb24udW5ib3VuZERlcHNDb3VudF8rK10gPSBvYnNlcnZhYmxlO1xuICAgICAgaWYgKCFvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZF8gJiYgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0KSB7XG4gICAgICAgIG9ic2VydmFibGUuaXNCZWluZ09ic2VydmVkXyA9IHRydWU7XG4gICAgICAgIG9ic2VydmFibGUub25CTygpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWRfO1xuICB9IGVsc2UgaWYgKG9ic2VydmFibGUub2JzZXJ2ZXJzXy5zaXplID09PSAwICYmIGdsb2JhbFN0YXRlLmluQmF0Y2ggPiAwKSB7XG4gICAgcXVldWVGb3JVbm9ic2VydmF0aW9uKG9ic2VydmFibGUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIGZ1bmN0aW9uIGludmFyaWFudExPUyhvYnNlcnZhYmxlOiBJT2JzZXJ2YWJsZSwgbXNnOiBzdHJpbmcpIHtcbi8vICAgICAvLyBpdCdzIGV4cGVuc2l2ZSBzbyBiZXR0ZXIgbm90IHJ1biBpdCBpbiBwcm9kdWNpdG9uLiBidXQgdGVtcG9yYXJpbHkgaGVscGZ1bCBmb3IgdGVzdGluZ1xuLy8gICAgIGNvbnN0IG1pbiA9IGdldE9ic2VydmVycyhvYnNlcnZhYmxlKS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWluKGEsIGIuZGVwZW5kZW5jaWVzU3RhdGUpLCAyKVxuLy8gICAgIGlmIChtaW4gPj0gb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlKSByZXR1cm4gLy8gPC0gdGhlIG9ubHkgYXNzdW1wdGlvbiBhYm91dCBgbG93ZXN0T2JzZXJ2ZXJTdGF0ZWBcbi8vICAgICB0aHJvdyBuZXcgRXJyb3IoXG4vLyAgICAgICAgIFwibG93ZXN0T2JzZXJ2ZXJTdGF0ZSBpcyB3cm9uZyBmb3IgXCIgK1xuLy8gICAgICAgICAgICAgbXNnICtcbi8vICAgICAgICAgICAgIFwiIGJlY2F1c2UgXCIgK1xuLy8gICAgICAgICAgICAgbWluICtcbi8vICAgICAgICAgICAgIFwiIDwgXCIgK1xuLy8gICAgICAgICAgICAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXG4vLyAgICAgKVxuLy8gfVxuLyoqXHJcbiAqIE5PVEU6IGN1cnJlbnQgcHJvcGFnYXRpb24gbWVjaGFuaXNtIHdpbGwgaW4gY2FzZSBvZiBzZWxmIHJlcnVuaW5nIGF1dG9ydW5zIGJlaGF2ZSB1bmV4cGVjdGVkbHlcclxuICogSXQgd2lsbCBwcm9wYWdhdGUgY2hhbmdlcyB0byBvYnNlcnZlcnMgZnJvbSBwcmV2aW91cyBydW5cclxuICogSXQncyBoYXJkIG9yIG1heWJlIGltcG9zc2libGUgKHdpdGggcmVhc29uYWJsZSBwZXJmKSB0byBnZXQgaXQgcmlnaHQgd2l0aCBjdXJyZW50IGFwcHJvYWNoXHJcbiAqIEhvcGVmdWxseSBzZWxmIHJlcnVuaW5nIGF1dG9ydW5zIGFyZW4ndCBhIGZlYXR1cmUgcGVvcGxlIHNob3VsZCBkZXBlbmQgb25cclxuICogQWxzbyBtb3N0IGJhc2ljIHVzZSBjYXNlcyBzaG91bGQgYmUgb2tcclxuICovXG4vLyBDYWxsZWQgYnkgQXRvbSB3aGVuIGl0cyB2YWx1ZSBjaGFuZ2VzXG5mdW5jdGlvbiBwcm9wYWdhdGVDaGFuZ2VkKG9ic2VydmFibGUpIHtcbiAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY2hhbmdlZCBzdGFydFwiKTtcbiAgaWYgKG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXykge1xuICAgIHJldHVybjtcbiAgfVxuICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfO1xuICAvLyBJZGVhbGx5IHdlIHVzZSBmb3IuLm9mIGhlcmUsIGJ1dCB0aGUgZG93bmNvbXBpbGVkIHZlcnNpb24gaXMgcmVhbGx5IHNsb3cuLi5cbiAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGQuaXNUcmFjaW5nXyAhPT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICAgICAgbG9nVHJhY2VJbmZvKGQsIG9ic2VydmFibGUpO1xuICAgICAgfVxuICAgICAgZC5vbkJlY29tZVN0YWxlXygpO1xuICAgIH1cbiAgICBkLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXztcbiAgfSk7XG4gIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNoYW5nZWQgZW5kXCIpO1xufVxuLy8gQ2FsbGVkIGJ5IENvbXB1dGVkVmFsdWUgd2hlbiBpdCByZWNhbGN1bGF0ZSBhbmQgaXRzIHZhbHVlIGNoYW5nZWRcbmZ1bmN0aW9uIHByb3BhZ2F0ZUNoYW5nZUNvbmZpcm1lZChvYnNlcnZhYmxlKSB7XG4gIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNvbmZpcm1lZCBzdGFydFwiKTtcbiAgaWYgKG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXykge1xuICAgIHJldHVybjtcbiAgfVxuICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfO1xuICBvYnNlcnZhYmxlLm9ic2VydmVyc18uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uUE9TU0lCTFlfU1RBTEVfKSB7XG4gICAgICBkLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZC5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICBsb2dUcmFjZUluZm8oZCwgb2JzZXJ2YWJsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8gLy8gdGhpcyBoYXBwZW5zIGR1cmluZyBjb21wdXRpbmcgb2YgYGRgLCBqdXN0IGtlZXAgbG93ZXN0T2JzZXJ2ZXJTdGF0ZSB1cCB0byBkYXRlLlxuICAgICkge1xuICAgICAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfO1xuICAgIH1cbiAgfSk7XG4gIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNvbmZpcm1lZCBlbmRcIik7XG59XG4vLyBVc2VkIGJ5IGNvbXB1dGVkIHdoZW4gaXRzIGRlcGVuZGVuY3kgY2hhbmdlZCwgYnV0IHdlIGRvbid0IHdhbid0IHRvIGltbWVkaWF0ZWx5IHJlY29tcHV0ZS5cbmZ1bmN0aW9uIHByb3BhZ2F0ZU1heWJlQ2hhbmdlZChvYnNlcnZhYmxlKSB7XG4gIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcIm1heWJlIHN0YXJ0XCIpO1xuICBpZiAob2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyAhPT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXztcbiAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSB7XG4gICAgICBkLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXztcbiAgICAgIGQub25CZWNvbWVTdGFsZV8oKTtcbiAgICB9XG4gIH0pO1xuICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJtYXliZSBlbmRcIik7XG59XG5cbmZ1bmN0aW9uIGxvZ1RyYWNlSW5mbyhkZXJpdmF0aW9uLCBvYnNlcnZhYmxlKSB7XG4gIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIicgaXMgaW52YWxpZGF0ZWQgZHVlIHRvIGEgY2hhbmdlIGluOiAnXCIgKyBvYnNlcnZhYmxlLm5hbWVfICsgXCInXCIpO1xuICBpZiAoZGVyaXZhdGlvbi5pc1RyYWNpbmdfID09PSBUcmFjZU1vZGUuQlJFQUspIHtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICBwcmludERlcFRyZWUoZ2V0RGVwZW5kZW5jeVRyZWUoZGVyaXZhdGlvbiksIGxpbmVzLCAxKTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBuZXcgRnVuY3Rpb24oXCJkZWJ1Z2dlcjtcXG4vKlxcblRyYWNpbmcgJ1wiICsgZGVyaXZhdGlvbi5uYW1lXyArIFwiJ1xcblxcbllvdSBhcmUgZW50ZXJpbmcgdGhpcyBicmVhayBwb2ludCBiZWNhdXNlIGRlcml2YXRpb24gJ1wiICsgZGVyaXZhdGlvbi5uYW1lXyArIFwiJyBpcyBiZWluZyB0cmFjZWQgYW5kICdcIiArIG9ic2VydmFibGUubmFtZV8gKyBcIicgaXMgbm93IGZvcmNpbmcgaXQgdG8gdXBkYXRlLlxcbkp1c3QgZm9sbG93IHRoZSBzdGFja3RyYWNlIHlvdSBzaG91bGQgbm93IHNlZSBpbiB0aGUgZGV2dG9vbHMgdG8gc2VlIHByZWNpc2VseSB3aGF0IHBpZWNlIG9mIHlvdXIgY29kZSBpcyBjYXVzaW5nIHRoaXMgdXBkYXRlXFxuVGhlIHN0YWNrZnJhbWUgeW91IGFyZSBsb29raW5nIGZvciBpcyBhdCBsZWFzdCB+Ni04IHN0YWNrLWZyYW1lcyB1cC5cXG5cXG5cIiArIChkZXJpdmF0aW9uIGluc3RhbmNlb2YgQ29tcHV0ZWRWYWx1ZSA/IGRlcml2YXRpb24uZGVyaXZhdGlvbi50b1N0cmluZygpLnJlcGxhY2UoL1sqXVxcLy9nLCBcIi9cIikgOiBcIlwiKSArIFwiXFxuXFxuVGhlIGRlcGVuZGVuY2llcyBmb3IgdGhpcyBkZXJpdmF0aW9uIGFyZTpcXG5cXG5cIiArIGxpbmVzLmpvaW4oXCJcXG5cIikgKyBcIlxcbiovXFxuICAgIFwiKSgpO1xuICB9XG59XG5mdW5jdGlvbiBwcmludERlcFRyZWUodHJlZSwgbGluZXMsIGRlcHRoKSB7XG4gIGlmIChsaW5lcy5sZW5ndGggPj0gMTAwMCkge1xuICAgIGxpbmVzLnB1c2goXCIoYW5kIG1hbnkgbW9yZSlcIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxpbmVzLnB1c2goXCJcIiArIFwiXFx0XCIucmVwZWF0KGRlcHRoIC0gMSkgKyB0cmVlLm5hbWUpO1xuICBpZiAodHJlZS5kZXBlbmRlbmNpZXMpIHtcbiAgICB0cmVlLmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIHByaW50RGVwVHJlZShjaGlsZCwgbGluZXMsIGRlcHRoICsgMSk7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIFJlYWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gbm9kZXMgd2UgYXJlIGxvb2tpbmcgYXQuIE91ciB2YWx1ZSBkZXBlbmRzIG9uIHRoZXNlIG5vZGVzXG5cbiAgZnVuY3Rpb24gUmVhY3Rpb24obmFtZV8sIG9uSW52YWxpZGF0ZV8sIGVycm9ySGFuZGxlcl8sIHJlcXVpcmVzT2JzZXJ2YWJsZV8pIHtcbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIlJlYWN0aW9uQFwiICsgZ2V0TmV4dElkKCkgOiBcIlJlYWN0aW9uXCI7XG4gICAgfVxuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5vbkludmFsaWRhdGVfID0gdm9pZCAwO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyXyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlcXVpcmVzT2JzZXJ2YWJsZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5vYnNlcnZpbmdfID0gW107XG4gICAgdGhpcy5uZXdPYnNlcnZpbmdfID0gW107XG4gICAgdGhpcy5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfO1xuICAgIHRoaXMuZGlmZlZhbHVlXyA9IDA7XG4gICAgdGhpcy5ydW5JZF8gPSAwO1xuICAgIHRoaXMudW5ib3VuZERlcHNDb3VudF8gPSAwO1xuICAgIHRoaXMuaXNEaXNwb3NlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmlzU2NoZWR1bGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNUcmFja1BlbmRpbmdfID0gZmFsc2U7XG4gICAgdGhpcy5pc1J1bm5pbmdfID0gZmFsc2U7XG4gICAgdGhpcy5pc1RyYWNpbmdfID0gVHJhY2VNb2RlLk5PTkU7XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgIHRoaXMub25JbnZhbGlkYXRlXyA9IG9uSW52YWxpZGF0ZV87XG4gICAgdGhpcy5lcnJvckhhbmRsZXJfID0gZXJyb3JIYW5kbGVyXztcbiAgICB0aGlzLnJlcXVpcmVzT2JzZXJ2YWJsZV8gPSByZXF1aXJlc09ic2VydmFibGVfO1xuICB9XG4gIHZhciBfcHJvdG8gPSBSZWFjdGlvbi5wcm90b3R5cGU7XG4gIF9wcm90by5vbkJlY29tZVN0YWxlXyA9IGZ1bmN0aW9uIG9uQmVjb21lU3RhbGVfKCkge1xuICAgIHRoaXMuc2NoZWR1bGVfKCk7XG4gIH07XG4gIF9wcm90by5zY2hlZHVsZV8gPSBmdW5jdGlvbiBzY2hlZHVsZV8oKSB7XG4gICAgaWYgKCF0aGlzLmlzU2NoZWR1bGVkXykge1xuICAgICAgdGhpcy5pc1NjaGVkdWxlZF8gPSB0cnVlO1xuICAgICAgZ2xvYmFsU3RhdGUucGVuZGluZ1JlYWN0aW9ucy5wdXNoKHRoaXMpO1xuICAgICAgcnVuUmVhY3Rpb25zKCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uaXNTY2hlZHVsZWQgPSBmdW5jdGlvbiBpc1NjaGVkdWxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NjaGVkdWxlZF87XG4gIH1cbiAgLyoqXHJcbiAgICogaW50ZXJuYWwsIHVzZSBzY2hlZHVsZSgpIGlmIHlvdSBpbnRlbmQgdG8ga2ljayBvZmYgYSByZWFjdGlvblxyXG4gICAqLztcbiAgX3Byb3RvLnJ1blJlYWN0aW9uXyA9IGZ1bmN0aW9uIHJ1blJlYWN0aW9uXygpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZF8pIHtcbiAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgIHRoaXMuaXNTY2hlZHVsZWRfID0gZmFsc2U7XG4gICAgICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dDtcbiAgICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHRoaXM7XG4gICAgICBpZiAoc2hvdWxkQ29tcHV0ZSh0aGlzKSkge1xuICAgICAgICB0aGlzLmlzVHJhY2tQZW5kaW5nXyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5vbkludmFsaWRhdGVfKCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmlzVHJhY2tQZW5kaW5nXyAmJiBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgLy8gb25JbnZhbGlkYXRlIGRpZG4ndCB0cmlnZ2VyIHRyYWNrIHJpZ2h0IGF3YXkuLlxuICAgICAgICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgICAgICAgdHlwZTogXCJzY2hlZHVsZWQtcmVhY3Rpb25cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5yZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSBwcmV2O1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by50cmFjayA9IGZ1bmN0aW9uIHRyYWNrKGZuKSB7XG4gICAgaWYgKHRoaXMuaXNEaXNwb3NlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICAgIC8vIGNvbnNvbGUud2FybihcIlJlYWN0aW9uIGFscmVhZHkgZGlzcG9zZWRcIikgLy8gTm90ZTogTm90IGEgd2FybmluZyAvIGVycm9yIGluIG1vYnggNCBlaXRoZXJcbiAgICB9XG5cbiAgICBzdGFydEJhdGNoKCk7XG4gICAgdmFyIG5vdGlmeSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBzdGFydFRpbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnkpIHtcbiAgICAgIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBzcHlSZXBvcnRTdGFydCh7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IFwicmVhY3Rpb25cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuaXNSdW5uaW5nXyA9IHRydWU7XG4gICAgdmFyIHByZXZSZWFjdGlvbiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dDsgLy8gcmVhY3Rpb25zIGNvdWxkIGNyZWF0ZSByZWFjdGlvbnMuLi5cbiAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSB0aGlzO1xuICAgIHZhciByZXN1bHQgPSB0cmFja0Rlcml2ZWRGdW5jdGlvbih0aGlzLCBmbiwgdW5kZWZpbmVkKTtcbiAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSBwcmV2UmVhY3Rpb247XG4gICAgdGhpcy5pc1J1bm5pbmdfID0gZmFsc2U7XG4gICAgdGhpcy5pc1RyYWNrUGVuZGluZ18gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkXykge1xuICAgICAgLy8gZGlzcG9zZWQgZHVyaW5nIGxhc3QgcnVuLiBDbGVhbiB1cCBldmVyeXRoaW5nIHRoYXQgd2FzIGJvdW5kIGFmdGVyIHRoZSBkaXNwb3NlIGNhbGwuXG4gICAgICBjbGVhck9ic2VydmluZyh0aGlzKTtcbiAgICB9XG4gICAgaWYgKGlzQ2F1Z2h0RXhjZXB0aW9uKHJlc3VsdCkpIHtcbiAgICAgIHRoaXMucmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uXyhyZXN1bHQuY2F1c2UpO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeSkge1xuICAgICAgc3B5UmVwb3J0RW5kKHtcbiAgICAgICAgdGltZTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGVuZEJhdGNoKCk7XG4gIH07XG4gIF9wcm90by5yZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fID0gZnVuY3Rpb24gcmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uXyhlcnJvcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuZXJyb3JIYW5kbGVyXykge1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXJfKGVycm9yLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB2YXIgbWVzc2FnZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiW21vYnhdIEVuY291bnRlcmVkIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbiB0aGF0IHdhcyB0aHJvd24gYnkgYSByZWFjdGlvbiBvciBvYnNlcnZlciBjb21wb25lbnQsIGluOiAnXCIgKyB0aGlzICsgXCInXCIgOiBcIlttb2J4XSB1bmNhdWdodCBlcnJvciBpbiAnXCIgKyB0aGlzICsgXCInXCI7XG4gICAgaWYgKCFnbG9iYWxTdGF0ZS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGVycm9yKTtcbiAgICAgIC8qKiBJZiBkZWJ1Z2dpbmcgYnJvdWdodCB5b3UgaGVyZSwgcGxlYXNlLCByZWFkIHRoZSBhYm92ZSBtZXNzYWdlIDotKS4gVG54ISAqL1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbbW9ieF0gKGVycm9yIGluIHJlYWN0aW9uICdcIiArIHRoaXMubmFtZV8gKyBcIicgc3VwcHJlc3NlZCwgZml4IGVycm9yIG9mIGNhdXNpbmcgYWN0aW9uIGJlbG93KVwiKTtcbiAgICB9IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgIHNweVJlcG9ydCh7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgZXJyb3I6IFwiXCIgKyBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICAgIGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4gZihlcnJvciwgX3RoaXMpO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWRfKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWRfID0gdHJ1ZTtcbiAgICAgIGlmICghdGhpcy5pc1J1bm5pbmdfKSB7XG4gICAgICAgIC8vIGlmIGRpc3Bvc2VkIHdoaWxlIHJ1bm5pbmcsIGNsZWFuIHVwIGxhdGVyLiBNYXliZSBub3Qgb3B0aW1hbCwgYnV0IHJhcmUgY2FzZVxuICAgICAgICBzdGFydEJhdGNoKCk7XG4gICAgICAgIGNsZWFyT2JzZXJ2aW5nKHRoaXMpO1xuICAgICAgICBlbmRCYXRjaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmdldERpc3Bvc2VyXyA9IGZ1bmN0aW9uIGdldERpc3Bvc2VyXygpIHtcbiAgICB2YXIgciA9IHRoaXMuZGlzcG9zZS5iaW5kKHRoaXMpO1xuICAgIHJbJG1vYnhdID0gdGhpcztcbiAgICByZXR1cm4gcjtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiUmVhY3Rpb25bXCIgKyB0aGlzLm5hbWVfICsgXCJdXCI7XG4gIH07XG4gIF9wcm90by50cmFjZSA9IGZ1bmN0aW9uIHRyYWNlJDEoZW50ZXJCcmVha1BvaW50KSB7XG4gICAgaWYgKGVudGVyQnJlYWtQb2ludCA9PT0gdm9pZCAwKSB7XG4gICAgICBlbnRlckJyZWFrUG9pbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgdHJhY2UodGhpcywgZW50ZXJCcmVha1BvaW50KTtcbiAgfTtcbiAgcmV0dXJuIFJlYWN0aW9uO1xufSgpO1xuZnVuY3Rpb24gb25SZWFjdGlvbkVycm9yKGhhbmRsZXIpIHtcbiAgZ2xvYmFsU3RhdGUuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkeCA9IGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgZ2xvYmFsU3RhdGUuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxyXG4gKiBNYWdpYyBudW1iZXIgYWxlcnQhXHJcbiAqIERlZmluZXMgd2l0aGluIGhvdyBtYW55IHRpbWVzIGEgcmVhY3Rpb24gaXMgYWxsb3dlZCB0byByZS10cmlnZ2VyIGl0c2VsZlxyXG4gKiB1bnRpbCBpdCBpcyBhc3N1bWVkIHRoYXQgdGhpcyBpcyBnb25uYSBiZSBhIG5ldmVyIGVuZGluZyBsb29wLi4uXHJcbiAqL1xudmFyIE1BWF9SRUFDVElPTl9JVEVSQVRJT05TID0gMTAwO1xudmFyIHJlYWN0aW9uU2NoZWR1bGVyID0gZnVuY3Rpb24gcmVhY3Rpb25TY2hlZHVsZXIoZikge1xuICByZXR1cm4gZigpO1xufTtcbmZ1bmN0aW9uIHJ1blJlYWN0aW9ucygpIHtcbiAgLy8gVHJhbXBvbGluaW5nLCBpZiBydW5SZWFjdGlvbnMgYXJlIGFscmVhZHkgcnVubmluZywgbmV3IHJlYWN0aW9ucyB3aWxsIGJlIHBpY2tlZCB1cFxuICBpZiAoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAgfHwgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlYWN0aW9uU2NoZWR1bGVyKHJ1blJlYWN0aW9uc0hlbHBlcik7XG59XG5mdW5jdGlvbiBydW5SZWFjdGlvbnNIZWxwZXIoKSB7XG4gIGdsb2JhbFN0YXRlLmlzUnVubmluZ1JlYWN0aW9ucyA9IHRydWU7XG4gIHZhciBhbGxSZWFjdGlvbnMgPSBnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIC8vIFdoaWxlIHJ1bm5pbmcgcmVhY3Rpb25zLCBuZXcgcmVhY3Rpb25zIG1pZ2h0IGJlIHRyaWdnZXJlZC5cbiAgLy8gSGVuY2Ugd2Ugd29yayB3aXRoIHR3byB2YXJpYWJsZXMgYW5kIGNoZWNrIHdoZXRoZXJcbiAgLy8gd2UgY29udmVyZ2UgdG8gbm8gcmVtYWluaW5nIHJlYWN0aW9ucyBhZnRlciBhIHdoaWxlLlxuICB3aGlsZSAoYWxsUmVhY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoKytpdGVyYXRpb25zID09PSBNQVhfUkVBQ1RJT05fSVRFUkFUSU9OUykge1xuICAgICAgY29uc29sZS5lcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIlJlYWN0aW9uIGRvZXNuJ3QgY29udmVyZ2UgdG8gYSBzdGFibGUgc3RhdGUgYWZ0ZXIgXCIgKyBNQVhfUkVBQ1RJT05fSVRFUkFUSU9OUyArIFwiIGl0ZXJhdGlvbnMuXCIgKyAoXCIgUHJvYmFibHkgdGhlcmUgaXMgYSBjeWNsZSBpbiB0aGUgcmVhY3RpdmUgZnVuY3Rpb246IFwiICsgYWxsUmVhY3Rpb25zWzBdKSA6IFwiW21vYnhdIGN5Y2xlIGluIHJlYWN0aW9uOiBcIiArIGFsbFJlYWN0aW9uc1swXSk7XG4gICAgICBhbGxSZWFjdGlvbnMuc3BsaWNlKDApOyAvLyBjbGVhciByZWFjdGlvbnNcbiAgICB9XG5cbiAgICB2YXIgcmVtYWluaW5nUmVhY3Rpb25zID0gYWxsUmVhY3Rpb25zLnNwbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlbWFpbmluZ1JlYWN0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlbWFpbmluZ1JlYWN0aW9uc1tpXS5ydW5SZWFjdGlvbl8oKTtcbiAgICB9XG4gIH1cbiAgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zID0gZmFsc2U7XG59XG52YXIgaXNSZWFjdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiUmVhY3Rpb25cIiwgUmVhY3Rpb24pO1xuZnVuY3Rpb24gc2V0UmVhY3Rpb25TY2hlZHVsZXIoZm4pIHtcbiAgdmFyIGJhc2VTY2hlZHVsZXIgPSByZWFjdGlvblNjaGVkdWxlcjtcbiAgcmVhY3Rpb25TY2hlZHVsZXIgPSBmdW5jdGlvbiByZWFjdGlvblNjaGVkdWxlcihmKSB7XG4gICAgcmV0dXJuIGZuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBiYXNlU2NoZWR1bGVyKGYpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc1NweUVuYWJsZWQoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgISFnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMubGVuZ3RoO1xufVxuZnVuY3Rpb24gc3B5UmVwb3J0KGV2ZW50KSB7XG4gIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gZGVhZCBjb2RlIGVsaW1pbmF0aW9uIGNhbiBkbyB0aGUgcmVzdFxuICBpZiAoIWdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGxpc3RlbmVycyA9IGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycztcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldKGV2ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gc3B5UmVwb3J0U3RhcnQoZXZlbnQpIHtcbiAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hhbmdlID0gX2V4dGVuZHMoe30sIGV2ZW50LCB7XG4gICAgc3B5UmVwb3J0U3RhcnQ6IHRydWVcbiAgfSk7XG4gIHNweVJlcG9ydChjaGFuZ2UpO1xufVxudmFyIEVORF9FVkVOVCA9IHtcbiAgdHlwZTogXCJyZXBvcnQtZW5kXCIsXG4gIHNweVJlcG9ydEVuZDogdHJ1ZVxufTtcbmZ1bmN0aW9uIHNweVJlcG9ydEVuZChjaGFuZ2UpIHtcbiAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY2hhbmdlKSB7XG4gICAgc3B5UmVwb3J0KF9leHRlbmRzKHt9LCBjaGFuZ2UsIHtcbiAgICAgIHR5cGU6IFwicmVwb3J0LWVuZFwiLFxuICAgICAgc3B5UmVwb3J0RW5kOiB0cnVlXG4gICAgfSkpO1xuICB9IGVsc2Uge1xuICAgIHNweVJlcG9ydChFTkRfRVZFTlQpO1xuICB9XG59XG5mdW5jdGlvbiBzcHkobGlzdGVuZXIpIHtcbiAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnNvbGUud2FybihcIlttb2J4LnNweV0gSXMgYSBuby1vcCBpbiBwcm9kdWN0aW9uIGJ1aWxkc1wiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybiBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycyA9IGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgcmV0dXJuIGwgIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIEFDVElPTiA9IFwiYWN0aW9uXCI7XG52YXIgQUNUSU9OX0JPVU5EID0gXCJhY3Rpb24uYm91bmRcIjtcbnZhciBBVVRPQUNUSU9OID0gXCJhdXRvQWN0aW9uXCI7XG52YXIgQVVUT0FDVElPTl9CT1VORCA9IFwiYXV0b0FjdGlvbi5ib3VuZFwiO1xudmFyIERFRkFVTFRfQUNUSU9OX05BTUUgPSBcIjx1bm5hbWVkIGFjdGlvbj5cIjtcbnZhciBhY3Rpb25Bbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQUNUSU9OKTtcbnZhciBhY3Rpb25Cb3VuZEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihBQ1RJT05fQk9VTkQsIHtcbiAgYm91bmQ6IHRydWVcbn0pO1xudmFyIGF1dG9BY3Rpb25Bbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQVVUT0FDVElPTiwge1xuICBhdXRvQWN0aW9uOiB0cnVlXG59KTtcbnZhciBhdXRvQWN0aW9uQm91bmRBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQVVUT0FDVElPTl9CT1VORCwge1xuICBhdXRvQWN0aW9uOiB0cnVlLFxuICBib3VuZDogdHJ1ZVxufSk7XG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25GYWN0b3J5KGF1dG9BY3Rpb24pIHtcbiAgdmFyIHJlcyA9IGZ1bmN0aW9uIGFjdGlvbihhcmcxLCBhcmcyKSB7XG4gICAgLy8gYWN0aW9uKGZuKCkge30pXG4gICAgaWYgKGlzRnVuY3Rpb24oYXJnMSkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVBY3Rpb24oYXJnMS5uYW1lIHx8IERFRkFVTFRfQUNUSU9OX05BTUUsIGFyZzEsIGF1dG9BY3Rpb24pO1xuICAgIH1cbiAgICAvLyBhY3Rpb24oXCJuYW1lXCIsIGZuKCkge30pXG4gICAgaWYgKGlzRnVuY3Rpb24oYXJnMikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVBY3Rpb24oYXJnMSwgYXJnMiwgYXV0b0FjdGlvbik7XG4gICAgfVxuICAgIC8vIEBhY3Rpb25cbiAgICBpZiAoaXNTdHJpbmdpc2goYXJnMikpIHtcbiAgICAgIHJldHVybiBzdG9yZUFubm90YXRpb24oYXJnMSwgYXJnMiwgYXV0b0FjdGlvbiA/IGF1dG9BY3Rpb25Bbm5vdGF0aW9uIDogYWN0aW9uQW5ub3RhdGlvbik7XG4gICAgfVxuICAgIC8vIGFjdGlvbihcIm5hbWVcIikgJiBAYWN0aW9uKFwibmFtZVwiKVxuICAgIGlmIChpc1N0cmluZ2lzaChhcmcxKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZURlY29yYXRvckFubm90YXRpb24oY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihhdXRvQWN0aW9uID8gQVVUT0FDVElPTiA6IEFDVElPTiwge1xuICAgICAgICBuYW1lOiBhcmcxLFxuICAgICAgICBhdXRvQWN0aW9uOiBhdXRvQWN0aW9uXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGRpZShcIkludmFsaWQgYXJndW1lbnRzIGZvciBgYWN0aW9uYFwiKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiByZXM7XG59XG52YXIgYWN0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkZhY3RvcnkoZmFsc2UpO1xuT2JqZWN0LmFzc2lnbihhY3Rpb24sIGFjdGlvbkFubm90YXRpb24pO1xudmFyIGF1dG9BY3Rpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uRmFjdG9yeSh0cnVlKTtcbk9iamVjdC5hc3NpZ24oYXV0b0FjdGlvbiwgYXV0b0FjdGlvbkFubm90YXRpb24pO1xuYWN0aW9uLmJvdW5kID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oYWN0aW9uQm91bmRBbm5vdGF0aW9uKTtcbmF1dG9BY3Rpb24uYm91bmQgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihhdXRvQWN0aW9uQm91bmRBbm5vdGF0aW9uKTtcbmZ1bmN0aW9uIHJ1bkluQWN0aW9uKGZuKSB7XG4gIHJldHVybiBleGVjdXRlQWN0aW9uKGZuLm5hbWUgfHwgREVGQVVMVF9BQ1RJT05fTkFNRSwgZmFsc2UsIGZuLCB0aGlzLCB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gaXNBY3Rpb24odGhpbmcpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odGhpbmcpICYmIHRoaW5nLmlzTW9ieEFjdGlvbiA9PT0gdHJ1ZTtcbn1cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuYW1lZCByZWFjdGl2ZSB2aWV3IGFuZCBrZWVwcyBpdCBhbGl2ZSwgc28gdGhhdCB0aGUgdmlldyBpcyBhbHdheXNcclxuICogdXBkYXRlZCBpZiBvbmUgb2YgdGhlIGRlcGVuZGVuY2llcyBjaGFuZ2VzLCBldmVuIHdoZW4gdGhlIHZpZXcgaXMgbm90IGZ1cnRoZXIgdXNlZCBieSBzb21ldGhpbmcgZWxzZS5cclxuICogQHBhcmFtIHZpZXcgVGhlIHJlYWN0aXZlIHZpZXdcclxuICogQHJldHVybnMgZGlzcG9zZXIgZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHN0b3AgdGhlIHZpZXcgZnJvbSBiZWluZyB1cGRhdGVkIGluIHRoZSBmdXR1cmUuXHJcbiAqL1xuZnVuY3Rpb24gYXV0b3J1bih2aWV3LCBvcHRzKSB7XG4gIHZhciBfb3B0cyRuYW1lLCBfb3B0cztcbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSBFTVBUWV9PQkpFQ1Q7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNGdW5jdGlvbih2aWV3KSkge1xuICAgICAgZGllKFwiQXV0b3J1biBleHBlY3RzIGEgZnVuY3Rpb24gYXMgZmlyc3QgYXJndW1lbnRcIik7XG4gICAgfVxuICAgIGlmIChpc0FjdGlvbih2aWV3KSkge1xuICAgICAgZGllKFwiQXV0b3J1biBkb2VzIG5vdCBhY2NlcHQgYWN0aW9ucyBzaW5jZSBhY3Rpb25zIGFyZSB1bnRyYWNrYWJsZVwiKTtcbiAgICB9XG4gIH1cbiAgdmFyIG5hbWUgPSAoX29wdHMkbmFtZSA9IChfb3B0cyA9IG9wdHMpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0cy5uYW1lKSAhPSBudWxsID8gX29wdHMkbmFtZSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHZpZXcubmFtZSB8fCBcIkF1dG9ydW5AXCIgKyBnZXROZXh0SWQoKSA6IFwiQXV0b3J1blwiO1xuICB2YXIgcnVuU3luYyA9ICFvcHRzLnNjaGVkdWxlciAmJiAhb3B0cy5kZWxheTtcbiAgdmFyIHJlYWN0aW9uO1xuICBpZiAocnVuU3luYykge1xuICAgIC8vIG5vcm1hbCBhdXRvcnVuXG4gICAgcmVhY3Rpb24gPSBuZXcgUmVhY3Rpb24obmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmFjayhyZWFjdGlvblJ1bm5lcik7XG4gICAgfSwgb3B0cy5vbkVycm9yLCBvcHRzLnJlcXVpcmVzT2JzZXJ2YWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNjaGVkdWxlciA9IGNyZWF0ZVNjaGVkdWxlckZyb21PcHRpb25zKG9wdHMpO1xuICAgIC8vIGRlYm91bmNlZCBhdXRvcnVuXG4gICAgdmFyIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgcmVhY3Rpb24gPSBuZXcgUmVhY3Rpb24obmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHNjaGVkdWxlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIXJlYWN0aW9uLmlzRGlzcG9zZWRfKSB7XG4gICAgICAgICAgICByZWFjdGlvbi50cmFjayhyZWFjdGlvblJ1bm5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBvcHRzLm9uRXJyb3IsIG9wdHMucmVxdWlyZXNPYnNlcnZhYmxlKTtcbiAgfVxuICBmdW5jdGlvbiByZWFjdGlvblJ1bm5lcigpIHtcbiAgICB2aWV3KHJlYWN0aW9uKTtcbiAgfVxuICByZWFjdGlvbi5zY2hlZHVsZV8oKTtcbiAgcmV0dXJuIHJlYWN0aW9uLmdldERpc3Bvc2VyXygpO1xufVxudmFyIHJ1biA9IGZ1bmN0aW9uIHJ1bihmKSB7XG4gIHJldHVybiBmKCk7XG59O1xuZnVuY3Rpb24gY3JlYXRlU2NoZWR1bGVyRnJvbU9wdGlvbnMob3B0cykge1xuICByZXR1cm4gb3B0cy5zY2hlZHVsZXIgPyBvcHRzLnNjaGVkdWxlciA6IG9wdHMuZGVsYXkgPyBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGYsIG9wdHMuZGVsYXkpO1xuICB9IDogcnVuO1xufVxuZnVuY3Rpb24gcmVhY3Rpb24oZXhwcmVzc2lvbiwgZWZmZWN0LCBvcHRzKSB7XG4gIHZhciBfb3B0cyRuYW1lMjtcbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSBFTVBUWV9PQkpFQ1Q7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNGdW5jdGlvbihleHByZXNzaW9uKSB8fCAhaXNGdW5jdGlvbihlZmZlY3QpKSB7XG4gICAgICBkaWUoXCJGaXJzdCBhbmQgc2Vjb25kIGFyZ3VtZW50IHRvIHJlYWN0aW9uIHNob3VsZCBiZSBmdW5jdGlvbnNcIik7XG4gICAgfVxuICAgIGlmICghaXNQbGFpbk9iamVjdChvcHRzKSkge1xuICAgICAgZGllKFwiVGhpcmQgYXJndW1lbnQgb2YgcmVhY3Rpb25zIHNob3VsZCBiZSBhbiBvYmplY3RcIik7XG4gICAgfVxuICB9XG4gIHZhciBuYW1lID0gKF9vcHRzJG5hbWUyID0gb3B0cy5uYW1lKSAhPSBudWxsID8gX29wdHMkbmFtZTIgOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIlJlYWN0aW9uQFwiICsgZ2V0TmV4dElkKCkgOiBcIlJlYWN0aW9uXCI7XG4gIHZhciBlZmZlY3RBY3Rpb24gPSBhY3Rpb24obmFtZSwgb3B0cy5vbkVycm9yID8gd3JhcEVycm9ySGFuZGxlcihvcHRzLm9uRXJyb3IsIGVmZmVjdCkgOiBlZmZlY3QpO1xuICB2YXIgcnVuU3luYyA9ICFvcHRzLnNjaGVkdWxlciAmJiAhb3B0cy5kZWxheTtcbiAgdmFyIHNjaGVkdWxlciA9IGNyZWF0ZVNjaGVkdWxlckZyb21PcHRpb25zKG9wdHMpO1xuICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcbiAgdmFyIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIG9sZFZhbHVlO1xuICB2YXIgZXF1YWxzID0gb3B0cy5jb21wYXJlU3RydWN0dXJhbCA/IGNvbXBhcmVyLnN0cnVjdHVyYWwgOiBvcHRzLmVxdWFscyB8fCBjb21wYXJlcltcImRlZmF1bHRcIl07XG4gIHZhciByID0gbmV3IFJlYWN0aW9uKG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZmlyc3RUaW1lIHx8IHJ1blN5bmMpIHtcbiAgICAgIHJlYWN0aW9uUnVubmVyKCk7XG4gICAgfSBlbHNlIGlmICghaXNTY2hlZHVsZWQpIHtcbiAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNjaGVkdWxlcihyZWFjdGlvblJ1bm5lcik7XG4gICAgfVxuICB9LCBvcHRzLm9uRXJyb3IsIG9wdHMucmVxdWlyZXNPYnNlcnZhYmxlKTtcbiAgZnVuY3Rpb24gcmVhY3Rpb25SdW5uZXIoKSB7XG4gICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBpZiAoci5pc0Rpc3Bvc2VkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHIudHJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5leHRWYWx1ZSA9IGFsbG93U3RhdGVDaGFuZ2VzKGZhbHNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uKHIpO1xuICAgICAgfSk7XG4gICAgICBjaGFuZ2VkID0gZmlyc3RUaW1lIHx8ICFlcXVhbHModmFsdWUsIG5leHRWYWx1ZSk7XG4gICAgICBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgICAgdmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKGZpcnN0VGltZSAmJiBvcHRzLmZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgZWZmZWN0QWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSwgcik7XG4gICAgfSBlbHNlIGlmICghZmlyc3RUaW1lICYmIGNoYW5nZWQpIHtcbiAgICAgIGVmZmVjdEFjdGlvbih2YWx1ZSwgb2xkVmFsdWUsIHIpO1xuICAgIH1cbiAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgfVxuICByLnNjaGVkdWxlXygpO1xuICByZXR1cm4gci5nZXREaXNwb3Nlcl8oKTtcbn1cbmZ1bmN0aW9uIHdyYXBFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyLCBiYXNlRm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJhc2VGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9ySGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIE9OX0JFQ09NRV9PQlNFUlZFRCA9IFwib25CT1wiO1xudmFyIE9OX0JFQ09NRV9VTk9CU0VSVkVEID0gXCJvbkJVT1wiO1xuZnVuY3Rpb24gb25CZWNvbWVPYnNlcnZlZCh0aGluZywgYXJnMiwgYXJnMykge1xuICByZXR1cm4gaW50ZXJjZXB0SG9vayhPTl9CRUNPTUVfT0JTRVJWRUQsIHRoaW5nLCBhcmcyLCBhcmczKTtcbn1cbmZ1bmN0aW9uIG9uQmVjb21lVW5vYnNlcnZlZCh0aGluZywgYXJnMiwgYXJnMykge1xuICByZXR1cm4gaW50ZXJjZXB0SG9vayhPTl9CRUNPTUVfVU5PQlNFUlZFRCwgdGhpbmcsIGFyZzIsIGFyZzMpO1xufVxuZnVuY3Rpb24gaW50ZXJjZXB0SG9vayhob29rLCB0aGluZywgYXJnMiwgYXJnMykge1xuICB2YXIgYXRvbSA9IHR5cGVvZiBhcmczID09PSBcImZ1bmN0aW9uXCIgPyBnZXRBdG9tKHRoaW5nLCBhcmcyKSA6IGdldEF0b20odGhpbmcpO1xuICB2YXIgY2IgPSBpc0Z1bmN0aW9uKGFyZzMpID8gYXJnMyA6IGFyZzI7XG4gIHZhciBsaXN0ZW5lcnNLZXkgPSBob29rICsgXCJMXCI7XG4gIGlmIChhdG9tW2xpc3RlbmVyc0tleV0pIHtcbiAgICBhdG9tW2xpc3RlbmVyc0tleV0uYWRkKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBhdG9tW2xpc3RlbmVyc0tleV0gPSBuZXcgU2V0KFtjYl0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvb2tMaXN0ZW5lcnMgPSBhdG9tW2xpc3RlbmVyc0tleV07XG4gICAgaWYgKGhvb2tMaXN0ZW5lcnMpIHtcbiAgICAgIGhvb2tMaXN0ZW5lcnNbXCJkZWxldGVcIl0oY2IpO1xuICAgICAgaWYgKGhvb2tMaXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgYXRvbVtsaXN0ZW5lcnNLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIE5FVkVSID0gXCJuZXZlclwiO1xudmFyIEFMV0FZUyA9IFwiYWx3YXlzXCI7XG52YXIgT0JTRVJWRUQgPSBcIm9ic2VydmVkXCI7XG4vLyBjb25zdCBJRl9BVkFJTEFCTEUgPSBcImlmYXZhaWxhYmxlXCJcbmZ1bmN0aW9uIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmlzb2xhdGVHbG9iYWxTdGF0ZSA9PT0gdHJ1ZSkge1xuICAgIGlzb2xhdGVHbG9iYWxTdGF0ZSgpO1xuICB9XG4gIHZhciB1c2VQcm94aWVzID0gb3B0aW9ucy51c2VQcm94aWVzLFxuICAgIGVuZm9yY2VBY3Rpb25zID0gb3B0aW9ucy5lbmZvcmNlQWN0aW9ucztcbiAgaWYgKHVzZVByb3hpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGdsb2JhbFN0YXRlLnVzZVByb3hpZXMgPSB1c2VQcm94aWVzID09PSBBTFdBWVMgPyB0cnVlIDogdXNlUHJveGllcyA9PT0gTkVWRVIgPyBmYWxzZSA6IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgfVxuICBpZiAodXNlUHJveGllcyA9PT0gXCJpZmF2YWlsYWJsZVwiKSB7XG4gICAgZ2xvYmFsU3RhdGUudmVyaWZ5UHJveGllcyA9IHRydWU7XG4gIH1cbiAgaWYgKGVuZm9yY2VBY3Rpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZWEgPSBlbmZvcmNlQWN0aW9ucyA9PT0gQUxXQVlTID8gQUxXQVlTIDogZW5mb3JjZUFjdGlvbnMgPT09IE9CU0VSVkVEO1xuICAgIGdsb2JhbFN0YXRlLmVuZm9yY2VBY3Rpb25zID0gZWE7XG4gICAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSBlYSA9PT0gdHJ1ZSB8fCBlYSA9PT0gQUxXQVlTID8gZmFsc2UgOiB0cnVlO1xuICB9XG4gIFtcImNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvblwiLCBcInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlXCIsIFwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb25cIiwgXCJkaXNhYmxlRXJyb3JCb3VuZGFyaWVzXCIsIFwic2FmZURlc2NyaXB0b3JzXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgZ2xvYmFsU3RhdGVba2V5XSA9ICEhb3B0aW9uc1trZXldO1xuICAgIH1cbiAgfSk7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyA9ICFnbG9iYWxTdGF0ZS5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbjtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzID09PSB0cnVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiV0FSTklORzogRGVidWcgZmVhdHVyZSBvbmx5LiBNb2JYIHdpbGwgTk9UIHJlY292ZXIgZnJvbSBlcnJvcnMgd2hlbiBgZGlzYWJsZUVycm9yQm91bmRhcmllc2AgaXMgZW5hYmxlZC5cIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVhY3Rpb25TY2hlZHVsZXIpIHtcbiAgICBzZXRSZWFjdGlvblNjaGVkdWxlcihvcHRpb25zLnJlYWN0aW9uU2NoZWR1bGVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRlbmRPYnNlcnZhYmxlKHRhcmdldCwgcHJvcGVydGllcywgYW5ub3RhdGlvbnMsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gNCkge1xuICAgICAgZGllKFwiJ2V4dGVuZE9ic2VydmFibGUnIGV4cGVjdGVkIDItNCBhcmd1bWVudHNcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBkaWUoXCInZXh0ZW5kT2JzZXJ2YWJsZScgZXhwZWN0cyBhbiBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnRcIik7XG4gICAgfVxuICAgIGlmIChpc09ic2VydmFibGVNYXAodGFyZ2V0KSkge1xuICAgICAgZGllKFwiJ2V4dGVuZE9ic2VydmFibGUnIHNob3VsZCBub3QgYmUgdXNlZCBvbiBtYXBzLCB1c2UgbWFwLm1lcmdlIGluc3RlYWRcIik7XG4gICAgfVxuICAgIGlmICghaXNQbGFpbk9iamVjdChwcm9wZXJ0aWVzKSkge1xuICAgICAgZGllKFwiJ2V4dGVuZE9ic2VydmFibGUnIG9ubHkgYWNjZXB0cyBwbGFpbiBvYmplY3RzIGFzIHNlY29uZCBhcmd1bWVudFwiKTtcbiAgICB9XG4gICAgaWYgKGlzT2JzZXJ2YWJsZShwcm9wZXJ0aWVzKSB8fCBpc09ic2VydmFibGUoYW5ub3RhdGlvbnMpKSB7XG4gICAgICBkaWUoXCJFeHRlbmRpbmcgYW4gb2JqZWN0IHdpdGggYW5vdGhlciBvYnNlcnZhYmxlIChvYmplY3QpIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICB9XG4gIC8vIFB1bGwgZGVzY3JpcHRvcnMgZmlyc3QsIHNvIHdlIGRvbid0IGhhdmUgdG8gZGVhbCB3aXRoIHByb3BzIGFkZGVkIGJ5IGFkbWluaXN0cmF0aW9uICgkbW9ieClcbiAgdmFyIGRlc2NyaXB0b3JzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhwcm9wZXJ0aWVzKTtcbiAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpWyRtb2J4XTtcbiAgc3RhcnRCYXRjaCgpO1xuICB0cnkge1xuICAgIG93bktleXMoZGVzY3JpcHRvcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgYWRtLmV4dGVuZF8oa2V5LCBkZXNjcmlwdG9yc1trZXldLFxuICAgICAgLy8gbXVzdCBwYXNzIFwidW5kZWZpbmVkXCIgZm9yIHsga2V5OiB1bmRlZmluZWQgfVxuICAgICAgIWFubm90YXRpb25zID8gdHJ1ZSA6IGtleSBpbiBhbm5vdGF0aW9ucyA/IGFubm90YXRpb25zW2tleV0gOiB0cnVlKTtcbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBlbmRCYXRjaCgpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGdldERlcGVuZGVuY3lUcmVlKHRoaW5nLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gbm9kZVRvRGVwZW5kZW5jeVRyZWUoZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpKTtcbn1cbmZ1bmN0aW9uIG5vZGVUb0RlcGVuZGVuY3lUcmVlKG5vZGUpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBuYW1lOiBub2RlLm5hbWVfXG4gIH07XG4gIGlmIChub2RlLm9ic2VydmluZ18gJiYgbm9kZS5vYnNlcnZpbmdfLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQuZGVwZW5kZW5jaWVzID0gdW5pcXVlKG5vZGUub2JzZXJ2aW5nXykubWFwKG5vZGVUb0RlcGVuZGVuY3lUcmVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJUcmVlKHRoaW5nLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gbm9kZVRvT2JzZXJ2ZXJUcmVlKGdldEF0b20odGhpbmcsIHByb3BlcnR5KSk7XG59XG5mdW5jdGlvbiBub2RlVG9PYnNlcnZlclRyZWUobm9kZSkge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIG5hbWU6IG5vZGUubmFtZV9cbiAgfTtcbiAgaWYgKGhhc09ic2VydmVycyhub2RlKSkge1xuICAgIHJlc3VsdC5vYnNlcnZlcnMgPSBBcnJheS5mcm9tKGdldE9ic2VydmVycyhub2RlKSkubWFwKG5vZGVUb09ic2VydmVyVHJlZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVuaXF1ZShsaXN0KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQobGlzdCkpO1xufVxuXG52YXIgZ2VuZXJhdG9ySWQgPSAwO1xuZnVuY3Rpb24gRmxvd0NhbmNlbGxhdGlvbkVycm9yKCkge1xuICB0aGlzLm1lc3NhZ2UgPSBcIkZMT1dfQ0FOQ0VMTEVEXCI7XG59XG5GbG93Q2FuY2VsbGF0aW9uRXJyb3IucHJvdG90eXBlID0gLyojX19QVVJFX18qL09iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbmZ1bmN0aW9uIGlzRmxvd0NhbmNlbGxhdGlvbkVycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEZsb3dDYW5jZWxsYXRpb25FcnJvcjtcbn1cbnZhciBmbG93QW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVGbG93QW5ub3RhdGlvbihcImZsb3dcIik7XG52YXIgZmxvd0JvdW5kQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVGbG93QW5ub3RhdGlvbihcImZsb3cuYm91bmRcIiwge1xuICBib3VuZDogdHJ1ZVxufSk7XG52YXIgZmxvdyA9IC8qI19fUFVSRV9fKi9PYmplY3QuYXNzaWduKGZ1bmN0aW9uIGZsb3coYXJnMSwgYXJnMikge1xuICAvLyBAZmxvd1xuICBpZiAoaXNTdHJpbmdpc2goYXJnMikpIHtcbiAgICByZXR1cm4gc3RvcmVBbm5vdGF0aW9uKGFyZzEsIGFyZzIsIGZsb3dBbm5vdGF0aW9uKTtcbiAgfVxuICAvLyBmbG93KGZuKVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICBkaWUoXCJGbG93IGV4cGVjdHMgc2luZ2xlIGFyZ3VtZW50IHdpdGggZ2VuZXJhdG9yIGZ1bmN0aW9uXCIpO1xuICB9XG4gIHZhciBnZW5lcmF0b3IgPSBhcmcxO1xuICB2YXIgbmFtZSA9IGdlbmVyYXRvci5uYW1lIHx8IFwiPHVubmFtZWQgZmxvdz5cIjtcbiAgLy8gSW1wbGVtZW50YXRpb24gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3RqL2NvL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gIHZhciByZXMgPSBmdW5jdGlvbiByZXMoKSB7XG4gICAgdmFyIGN0eCA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHJ1bklkID0gKytnZW5lcmF0b3JJZDtcbiAgICB2YXIgZ2VuID0gYWN0aW9uKG5hbWUgKyBcIiAtIHJ1bmlkOiBcIiArIHJ1bklkICsgXCIgLSBpbml0XCIsIGdlbmVyYXRvcikuYXBwbHkoY3R4LCBhcmdzKTtcbiAgICB2YXIgcmVqZWN0b3I7XG4gICAgdmFyIHBlbmRpbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHN0ZXBJZCA9IDA7XG4gICAgICByZWplY3RvciA9IHJlamVjdDtcbiAgICAgIGZ1bmN0aW9uIG9uRnVsZmlsbGVkKHJlcykge1xuICAgICAgICBwZW5kaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXQgPSBhY3Rpb24obmFtZSArIFwiIC0gcnVuaWQ6IFwiICsgcnVuSWQgKyBcIiAtIHlpZWxkIFwiICsgc3RlcElkKyssIGdlbi5uZXh0KS5jYWxsKGdlbiwgcmVzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dChyZXQpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25SZWplY3RlZChlcnIpIHtcbiAgICAgICAgcGVuZGluZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0ID0gYWN0aW9uKG5hbWUgKyBcIiAtIHJ1bmlkOiBcIiArIHJ1bklkICsgXCIgLSB5aWVsZCBcIiArIHN0ZXBJZCsrLCBnZW5bXCJ0aHJvd1wiXSkuY2FsbChnZW4sIGVycik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQocmV0KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG5leHQocmV0KSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHJldCA9PSBudWxsID8gdm9pZCAwIDogcmV0LnRoZW4pKSB7XG4gICAgICAgICAgLy8gYW4gYXN5bmMgaXRlcmF0b3JcbiAgICAgICAgICByZXQudGhlbihuZXh0LCByZWplY3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0LmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHJldC52YWx1ZSk7XG4gICAgICAgIHJldHVybiBwZW5kaW5nUHJvbWlzZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgIH1cbiAgICAgIG9uRnVsZmlsbGVkKHVuZGVmaW5lZCk7IC8vIGtpY2sgb2ZmIHRoZSBwcm9jZXNzXG4gICAgfSk7XG5cbiAgICBwcm9taXNlLmNhbmNlbCA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0gY2FuY2VsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwZW5kaW5nUHJvbWlzZSkge1xuICAgICAgICAgIGNhbmNlbFByb21pc2UocGVuZGluZ1Byb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmFsbHkgYmxvY2sgY2FuIHJldHVybiAob3IgeWllbGQpIHN0dWZmLi5cbiAgICAgICAgdmFyIF9yZXMgPSBnZW5bXCJyZXR1cm5cIl0odW5kZWZpbmVkKTtcbiAgICAgICAgLy8gZWF0IGFueXRoaW5nIHRoYXQgcHJvbWlzZSB3b3VsZCBkbywgaXQncyBjYW5jZWxsZWQhXG4gICAgICAgIHZhciB5aWVsZGVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShfcmVzLnZhbHVlKTtcbiAgICAgICAgeWllbGRlZFByb21pc2UudGhlbihub29wLCBub29wKTtcbiAgICAgICAgY2FuY2VsUHJvbWlzZSh5aWVsZGVkUHJvbWlzZSk7IC8vIG1heWJlIGl0IGNhbiBiZSBjYW5jZWxsZWQgOilcbiAgICAgICAgLy8gcmVqZWN0IG91ciBvcmlnaW5hbCBwcm9taXNlXG4gICAgICAgIHJlamVjdG9yKG5ldyBGbG93Q2FuY2VsbGF0aW9uRXJyb3IoKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdG9yKGUpOyAvLyB0aGVyZSBjb3VsZCBiZSBhIHRocm93aW5nIGZpbmFsbHkgYmxvY2tcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuICByZXMuaXNNb2JYRmxvdyA9IHRydWU7XG4gIHJldHVybiByZXM7XG59LCBmbG93QW5ub3RhdGlvbik7XG5mbG93LmJvdW5kID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oZmxvd0JvdW5kQW5ub3RhdGlvbik7XG5mdW5jdGlvbiBjYW5jZWxQcm9taXNlKHByb21pc2UpIHtcbiAgaWYgKGlzRnVuY3Rpb24ocHJvbWlzZS5jYW5jZWwpKSB7XG4gICAgcHJvbWlzZS5jYW5jZWwoKTtcbiAgfVxufVxuZnVuY3Rpb24gZmxvd1Jlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdDsgLy8ganVzdCB0cmlja2luZyBUeXBlU2NyaXB0IDopXG59XG5cbmZ1bmN0aW9uIGlzRmxvdyhmbikge1xuICByZXR1cm4gKGZuID09IG51bGwgPyB2b2lkIDAgOiBmbi5pc01vYlhGbG93KSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0UmVhZHModGhpbmcsIHByb3BPckhhbmRsZXIsIGhhbmRsZXIpIHtcbiAgdmFyIHRhcmdldDtcbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0aGluZykgfHwgaXNPYnNlcnZhYmxlQXJyYXkodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZVZhbHVlKHRoaW5nKSkge1xuICAgIHRhcmdldCA9IGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVPYmplY3QodGhpbmcpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNTdHJpbmdpc2gocHJvcE9ySGFuZGxlcikpIHtcbiAgICAgIHJldHVybiBkaWUoXCJJbnRlcmNlcHRSZWFkcyBjYW4gb25seSBiZSB1c2VkIHdpdGggYSBzcGVjaWZpYyBwcm9wZXJ0eSwgbm90IHdpdGggYW4gb2JqZWN0IGluIGdlbmVyYWxcIik7XG4gICAgfVxuICAgIHRhcmdldCA9IGdldEFkbWluaXN0cmF0aW9uKHRoaW5nLCBwcm9wT3JIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gZGllKFwiRXhwZWN0ZWQgb2JzZXJ2YWJsZSBtYXAsIG9iamVjdCBvciBhcnJheSBhcyBmaXJzdCBhcnJheVwiKTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRhcmdldC5kZWhhbmNlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGRpZShcIkFuIGludGVyY2VwdCByZWFkZXIgd2FzIGFscmVhZHkgZXN0YWJsaXNoZWRcIik7XG4gIH1cbiAgdGFyZ2V0LmRlaGFuY2VyID0gdHlwZW9mIHByb3BPckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiA/IHByb3BPckhhbmRsZXIgOiBoYW5kbGVyO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRhcmdldC5kZWhhbmNlciA9IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0KHRoaW5nLCBwcm9wT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIGludGVyY2VwdFByb3BlcnR5KHRoaW5nLCBwcm9wT3JIYW5kbGVyLCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW50ZXJjZXB0SW50ZXJjZXB0YWJsZSh0aGluZywgcHJvcE9ySGFuZGxlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVyY2VwdEludGVyY2VwdGFibGUodGhpbmcsIGhhbmRsZXIpIHtcbiAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKS5pbnRlcmNlcHRfKGhhbmRsZXIpO1xufVxuZnVuY3Rpb24gaW50ZXJjZXB0UHJvcGVydHkodGhpbmcsIHByb3BlcnR5LCBoYW5kbGVyKSB7XG4gIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcGVydHkpLmludGVyY2VwdF8oaGFuZGxlcik7XG59XG5cbmZ1bmN0aW9uIF9pc0NvbXB1dGVkKHZhbHVlLCBwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBpc0NvbXB1dGVkVmFsdWUodmFsdWUpO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVPYmplY3QodmFsdWUpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIXZhbHVlWyRtb2J4XS52YWx1ZXNfLmhhcyhwcm9wZXJ0eSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGF0b20gPSBnZXRBdG9tKHZhbHVlLCBwcm9wZXJ0eSk7XG4gIHJldHVybiBpc0NvbXB1dGVkVmFsdWUoYXRvbSk7XG59XG5mdW5jdGlvbiBpc0NvbXB1dGVkKHZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gZGllKFwiaXNDb21wdXRlZCBleHBlY3RzIG9ubHkgMSBhcmd1bWVudC4gVXNlIGlzQ29tcHV0ZWRQcm9wIHRvIGluc3BlY3QgdGhlIG9ic2VydmFiaWxpdHkgb2YgYSBwcm9wZXJ0eVwiKTtcbiAgfVxuICByZXR1cm4gX2lzQ29tcHV0ZWQodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNDb21wdXRlZFByb3AodmFsdWUsIHByb3BOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzU3RyaW5naXNoKHByb3BOYW1lKSkge1xuICAgIHJldHVybiBkaWUoXCJpc0NvbXB1dGVkIGV4cGVjdGVkIGEgcHJvcGVydHkgbmFtZSBhcyBzZWNvbmQgYXJndW1lbnRcIik7XG4gIH1cbiAgcmV0dXJuIF9pc0NvbXB1dGVkKHZhbHVlLCBwcm9wTmFtZSk7XG59XG5cbmZ1bmN0aW9uIF9pc09ic2VydmFibGUodmFsdWUsIHByb3BlcnR5KSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChpc09ic2VydmFibGVNYXAodmFsdWUpIHx8IGlzT2JzZXJ2YWJsZUFycmF5KHZhbHVlKSkpIHtcbiAgICAgIHJldHVybiBkaWUoXCJpc09ic2VydmFibGUob2JqZWN0LCBwcm9wZXJ0eU5hbWUpIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGFycmF5cyBhbmQgbWFwcy4gVXNlIG1hcC5oYXMgb3IgYXJyYXkubGVuZ3RoIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlWyRtb2J4XS52YWx1ZXNfLmhhcyhwcm9wZXJ0eSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBGb3IgZmlyc3QgY2hlY2ssIHNlZSAjNzAxXG4gIHJldHVybiBpc09ic2VydmFibGVPYmplY3QodmFsdWUpIHx8ICEhdmFsdWVbJG1vYnhdIHx8IGlzQXRvbSh2YWx1ZSkgfHwgaXNSZWFjdGlvbih2YWx1ZSkgfHwgaXNDb21wdXRlZFZhbHVlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZSh2YWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICBkaWUoXCJpc09ic2VydmFibGUgZXhwZWN0cyBvbmx5IDEgYXJndW1lbnQuIFVzZSBpc09ic2VydmFibGVQcm9wIHRvIGluc3BlY3QgdGhlIG9ic2VydmFiaWxpdHkgb2YgYSBwcm9wZXJ0eVwiKTtcbiAgfVxuICByZXR1cm4gX2lzT2JzZXJ2YWJsZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc09ic2VydmFibGVQcm9wKHZhbHVlLCBwcm9wTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc1N0cmluZ2lzaChwcm9wTmFtZSkpIHtcbiAgICByZXR1cm4gZGllKFwiZXhwZWN0ZWQgYSBwcm9wZXJ0eSBuYW1lIGFzIHNlY29uZCBhcmd1bWVudFwiKTtcbiAgfVxuICByZXR1cm4gX2lzT2JzZXJ2YWJsZSh2YWx1ZSwgcHJvcE5hbWUpO1xufVxuXG5mdW5jdGlvbiBrZXlzKG9iaikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5rZXlzXygpO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVNYXAob2JqKSB8fCBpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKG9iai5rZXlzKCkpO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSk7XG4gIH1cbiAgZGllKDUpO1xufVxuZnVuY3Rpb24gdmFsdWVzKG9iaikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgcmV0dXJuIGtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG9iai5nZXQoa2V5KTtcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShvYmoudmFsdWVzKCkpO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9XG4gIGRpZSg2KTtcbn1cbmZ1bmN0aW9uIGVudHJpZXMob2JqKSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBrZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBvYmpba2V5XV07XG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgcmV0dXJuIGtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9iai5nZXQoa2V5KV07XG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ob2JqLmVudHJpZXMoKSk7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLm1hcChmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuICAgICAgcmV0dXJuIFtpbmRleCwga2V5XTtcbiAgICB9KTtcbiAgfVxuICBkaWUoNyk7XG59XG5mdW5jdGlvbiBzZXQob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICFpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIHN0YXJ0QmF0Y2goKTtcbiAgICB2YXIgX3ZhbHVlcyA9IGtleTtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2tleSBpbiBfdmFsdWVzKSB7XG4gICAgICAgIHNldChvYmosIF9rZXksIF92YWx1ZXNbX2tleV0pO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgb2JqWyRtb2J4XS5zZXRfKGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgb2JqLnNldChrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIG9iai5hZGQoa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGtleSA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgIH1cbiAgICBpZiAoa2V5IDwgMCkge1xuICAgICAgZGllKFwiSW52YWxpZCBpbmRleDogJ1wiICsga2V5ICsgXCInXCIpO1xuICAgIH1cbiAgICBzdGFydEJhdGNoKCk7XG4gICAgaWYgKGtleSA+PSBvYmoubGVuZ3RoKSB7XG4gICAgICBvYmoubGVuZ3RoID0ga2V5ICsgMTtcbiAgICB9XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICBlbmRCYXRjaCgpO1xuICB9IGVsc2Uge1xuICAgIGRpZSg4KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlKG9iaiwga2V5KSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIG9ialskbW9ieF0uZGVsZXRlXyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgb2JqW1wiZGVsZXRlXCJdKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICBvYmpbXCJkZWxldGVcIl0oa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGtleSA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgIH1cbiAgICBvYmouc3BsaWNlKGtleSwgMSk7XG4gIH0gZWxzZSB7XG4gICAgZGllKDkpO1xuICB9XG59XG5mdW5jdGlvbiBoYXMob2JqLCBrZXkpIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0uaGFzXyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgcmV0dXJuIG9iai5oYXMoa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIHJldHVybiBvYmouaGFzKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBrZXkgPj0gMCAmJiBrZXkgPCBvYmoubGVuZ3RoO1xuICB9XG4gIGRpZSgxMCk7XG59XG5mdW5jdGlvbiBnZXQob2JqLCBrZXkpIHtcbiAgaWYgKCFoYXMob2JqLCBrZXkpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5nZXRfKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmdldChrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgZGllKDExKTtcbn1cbmZ1bmN0aW9uIGFwaURlZmluZVByb3BlcnR5KG9iaiwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmpbJG1vYnhdLmRlZmluZVByb3BlcnR5XyhrZXksIGRlc2NyaXB0b3IpO1xuICB9XG4gIGRpZSgzOSk7XG59XG5mdW5jdGlvbiBhcGlPd25LZXlzKG9iaikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5vd25LZXlzXygpO1xuICB9XG4gIGRpZSgzOCk7XG59XG5cbmZ1bmN0aW9uIG9ic2VydmUodGhpbmcsIHByb3BPckNiLCBjYk9yRmlyZSwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gIGlmIChpc0Z1bmN0aW9uKGNiT3JGaXJlKSkge1xuICAgIHJldHVybiBvYnNlcnZlT2JzZXJ2YWJsZVByb3BlcnR5KHRoaW5nLCBwcm9wT3JDYiwgY2JPckZpcmUsIGZpcmVJbW1lZGlhdGVseSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9ic2VydmVPYnNlcnZhYmxlKHRoaW5nLCBwcm9wT3JDYiwgY2JPckZpcmUpO1xuICB9XG59XG5mdW5jdGlvbiBvYnNlcnZlT2JzZXJ2YWJsZSh0aGluZywgbGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcpLm9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpO1xufVxuZnVuY3Rpb24gb2JzZXJ2ZU9ic2VydmFibGVQcm9wZXJ0eSh0aGluZywgcHJvcGVydHksIGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nLCBwcm9wZXJ0eSkub2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSk7XG59XG5cbmZ1bmN0aW9uIGNhY2hlKG1hcCwga2V5LCB2YWx1ZSkge1xuICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB0b0pTSGVscGVyKHNvdXJjZSwgX19hbHJlYWR5U2Vlbikge1xuICBpZiAoc291cmNlID09IG51bGwgfHwgdHlwZW9mIHNvdXJjZSAhPT0gXCJvYmplY3RcIiB8fCBzb3VyY2UgaW5zdGFuY2VvZiBEYXRlIHx8ICFpc09ic2VydmFibGUoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZVZhbHVlKHNvdXJjZSkgfHwgaXNDb21wdXRlZFZhbHVlKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gdG9KU0hlbHBlcihzb3VyY2UuZ2V0KCksIF9fYWxyZWFkeVNlZW4pO1xuICB9XG4gIGlmIChfX2FscmVhZHlTZWVuLmhhcyhzb3VyY2UpKSB7XG4gICAgcmV0dXJuIF9fYWxyZWFkeVNlZW4uZ2V0KHNvdXJjZSk7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KHNvdXJjZSkpIHtcbiAgICB2YXIgcmVzID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCkpO1xuICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICByZXNbaWR4XSA9IHRvSlNIZWxwZXIodmFsdWUsIF9fYWxyZWFkeVNlZW4pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZVNldChzb3VyY2UpKSB7XG4gICAgdmFyIF9yZXMgPSBjYWNoZShfX2FscmVhZHlTZWVuLCBzb3VyY2UsIG5ldyBTZXQoKSk7XG4gICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBfcmVzLmFkZCh0b0pTSGVscGVyKHZhbHVlLCBfX2FscmVhZHlTZWVuKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF9yZXM7XG4gIH1cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcChzb3VyY2UpKSB7XG4gICAgdmFyIF9yZXMyID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCBuZXcgTWFwKCkpO1xuICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBfcmVzMi5zZXQoa2V5LCB0b0pTSGVscGVyKHZhbHVlLCBfX2FscmVhZHlTZWVuKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF9yZXMyO1xuICB9IGVsc2Uge1xuICAgIC8vIG11c3QgYmUgb2JzZXJ2YWJsZSBvYmplY3RcbiAgICB2YXIgX3JlczMgPSBjYWNoZShfX2FscmVhZHlTZWVuLCBzb3VyY2UsIHt9KTtcbiAgICBhcGlPd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAob2JqZWN0UHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIF9yZXMzW2tleV0gPSB0b0pTSGVscGVyKHNvdXJjZVtrZXldLCBfX2FscmVhZHlTZWVuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3JlczM7XG4gIH1cbn1cbi8qKlxyXG4gKiBSZWN1cnNpdmVseSBjb252ZXJ0cyBhbiBvYnNlcnZhYmxlIHRvIGl0J3Mgbm9uLW9ic2VydmFibGUgbmF0aXZlIGNvdW50ZXJwYXJ0LlxyXG4gKiBJdCBkb2VzIE5PVCByZWN1cnNlIGludG8gbm9uLW9ic2VydmFibGVzLCB0aGVzZSBhcmUgbGVmdCBhcyB0aGV5IGFyZSwgZXZlbiBpZiB0aGV5IGNvbnRhaW4gb2JzZXJ2YWJsZXMuXHJcbiAqIENvbXB1dGVkIGFuZCBvdGhlciBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBjb21wbGV0ZWx5IGlnbm9yZWQuXHJcbiAqIENvbXBsZXggc2NlbmFyaW9zIHJlcXVpcmUgY3VzdG9tIHNvbHV0aW9uLCBlZyBpbXBsZW1lbnRpbmcgYHRvSlNPTmAgb3IgdXNpbmcgYHNlcmlhbGl6cmAgbGliLlxyXG4gKi9cbmZ1bmN0aW9uIHRvSlMoc291cmNlLCBvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgb3B0aW9ucykge1xuICAgIGRpZShcInRvSlMgbm8gbG9uZ2VyIHN1cHBvcnRzIG9wdGlvbnNcIik7XG4gIH1cbiAgcmV0dXJuIHRvSlNIZWxwZXIoc291cmNlLCBuZXcgTWFwKCkpO1xufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGRpZShcInRyYWNlKCkgaXMgbm90IGF2YWlsYWJsZSBpbiBwcm9kdWN0aW9uIGJ1aWxkc1wiKTtcbiAgfVxuICB2YXIgZW50ZXJCcmVha1BvaW50ID0gZmFsc2U7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgZW50ZXJCcmVha1BvaW50ID0gYXJncy5wb3AoKTtcbiAgfVxuICB2YXIgZGVyaXZhdGlvbiA9IGdldEF0b21Gcm9tQXJncyhhcmdzKTtcbiAgaWYgKCFkZXJpdmF0aW9uKSB7XG4gICAgcmV0dXJuIGRpZShcIid0cmFjZShicmVhaz8pJyBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhIHRyYWNrZWQgY29tcHV0ZWQgdmFsdWUgb3IgYSBSZWFjdGlvbi4gQ29uc2lkZXIgcGFzc2luZyBpbiB0aGUgY29tcHV0ZWQgdmFsdWUgb3IgcmVhY3Rpb24gZXhwbGljaXRseVwiKTtcbiAgfVxuICBpZiAoZGVyaXZhdGlvbi5pc1RyYWNpbmdfID09PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIicgdHJhY2luZyBlbmFibGVkXCIpO1xuICB9XG4gIGRlcml2YXRpb24uaXNUcmFjaW5nXyA9IGVudGVyQnJlYWtQb2ludCA/IFRyYWNlTW9kZS5CUkVBSyA6IFRyYWNlTW9kZS5MT0c7XG59XG5mdW5jdGlvbiBnZXRBdG9tRnJvbUFyZ3MoYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZ2V0QXRvbShhcmdzWzBdKTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZ2V0QXRvbShhcmdzWzBdLCBhcmdzWzFdKTtcbiAgfVxufVxuXG4vKipcclxuICogRHVyaW5nIGEgdHJhbnNhY3Rpb24gbm8gdmlld3MgYXJlIHVwZGF0ZWQgdW50aWwgdGhlIGVuZCBvZiB0aGUgdHJhbnNhY3Rpb24uXHJcbiAqIFRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJ1biBzeW5jaHJvbm91c2x5IG5vbmV0aGVsZXNzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aW9uIGEgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIHNvbWUgcmVhY3RpdmUgc3RhdGVcclxuICogQHJldHVybnMgYW55IHZhbHVlIHRoYXQgd2FzIHJldHVybmVkIGJ5IHRoZSAnYWN0aW9uJyBwYXJhbWV0ZXIuXHJcbiAqL1xuZnVuY3Rpb24gdHJhbnNhY3Rpb24oYWN0aW9uLCB0aGlzQXJnKSB7XG4gIGlmICh0aGlzQXJnID09PSB2b2lkIDApIHtcbiAgICB0aGlzQXJnID0gdW5kZWZpbmVkO1xuICB9XG4gIHN0YXJ0QmF0Y2goKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYWN0aW9uLmFwcGx5KHRoaXNBcmcpO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2hlbihwcmVkaWNhdGUsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgYXJnMSAmJiB0eXBlb2YgYXJnMSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiB3aGVuUHJvbWlzZShwcmVkaWNhdGUsIGFyZzEpO1xuICB9XG4gIHJldHVybiBfd2hlbihwcmVkaWNhdGUsIGFyZzEsIGFyZzIgfHwge30pO1xufVxuZnVuY3Rpb24gX3doZW4ocHJlZGljYXRlLCBlZmZlY3QsIG9wdHMpIHtcbiAgdmFyIHRpbWVvdXRIYW5kbGU7XG4gIGlmICh0eXBlb2Ygb3B0cy50aW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiV0hFTl9USU1FT1VUXCIpO1xuICAgIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZGlzcG9zZXJbJG1vYnhdLmlzRGlzcG9zZWRfKSB7XG4gICAgICAgIGRpc3Bvc2VyKCk7XG4gICAgICAgIGlmIChvcHRzLm9uRXJyb3IpIHtcbiAgICAgICAgICBvcHRzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgb3B0cy50aW1lb3V0KTtcbiAgfVxuICBvcHRzLm5hbWUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBvcHRzLm5hbWUgfHwgXCJXaGVuQFwiICsgZ2V0TmV4dElkKCkgOiBcIldoZW5cIjtcbiAgdmFyIGVmZmVjdEFjdGlvbiA9IGNyZWF0ZUFjdGlvbihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBvcHRzLm5hbWUgKyBcIi1lZmZlY3RcIiA6IFwiV2hlbi1lZmZlY3RcIiwgZWZmZWN0KTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIHZhciBkaXNwb3NlciA9IGF1dG9ydW4oZnVuY3Rpb24gKHIpIHtcbiAgICAvLyBwcmVkaWNhdGUgc2hvdWxkIG5vdCBjaGFuZ2Ugc3RhdGVcbiAgICB2YXIgY29uZCA9IGFsbG93U3RhdGVDaGFuZ2VzKGZhbHNlLCBwcmVkaWNhdGUpO1xuICAgIGlmIChjb25kKSB7XG4gICAgICByLmRpc3Bvc2UoKTtcbiAgICAgIGlmICh0aW1lb3V0SGFuZGxlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgIH1cbiAgICAgIGVmZmVjdEFjdGlvbigpO1xuICAgIH1cbiAgfSwgb3B0cyk7XG4gIHJldHVybiBkaXNwb3Nlcjtcbn1cbmZ1bmN0aW9uIHdoZW5Qcm9taXNlKHByZWRpY2F0ZSwgb3B0cykge1xuICB2YXIgX29wdHMkc2lnbmFsO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG9wdHMgJiYgb3B0cy5vbkVycm9yKSB7XG4gICAgcmV0dXJuIGRpZShcInRoZSBvcHRpb25zICdvbkVycm9yJyBhbmQgJ3Byb21pc2UnIGNhbm5vdCBiZSBjb21iaW5lZFwiKTtcbiAgfVxuICBpZiAob3B0cyAhPSBudWxsICYmIChfb3B0cyRzaWduYWwgPSBvcHRzLnNpZ25hbCkgIT0gbnVsbCAmJiBfb3B0cyRzaWduYWwuYWJvcnRlZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIldIRU5fQUJPUlRFRFwiKSksIHtcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB2YXIgY2FuY2VsO1xuICB2YXIgYWJvcnQ7XG4gIHZhciByZXMgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIF9vcHRzJHNpZ25hbDI7XG4gICAgdmFyIGRpc3Bvc2VyID0gX3doZW4ocHJlZGljYXRlLCByZXNvbHZlLCBfZXh0ZW5kcyh7fSwgb3B0cywge1xuICAgICAgb25FcnJvcjogcmVqZWN0XG4gICAgfSkpO1xuICAgIGNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGRpc3Bvc2VyKCk7XG4gICAgICByZWplY3QobmV3IEVycm9yKFwiV0hFTl9DQU5DRUxMRURcIikpO1xuICAgIH07XG4gICAgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIGRpc3Bvc2VyKCk7XG4gICAgICByZWplY3QobmV3IEVycm9yKFwiV0hFTl9BQk9SVEVEXCIpKTtcbiAgICB9O1xuICAgIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IChfb3B0cyRzaWduYWwyID0gb3B0cy5zaWduYWwpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0cyRzaWduYWwyLmFkZEV2ZW50TGlzdGVuZXIgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRzJHNpZ25hbDIuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0KTtcbiAgfSlbXCJmaW5hbGx5XCJdKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX29wdHMkc2lnbmFsMztcbiAgICByZXR1cm4gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogKF9vcHRzJHNpZ25hbDMgPSBvcHRzLnNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRzJHNpZ25hbDMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9PSBudWxsID8gdm9pZCAwIDogX29wdHMkc2lnbmFsMy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnQpO1xuICB9KTtcbiAgcmVzLmNhbmNlbCA9IGNhbmNlbDtcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZ2V0QWRtKHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0WyRtb2J4XTtcbn1cbi8vIE9wdGltaXphdGlvbjogd2UgZG9uJ3QgbmVlZCB0aGUgaW50ZXJtZWRpYXRlIG9iamVjdHMgYW5kIGNvdWxkIGhhdmUgYSBjb21wbGV0ZWx5IGN1c3RvbSBhZG1pbmlzdHJhdGlvbiBmb3IgRHluYW1pY09iamVjdHMsXG4vLyBhbmQgc2tpcCBlaXRoZXIgdGhlIGludGVybmFsIHZhbHVlcyBtYXAsIG9yIHRoZSBiYXNlIG9iamVjdCB3aXRoIGl0cyBwcm9wZXJ0eSBkZXNjcmlwdG9ycyFcbnZhciBvYmplY3RQcm94eVRyYXBzID0ge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIG5hbWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikge1xuICAgICAgd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChcImRldGVjdCBuZXcgcHJvcGVydGllcyB1c2luZyB0aGUgJ2luJyBvcGVyYXRvci4gVXNlICdoYXMnIGZyb20gJ21vYngnIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRtKHRhcmdldCkuaGFzXyhuYW1lKTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBuYW1lKSB7XG4gICAgcmV0dXJuIGdldEFkbSh0YXJnZXQpLmdldF8obmFtZSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgX2dldEFkbSRzZXRfO1xuICAgIGlmICghaXNTdHJpbmdpc2gobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhZ2V0QWRtKHRhcmdldCkudmFsdWVzXy5oYXMobmFtZSkpIHtcbiAgICAgIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJhZGQgYSBuZXcgb2JzZXJ2YWJsZSBwcm9wZXJ0eSB0aHJvdWdoIGRpcmVjdCBhc3NpZ25tZW50LiBVc2UgJ3NldCcgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIC8vIG51bGwgKGludGVyY2VwdGVkKSAtPiB0cnVlIChzdWNjZXNzKVxuICAgIHJldHVybiAoX2dldEFkbSRzZXRfID0gZ2V0QWRtKHRhcmdldCkuc2V0XyhuYW1lLCB2YWx1ZSwgdHJ1ZSkpICE9IG51bGwgPyBfZ2V0QWRtJHNldF8gOiB0cnVlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBuYW1lKSB7XG4gICAgdmFyIF9nZXRBZG0kZGVsZXRlXztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiZGVsZXRlIHByb3BlcnRpZXMgZnJvbSBhbiBvYnNlcnZhYmxlIG9iamVjdC4gVXNlICdyZW1vdmUnIGZyb20gJ21vYngnIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIWlzU3RyaW5naXNoKG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG51bGwgKGludGVyY2VwdGVkKSAtPiB0cnVlIChzdWNjZXNzKVxuICAgIHJldHVybiAoX2dldEFkbSRkZWxldGVfID0gZ2V0QWRtKHRhcmdldCkuZGVsZXRlXyhuYW1lLCB0cnVlKSkgIT0gbnVsbCA/IF9nZXRBZG0kZGVsZXRlXyA6IHRydWU7XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICB2YXIgX2dldEFkbSRkZWZpbmVQcm9wZXJ0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJkZWZpbmUgcHJvcGVydHkgb24gYW4gb2JzZXJ2YWJsZSBvYmplY3QuIFVzZSAnZGVmaW5lUHJvcGVydHknIGZyb20gJ21vYngnIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICAvLyBudWxsIChpbnRlcmNlcHRlZCkgLT4gdHJ1ZSAoc3VjY2VzcylcbiAgICByZXR1cm4gKF9nZXRBZG0kZGVmaW5lUHJvcGVydCA9IGdldEFkbSh0YXJnZXQpLmRlZmluZVByb3BlcnR5XyhuYW1lLCBkZXNjcmlwdG9yKSkgIT0gbnVsbCA/IF9nZXRBZG0kZGVmaW5lUHJvcGVydCA6IHRydWU7XG4gIH0sXG4gIG93bktleXM6IGZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJpdGVyYXRlIGtleXMgdG8gZGV0ZWN0IGFkZGVkIC8gcmVtb3ZlZCBwcm9wZXJ0aWVzLiBVc2UgJ2tleXMnIGZyb20gJ21vYngnIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRtKHRhcmdldCkub3duS2V5c18oKTtcbiAgfSxcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCkge1xuICAgIGRpZSgxMyk7XG4gIH1cbn07XG5mdW5jdGlvbiBhc0R5bmFtaWNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCwgb3B0aW9ucykge1xuICB2YXIgX3RhcmdldCQkbW9ieCwgX3RhcmdldCQkbW9ieCRwcm94eV87XG4gIGFzc2VydFByb3hpZXMoKTtcbiAgdGFyZ2V0ID0gYXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCwgb3B0aW9ucyk7XG4gIHJldHVybiAoX3RhcmdldCQkbW9ieCRwcm94eV8gPSAoX3RhcmdldCQkbW9ieCA9IHRhcmdldFskbW9ieF0pLnByb3h5XykgIT0gbnVsbCA/IF90YXJnZXQkJG1vYngkcHJveHlfIDogX3RhcmdldCQkbW9ieC5wcm94eV8gPSBuZXcgUHJveHkodGFyZ2V0LCBvYmplY3RQcm94eVRyYXBzKTtcbn1cblxuZnVuY3Rpb24gaGFzSW50ZXJjZXB0b3JzKGludGVyY2VwdGFibGUpIHtcbiAgcmV0dXJuIGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXyAhPT0gdW5kZWZpbmVkICYmIGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXy5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJJbnRlcmNlcHRvcihpbnRlcmNlcHRhYmxlLCBoYW5kbGVyKSB7XG4gIHZhciBpbnRlcmNlcHRvcnMgPSBpbnRlcmNlcHRhYmxlLmludGVyY2VwdG9yc18gfHwgKGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXyA9IFtdKTtcbiAgaW50ZXJjZXB0b3JzLnB1c2goaGFuZGxlcik7XG4gIHJldHVybiBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4ID0gaW50ZXJjZXB0b3JzLmluZGV4T2YoaGFuZGxlcik7XG4gICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgIGludGVyY2VwdG9ycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaW50ZXJjZXB0Q2hhbmdlKGludGVyY2VwdGFibGUsIGNoYW5nZSkge1xuICB2YXIgcHJldlUgPSB1bnRyYWNrZWRTdGFydCgpO1xuICB0cnkge1xuICAgIC8vIEludGVyY2VwdG9yIGNhbiBtb2RpZnkgdGhlIGFycmF5LCBjb3B5IGl0IHRvIGF2b2lkIGNvbmN1cnJlbnQgbW9kaWZpY2F0aW9uLCBzZWUgIzE5NTBcbiAgICB2YXIgaW50ZXJjZXB0b3JzID0gW10uY29uY2F0KGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXyB8fCBbXSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbnRlcmNlcHRvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaGFuZ2UgPSBpbnRlcmNlcHRvcnNbaV0oY2hhbmdlKTtcbiAgICAgIGlmIChjaGFuZ2UgJiYgIWNoYW5nZS50eXBlKSB7XG4gICAgICAgIGRpZSgxNCk7XG4gICAgICB9XG4gICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfSBmaW5hbGx5IHtcbiAgICB1bnRyYWNrZWRFbmQocHJldlUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0xpc3RlbmVycyhsaXN0ZW5hYmxlKSB7XG4gIHJldHVybiBsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc18gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc18ubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXIobGlzdGVuYWJsZSwgaGFuZGxlcikge1xuICB2YXIgbGlzdGVuZXJzID0gbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfIHx8IChsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc18gPSBbXSk7XG4gIGxpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xuICByZXR1cm4gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkeCA9IGxpc3RlbmVycy5pbmRleE9mKGhhbmRsZXIpO1xuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICBsaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycyhsaXN0ZW5hYmxlLCBjaGFuZ2UpIHtcbiAgdmFyIHByZXZVID0gdW50cmFja2VkU3RhcnQoKTtcbiAgdmFyIGxpc3RlbmVycyA9IGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzXztcbiAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxpc3RlbmVyc1tpXShjaGFuZ2UpO1xuICB9XG4gIHVudHJhY2tlZEVuZChwcmV2VSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VPYnNlcnZhYmxlKHRhcmdldCwgYW5ub3RhdGlvbnMsIG9wdGlvbnMpIHtcbiAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpWyRtb2J4XTtcbiAgc3RhcnRCYXRjaCgpO1xuICB0cnkge1xuICAgIHZhciBfYW5ub3RhdGlvbnM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBhbm5vdGF0aW9ucyAmJiB0YXJnZXRbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSB7XG4gICAgICBkaWUoXCJtYWtlT2JzZXJ2YWJsZSBzZWNvbmQgYXJnIG11c3QgYmUgbnVsbGlzaCB3aGVuIHVzaW5nIGRlY29yYXRvcnMuIE1peGluZyBAZGVjb3JhdG9yIHN5bnRheCB3aXRoIGFubm90YXRpb25zIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICAvLyBEZWZhdWx0IHRvIGRlY29yYXRvcnNcbiAgICAoX2Fubm90YXRpb25zID0gYW5ub3RhdGlvbnMpICE9IG51bGwgPyBfYW5ub3RhdGlvbnMgOiBhbm5vdGF0aW9ucyA9IGNvbGxlY3RTdG9yZWRBbm5vdGF0aW9ucyh0YXJnZXQpO1xuICAgIC8vIEFubm90YXRlXG4gICAgb3duS2V5cyhhbm5vdGF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gYWRtLm1ha2VfKGtleSwgYW5ub3RhdGlvbnNba2V5XSk7XG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgZW5kQmF0Y2goKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuLy8gcHJvdG9ba2V5c1N5bWJvbF0gPSBuZXcgU2V0PFByb3BlcnR5S2V5PigpXG52YXIga2V5c1N5bWJvbCA9IC8qI19fUFVSRV9fKi9TeW1ib2woXCJtb2J4LWtleXNcIik7XG5mdW5jdGlvbiBtYWtlQXV0b09ic2VydmFibGUodGFyZ2V0LCBvdmVycmlkZXMsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmICFpc1BsYWluT2JqZWN0KE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpKSkge1xuICAgICAgZGllKFwiJ21ha2VBdXRvT2JzZXJ2YWJsZScgY2FuIG9ubHkgYmUgdXNlZCBmb3IgY2xhc3NlcyB0aGF0IGRvbid0IGhhdmUgYSBzdXBlcmNsYXNzXCIpO1xuICAgIH1cbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgIGRpZShcIm1ha2VBdXRvT2JzZXJ2YWJsZSBjYW4gb25seSBiZSB1c2VkIG9uIG9iamVjdHMgbm90IGFscmVhZHkgbWFkZSBvYnNlcnZhYmxlXCIpO1xuICAgIH1cbiAgfVxuICAvLyBPcHRpbWl6YXRpb246IGF2b2lkIHZpc2l0aW5nIHByb3Rvc1xuICAvLyBBc3N1bWVzIHRoYXQgYW5ub3RhdGlvbi5tYWtlXy8uZXh0ZW5kXyB3b3JrcyB0aGUgc2FtZSBmb3IgcGxhaW4gb2JqZWN0c1xuICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIGV4dGVuZE9ic2VydmFibGUodGFyZ2V0LCB0YXJnZXQsIG92ZXJyaWRlcywgb3B0aW9ucyk7XG4gIH1cbiAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpWyRtb2J4XTtcbiAgLy8gT3B0aW1pemF0aW9uOiBjYWNoZSBrZXlzIG9uIHByb3RvXG4gIC8vIEFzc3VtZXMgbWFrZUF1dG9PYnNlcnZhYmxlIGNhbiBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBvYmplY3QgYW5kIGNhbid0IGJlIHVzZWQgaW4gc3ViY2xhc3NcbiAgaWYgKCF0YXJnZXRba2V5c1N5bWJvbF0pIHtcbiAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgICB2YXIga2V5cyA9IG5ldyBTZXQoW10uY29uY2F0KG93bktleXModGFyZ2V0KSwgb3duS2V5cyhwcm90bykpKTtcbiAgICBrZXlzW1wiZGVsZXRlXCJdKFwiY29uc3RydWN0b3JcIik7XG4gICAga2V5c1tcImRlbGV0ZVwiXSgkbW9ieCk7XG4gICAgYWRkSGlkZGVuUHJvcChwcm90bywga2V5c1N5bWJvbCwga2V5cyk7XG4gIH1cbiAgc3RhcnRCYXRjaCgpO1xuICB0cnkge1xuICAgIHRhcmdldFtrZXlzU3ltYm9sXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBhZG0ubWFrZV8oa2V5LFxuICAgICAgLy8gbXVzdCBwYXNzIFwidW5kZWZpbmVkXCIgZm9yIHsga2V5OiB1bmRlZmluZWQgfVxuICAgICAgIW92ZXJyaWRlcyA/IHRydWUgOiBrZXkgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzW2tleV0gOiB0cnVlKTtcbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBlbmRCYXRjaCgpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBTUExJQ0UgPSBcInNwbGljZVwiO1xudmFyIFVQREFURSA9IFwidXBkYXRlXCI7XG52YXIgTUFYX1NQTElDRV9TSVpFID0gMTAwMDA7IC8vIFNlZSBlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9pc3N1ZXMvODU5XG52YXIgYXJyYXlUcmFwcyA9IHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBuYW1lKSB7XG4gICAgdmFyIGFkbSA9IHRhcmdldFskbW9ieF07XG4gICAgaWYgKG5hbWUgPT09ICRtb2J4KSB7XG4gICAgICByZXR1cm4gYWRtO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgcmV0dXJuIGFkbS5nZXRBcnJheUxlbmd0aF8oKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmICFpc05hTihuYW1lKSkge1xuICAgICAgcmV0dXJuIGFkbS5nZXRfKHBhcnNlSW50KG5hbWUpKTtcbiAgICB9XG4gICAgaWYgKGhhc1Byb3AoYXJyYXlFeHRlbnNpb25zLCBuYW1lKSkge1xuICAgICAgcmV0dXJuIGFycmF5RXh0ZW5zaW9uc1tuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFtuYW1lXTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBhZG0gPSB0YXJnZXRbJG1vYnhdO1xuICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICBhZG0uc2V0QXJyYXlMZW5ndGhfKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiIHx8IGlzTmFOKG5hbWUpKSB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbnVtZXJpYyBzdHJpbmdcbiAgICAgIGFkbS5zZXRfKHBhcnNlSW50KG5hbWUpLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoKSB7XG4gICAgZGllKDE1KTtcbiAgfVxufTtcbnZhciBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIHRoaXMgaXMgdGhlIHByb3AgdGhhdCBnZXRzIHByb3hpZWQsIHNvIGNhbid0IHJlcGxhY2UgaXQhXG5cbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24obmFtZSwgZW5oYW5jZXIsIG93bmVkXywgbGVnYWN5TW9kZV8pIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJPYnNlcnZhYmxlQXJyYXlAXCIgKyBnZXROZXh0SWQoKSA6IFwiT2JzZXJ2YWJsZUFycmF5XCI7XG4gICAgfVxuICAgIHRoaXMub3duZWRfID0gdm9pZCAwO1xuICAgIHRoaXMubGVnYWN5TW9kZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5hdG9tXyA9IHZvaWQgMDtcbiAgICB0aGlzLnZhbHVlc18gPSBbXTtcbiAgICB0aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuZW5oYW5jZXJfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm94eV8gPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0S25vd25MZW5ndGhfID0gMDtcbiAgICB0aGlzLm93bmVkXyA9IG93bmVkXztcbiAgICB0aGlzLmxlZ2FjeU1vZGVfID0gbGVnYWN5TW9kZV87XG4gICAgdGhpcy5hdG9tXyA9IG5ldyBBdG9tKG5hbWUpO1xuICAgIHRoaXMuZW5oYW5jZXJfID0gZnVuY3Rpb24gKG5ld1YsIG9sZFYpIHtcbiAgICAgIHJldHVybiBlbmhhbmNlcihuZXdWLCBvbGRWLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBuYW1lICsgXCJbLi5dXCIgOiBcIk9ic2VydmFibGVBcnJheVsuLl1cIik7XG4gICAgfTtcbiAgfVxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlO1xuICBfcHJvdG8uZGVoYW5jZVZhbHVlXyA9IGZ1bmN0aW9uIGRlaGFuY2VWYWx1ZV8odmFsdWUpIHtcbiAgICBpZiAodGhpcy5kZWhhbmNlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWhhbmNlcih2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZXNfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlc18odmFsdWVzKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHZhbHVlcy5tYXAodGhpcy5kZWhhbmNlcik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICBpZiAoZmlyZUltbWVkaWF0ZWx5ID09PSB2b2lkIDApIHtcbiAgICAgIGZpcmVJbW1lZGlhdGVseSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgICBsaXN0ZW5lcih7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcImFycmF5XCIsXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8sXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5hdG9tXy5uYW1lXyxcbiAgICAgICAgdHlwZTogXCJzcGxpY2VcIixcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIGFkZGVkOiB0aGlzLnZhbHVlc18uc2xpY2UoKSxcbiAgICAgICAgYWRkZWRDb3VudDogdGhpcy52YWx1ZXNfLmxlbmd0aCxcbiAgICAgICAgcmVtb3ZlZDogW10sXG4gICAgICAgIHJlbW92ZWRDb3VudDogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcbiAgX3Byb3RvLmdldEFycmF5TGVuZ3RoXyA9IGZ1bmN0aW9uIGdldEFycmF5TGVuZ3RoXygpIHtcbiAgICB0aGlzLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXy5sZW5ndGg7XG4gIH07XG4gIF9wcm90by5zZXRBcnJheUxlbmd0aF8gPSBmdW5jdGlvbiBzZXRBcnJheUxlbmd0aF8obmV3TGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdMZW5ndGggIT09IFwibnVtYmVyXCIgfHwgaXNOYU4obmV3TGVuZ3RoKSB8fCBuZXdMZW5ndGggPCAwKSB7XG4gICAgICBkaWUoXCJPdXQgb2YgcmFuZ2U6IFwiICsgbmV3TGVuZ3RoKTtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRMZW5ndGggPSB0aGlzLnZhbHVlc18ubGVuZ3RoO1xuICAgIGlmIChuZXdMZW5ndGggPT09IGN1cnJlbnRMZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKG5ld0xlbmd0aCA+IGN1cnJlbnRMZW5ndGgpIHtcbiAgICAgIHZhciBuZXdJdGVtcyA9IG5ldyBBcnJheShuZXdMZW5ndGggLSBjdXJyZW50TGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3TGVuZ3RoIC0gY3VycmVudExlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0l0ZW1zW2ldID0gdW5kZWZpbmVkO1xuICAgICAgfSAvLyBObyBBcnJheS5maWxsIGV2ZXJ5d2hlcmUuLi5cbiAgICAgIHRoaXMuc3BsaWNlV2l0aEFycmF5XyhjdXJyZW50TGVuZ3RoLCAwLCBuZXdJdGVtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3BsaWNlV2l0aEFycmF5XyhuZXdMZW5ndGgsIGN1cnJlbnRMZW5ndGggLSBuZXdMZW5ndGgpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnVwZGF0ZUFycmF5TGVuZ3RoXyA9IGZ1bmN0aW9uIHVwZGF0ZUFycmF5TGVuZ3RoXyhvbGRMZW5ndGgsIGRlbHRhKSB7XG4gICAgaWYgKG9sZExlbmd0aCAhPT0gdGhpcy5sYXN0S25vd25MZW5ndGhfKSB7XG4gICAgICBkaWUoMTYpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RLbm93bkxlbmd0aF8gKz0gZGVsdGE7XG4gICAgaWYgKHRoaXMubGVnYWN5TW9kZV8gJiYgZGVsdGEgPiAwKSB7XG4gICAgICByZXNlcnZlQXJyYXlCdWZmZXIob2xkTGVuZ3RoICsgZGVsdGEgKyAxKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5zcGxpY2VXaXRoQXJyYXlfID0gZnVuY3Rpb24gc3BsaWNlV2l0aEFycmF5XyhpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmF0b21fKTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy52YWx1ZXNfLmxlbmd0aDtcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPiBsZW5ndGgpIHtcbiAgICAgIGluZGV4ID0gbGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IE1hdGgubWF4KDAsIGxlbmd0aCArIGluZGV4KTtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRlbGV0ZUNvdW50ID0gbGVuZ3RoIC0gaW5kZXg7XG4gICAgfSBlbHNlIGlmIChkZWxldGVDb3VudCA9PT0gdW5kZWZpbmVkIHx8IGRlbGV0ZUNvdW50ID09PSBudWxsKSB7XG4gICAgICBkZWxldGVDb3VudCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZUNvdW50ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGVsZXRlQ291bnQsIGxlbmd0aCAtIGluZGV4KSk7XG4gICAgfVxuICAgIGlmIChuZXdJdGVtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdJdGVtcyA9IEVNUFRZX0FSUkFZO1xuICAgIH1cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgICAgdHlwZTogU1BMSUNFLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHJlbW92ZWRDb3VudDogZGVsZXRlQ291bnQsXG4gICAgICAgIGFkZGVkOiBuZXdJdGVtc1xuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICByZXR1cm4gRU1QVFlfQVJSQVk7XG4gICAgICB9XG4gICAgICBkZWxldGVDb3VudCA9IGNoYW5nZS5yZW1vdmVkQ291bnQ7XG4gICAgICBuZXdJdGVtcyA9IGNoYW5nZS5hZGRlZDtcbiAgICB9XG4gICAgbmV3SXRlbXMgPSBuZXdJdGVtcy5sZW5ndGggPT09IDAgPyBuZXdJdGVtcyA6IG5ld0l0ZW1zLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIF90aGlzLmVuaGFuY2VyXyh2LCB1bmRlZmluZWQpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmxlZ2FjeU1vZGVfIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgdmFyIGxlbmd0aERlbHRhID0gbmV3SXRlbXMubGVuZ3RoIC0gZGVsZXRlQ291bnQ7XG4gICAgICB0aGlzLnVwZGF0ZUFycmF5TGVuZ3RoXyhsZW5ndGgsIGxlbmd0aERlbHRhKTsgLy8gY2hlY2tzIGlmIGludGVybmFsIGFycmF5IHdhc24ndCBtb2RpZmllZFxuICAgIH1cblxuICAgIHZhciByZXMgPSB0aGlzLnNwbGljZUl0ZW1zSW50b1ZhbHVlc18oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcyk7XG4gICAgaWYgKGRlbGV0ZUNvdW50ICE9PSAwIHx8IG5ld0l0ZW1zLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy5ub3RpZnlBcnJheVNwbGljZV8oaW5kZXgsIG5ld0l0ZW1zLCByZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWVzXyhyZXMpO1xuICB9O1xuICBfcHJvdG8uc3BsaWNlSXRlbXNJbnRvVmFsdWVzXyA9IGZ1bmN0aW9uIHNwbGljZUl0ZW1zSW50b1ZhbHVlc18oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcykge1xuICAgIGlmIChuZXdJdGVtcy5sZW5ndGggPCBNQVhfU1BMSUNFX1NJWkUpIHtcbiAgICAgIHZhciBfdGhpcyR2YWx1ZXNfO1xuICAgICAgcmV0dXJuIChfdGhpcyR2YWx1ZXNfID0gdGhpcy52YWx1ZXNfKS5zcGxpY2UuYXBwbHkoX3RoaXMkdmFsdWVzXywgW2luZGV4LCBkZWxldGVDb3VudF0uY29uY2F0KG5ld0l0ZW1zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBpdGVtcyByZW1vdmVkIGJ5IHRoZSBzcGxpY2VcbiAgICAgIHZhciByZXMgPSB0aGlzLnZhbHVlc18uc2xpY2UoaW5kZXgsIGluZGV4ICsgZGVsZXRlQ291bnQpO1xuICAgICAgLy8gVGhlIGl0ZW1zIHRoYXQgdGhhdCBzaG91bGQgcmVtYWluIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5XG4gICAgICB2YXIgb2xkSXRlbXMgPSB0aGlzLnZhbHVlc18uc2xpY2UoaW5kZXggKyBkZWxldGVDb3VudCk7XG4gICAgICAvLyBOZXcgbGVuZ3RoIGlzIHRoZSBwcmV2aW91cyBsZW5ndGggKyBhZGRpdGlvbiBjb3VudCAtIGRlbGV0aW9uIGNvdW50XG4gICAgICB0aGlzLnZhbHVlc18ubGVuZ3RoICs9IG5ld0l0ZW1zLmxlbmd0aCAtIGRlbGV0ZUNvdW50O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnZhbHVlc19baW5kZXggKyBpXSA9IG5ld0l0ZW1zW2ldO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG9sZEl0ZW1zLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0aGlzLnZhbHVlc19baW5kZXggKyBuZXdJdGVtcy5sZW5ndGggKyBfaV0gPSBvbGRJdGVtc1tfaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm5vdGlmeUFycmF5Q2hpbGRVcGRhdGVfID0gZnVuY3Rpb24gbm90aWZ5QXJyYXlDaGlsZFVwZGF0ZV8oaW5kZXgsIG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIHZhciBub3RpZnlTcHkgPSAhdGhpcy5vd25lZF8gJiYgaXNTcHlFbmFibGVkKCk7XG4gICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgIG9ic2VydmFibGVLaW5kOiBcImFycmF5XCIsXG4gICAgICBvYmplY3Q6IHRoaXMucHJveHlfLFxuICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLmF0b21fLm5hbWVfLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlXG4gICAgfSA6IG51bGw7XG4gICAgLy8gVGhlIHJlYXNvbiB3aHkgdGhpcyBpcyBvbiByaWdodCBoYW5kIHNpZGUgaGVyZSAoYW5kIG5vdCBhYm92ZSksIGlzIHRoaXMgd2F5IHRoZSB1Z2xpZmllciB3aWxsIGRyb3AgaXQsIGJ1dCBpdCB3b24ndFxuICAgIC8vIGNhdXNlIGFueSBydW50aW1lIG92ZXJoZWFkIGluIGRldmVsb3BtZW50IG1vZGUgd2l0aG91dCBOT0RFX0VOViBzZXQsIHVubGVzcyBzcHlpbmcgaXMgZW5hYmxlZFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgIH1cbiAgICB0aGlzLmF0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICBpZiAobm90aWZ5KSB7XG4gICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm5vdGlmeUFycmF5U3BsaWNlXyA9IGZ1bmN0aW9uIG5vdGlmeUFycmF5U3BsaWNlXyhpbmRleCwgYWRkZWQsIHJlbW92ZWQpIHtcbiAgICB2YXIgbm90aWZ5U3B5ID0gIXRoaXMub3duZWRfICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJhcnJheVwiLFxuICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5hdG9tXy5uYW1lXyxcbiAgICAgIHR5cGU6IFNQTElDRSxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgICBhZGRlZDogYWRkZWQsXG4gICAgICByZW1vdmVkQ291bnQ6IHJlbW92ZWQubGVuZ3RoLFxuICAgICAgYWRkZWRDb3VudDogYWRkZWQubGVuZ3RoXG4gICAgfSA6IG51bGw7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgfVxuICAgIHRoaXMuYXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgIC8vIGNvbmZvcm06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L29ic2VydmVcbiAgICBpZiAobm90aWZ5KSB7XG4gICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmdldF8gPSBmdW5jdGlvbiBnZXRfKGluZGV4KSB7XG4gICAgaWYgKHRoaXMubGVnYWN5TW9kZV8gJiYgaW5kZXggPj0gdGhpcy52YWx1ZXNfLmxlbmd0aCkge1xuICAgICAgY29uc29sZS53YXJuKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiW21vYnguYXJyYXldIEF0dGVtcHQgdG8gcmVhZCBhbiBhcnJheSBpbmRleCAoXCIgKyBpbmRleCArIFwiKSB0aGF0IGlzIG91dCBvZiBib3VuZHMgKFwiICsgdGhpcy52YWx1ZXNfLmxlbmd0aCArIFwiKS4gUGxlYXNlIGNoZWNrIGxlbmd0aCBmaXJzdC4gT3V0IG9mIGJvdW5kIGluZGljZXMgd2lsbCBub3QgYmUgdHJhY2tlZCBieSBNb2JYXCIgOiBcIlttb2J4XSBPdXQgb2YgYm91bmRzIHJlYWQ6IFwiICsgaW5kZXgpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZV8odGhpcy52YWx1ZXNfW2luZGV4XSk7XG4gIH07XG4gIF9wcm90by5zZXRfID0gZnVuY3Rpb24gc2V0XyhpbmRleCwgbmV3VmFsdWUpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXNfO1xuICAgIGlmICh0aGlzLmxlZ2FjeU1vZGVfICYmIGluZGV4ID4gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgLy8gb3V0IG9mIGJvdW5kc1xuICAgICAgZGllKDE3LCBpbmRleCwgdmFsdWVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIC8vIHVwZGF0ZSBhdCBpbmRleCBpbiByYW5nZVxuICAgICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5hdG9tXyk7XG4gICAgICB2YXIgb2xkVmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICAgIH1cbiAgICAgIG5ld1ZhbHVlID0gdGhpcy5lbmhhbmNlcl8obmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIHZhciBjaGFuZ2VkID0gbmV3VmFsdWUgIT09IG9sZFZhbHVlO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLm5vdGlmeUFycmF5Q2hpbGRVcGRhdGVfKGluZGV4LCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3Igb3V0IG9mIGJvdW5kIGluZGV4LCB3ZSBkb24ndCBjcmVhdGUgYW4gYWN0dWFsIHNwYXJzZSBhcnJheSxcbiAgICAgIC8vIGJ1dCByYXRoZXIgZmlsbCB0aGUgaG9sZXMgd2l0aCB1bmRlZmluZWQgKHNhbWUgYXMgc2V0QXJyYXlMZW5ndGhfKS5cbiAgICAgIC8vIFRoaXMgY291bGQgYmUgY29uc2lkZXJlZCBhIGJ1Zy5cbiAgICAgIHZhciBuZXdJdGVtcyA9IG5ldyBBcnJheShpbmRleCArIDEgLSB2YWx1ZXMubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3SXRlbXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIG5ld0l0ZW1zW2ldID0gdW5kZWZpbmVkO1xuICAgICAgfSAvLyBObyBBcnJheS5maWxsIGV2ZXJ5d2hlcmUuLi5cbiAgICAgIG5ld0l0ZW1zW25ld0l0ZW1zLmxlbmd0aCAtIDFdID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLnNwbGljZVdpdGhBcnJheV8odmFsdWVzLmxlbmd0aCwgMCwgbmV3SXRlbXMpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uO1xufSgpO1xuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2YWJsZUFycmF5KGluaXRpYWxWYWx1ZXMsIGVuaGFuY2VyLCBuYW1lLCBvd25lZCkge1xuICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgbmFtZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiT2JzZXJ2YWJsZUFycmF5QFwiICsgZ2V0TmV4dElkKCkgOiBcIk9ic2VydmFibGVBcnJheVwiO1xuICB9XG4gIGlmIChvd25lZCA9PT0gdm9pZCAwKSB7XG4gICAgb3duZWQgPSBmYWxzZTtcbiAgfVxuICBhc3NlcnRQcm94aWVzKCk7XG4gIHZhciBhZG0gPSBuZXcgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24obmFtZSwgZW5oYW5jZXIsIG93bmVkLCBmYWxzZSk7XG4gIGFkZEhpZGRlbkZpbmFsUHJvcChhZG0udmFsdWVzXywgJG1vYngsIGFkbSk7XG4gIHZhciBwcm94eSA9IG5ldyBQcm94eShhZG0udmFsdWVzXywgYXJyYXlUcmFwcyk7XG4gIGFkbS5wcm94eV8gPSBwcm94eTtcbiAgaWYgKGluaXRpYWxWYWx1ZXMgJiYgaW5pdGlhbFZhbHVlcy5sZW5ndGgpIHtcbiAgICB2YXIgcHJldiA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQodHJ1ZSk7XG4gICAgYWRtLnNwbGljZVdpdGhBcnJheV8oMCwgMCwgaW5pdGlhbFZhbHVlcyk7XG4gICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldik7XG4gIH1cbiAgcmV0dXJuIHByb3h5O1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG52YXIgYXJyYXlFeHRlbnNpb25zID0ge1xuICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKDApO1xuICB9LFxuICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKG5ld0l0ZW1zKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIHJldHVybiBhZG0uc3BsaWNlV2l0aEFycmF5XygwLCBhZG0udmFsdWVzXy5sZW5ndGgsIG5ld0l0ZW1zKTtcbiAgfSxcbiAgLy8gVXNlZCBieSBKU09OLnN0cmluZ2lmeVxuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZSgpO1xuICB9LFxuICAvKlxyXG4gICAqIGZ1bmN0aW9ucyB0aGF0IGRvIGFsdGVyIHRoZSBpbnRlcm5hbCBzdHJ1Y3R1cmUgb2YgdGhlIGFycmF5LCAoYmFzZWQgb24gbGliLmVzNi5kLnRzKVxyXG4gICAqIHNpbmNlIHRoZXNlIGZ1bmN0aW9ucyBhbHRlciB0aGUgaW5uZXIgc3RydWN0dXJlIG9mIHRoZSBhcnJheSwgdGhlIGhhdmUgc2lkZSBlZmZlY3RzLlxyXG4gICAqIEJlY2F1c2UgdGhlIGhhdmUgc2lkZSBlZmZlY3RzLCB0aGV5IHNob3VsZCBub3QgYmUgdXNlZCBpbiBjb21wdXRlZCBmdW5jdGlvbixcclxuICAgKiBhbmQgZm9yIHRoYXQgcmVhc29uIHRoZSBkbyBub3QgY2FsbCBkZXBlbmRlbmN5U3RhdGUubm90aWZ5T2JzZXJ2ZWRcclxuICAgKi9cbiAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2UoaW5kZXgsIGRlbGV0ZUNvdW50KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5ld0l0ZW1zID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIG5ld0l0ZW1zW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW107XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBhZG0uc3BsaWNlV2l0aEFycmF5XyhpbmRleCk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBhZG0uc3BsaWNlV2l0aEFycmF5XyhpbmRleCwgZGVsZXRlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gYWRtLnNwbGljZVdpdGhBcnJheV8oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcyk7XG4gIH0sXG4gIHNwbGljZVdpdGhBcnJheTogZnVuY3Rpb24gc3BsaWNlV2l0aEFycmF5KGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpIHtcbiAgICByZXR1cm4gdGhpc1skbW9ieF0uc3BsaWNlV2l0aEFycmF5XyhpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKTtcbiAgfSxcbiAgcHVzaDogZnVuY3Rpb24gcHVzaCgpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgaXRlbXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgYWRtLnNwbGljZVdpdGhBcnJheV8oYWRtLnZhbHVlc18ubGVuZ3RoLCAwLCBpdGVtcyk7XG4gICAgcmV0dXJuIGFkbS52YWx1ZXNfLmxlbmd0aDtcbiAgfSxcbiAgcG9wOiBmdW5jdGlvbiBwb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKE1hdGgubWF4KHRoaXNbJG1vYnhdLnZhbHVlc18ubGVuZ3RoIC0gMSwgMCksIDEpWzBdO1xuICB9LFxuICBzaGlmdDogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKDAsIDEpWzBdO1xuICB9LFxuICB1bnNoaWZ0OiBmdW5jdGlvbiB1bnNoaWZ0KCkge1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBpdGVtc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cbiAgICBhZG0uc3BsaWNlV2l0aEFycmF5XygwLCAwLCBpdGVtcyk7XG4gICAgcmV0dXJuIGFkbS52YWx1ZXNfLmxlbmd0aDtcbiAgfSxcbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAvLyByZXZlcnNlIGJ5IGRlZmF1bHQgbXV0YXRlcyBpbiBwbGFjZSBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN1bHRcbiAgICAvLyB3aGljaCBtYWtlcyBpdCBib3RoIGEgJ2Rlcml2YXRpb24nIGFuZCBhICdtdXRhdGlvbicuXG4gICAgaWYgKGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikge1xuICAgICAgZGllKDM3LCBcInJldmVyc2VcIik7XG4gICAgfVxuICAgIHRoaXMucmVwbGFjZSh0aGlzLnNsaWNlKCkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc29ydDogZnVuY3Rpb24gc29ydCgpIHtcbiAgICAvLyBzb3J0IGJ5IGRlZmF1bHQgbXV0YXRlcyBpbiBwbGFjZSBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN1bHRcbiAgICAvLyB3aGljaCBnb2VzIGFnYWluc3QgYWxsIGdvb2QgcHJhY3RpY2VzLiBMZXQncyBub3QgY2hhbmdlIHRoZSBhcnJheSBpbiBwbGFjZSFcbiAgICBpZiAoZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSB7XG4gICAgICBkaWUoMzcsIFwic29ydFwiKTtcbiAgICB9XG4gICAgdmFyIGNvcHkgPSB0aGlzLnNsaWNlKCk7XG4gICAgY29weS5zb3J0LmFwcGx5KGNvcHksIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5yZXBsYWNlKGNvcHkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSh2YWx1ZSkge1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICB2YXIgaWR4ID0gYWRtLmRlaGFuY2VWYWx1ZXNfKGFkbS52YWx1ZXNfKS5pbmRleE9mKHZhbHVlKTtcbiAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgIHRoaXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuLyoqXHJcbiAqIFdyYXAgZnVuY3Rpb24gZnJvbSBwcm90b3R5cGVcclxuICogV2l0aG91dCB0aGlzLCBldmVyeXRoaW5nIHdvcmtzIGFzIHdlbGwsIGJ1dCB0aGlzIHdvcmtzXHJcbiAqIGZhc3RlciBhcyBldmVyeXRoaW5nIHdvcmtzIG9uIHVucHJveGllZCB2YWx1ZXNcclxuICovXG5hZGRBcnJheUV4dGVuc2lvbihcImNvbmNhdFwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmxhdFwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiaW5jbHVkZXNcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImluZGV4T2ZcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImpvaW5cIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImxhc3RJbmRleE9mXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJzbGljZVwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwidG9TdHJpbmdcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInRvTG9jYWxlU3RyaW5nXCIsIHNpbXBsZUZ1bmMpO1xuLy8gbWFwXG5hZGRBcnJheUV4dGVuc2lvbihcImV2ZXJ5XCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmlsdGVyXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmluZFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZpbmRJbmRleFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZsYXRNYXBcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmb3JFYWNoXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwibWFwXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwic29tZVwiLCBtYXBMaWtlRnVuYyk7XG4vLyByZWR1Y2VcbmFkZEFycmF5RXh0ZW5zaW9uKFwicmVkdWNlXCIsIHJlZHVjZUxpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwicmVkdWNlUmlnaHRcIiwgcmVkdWNlTGlrZUZ1bmMpO1xuZnVuY3Rpb24gYWRkQXJyYXlFeHRlbnNpb24oZnVuY05hbWUsIGZ1bmNGYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgQXJyYXkucHJvdG90eXBlW2Z1bmNOYW1lXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgYXJyYXlFeHRlbnNpb25zW2Z1bmNOYW1lXSA9IGZ1bmNGYWN0b3J5KGZ1bmNOYW1lKTtcbiAgfVxufVxuLy8gUmVwb3J0IGFuZCBkZWxlZ2F0ZSB0byBkZWhhbmNlZCBhcnJheVxuZnVuY3Rpb24gc2ltcGxlRnVuYyhmdW5jTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICBhZG0uYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICB2YXIgZGVoYW5jZWRWYWx1ZXMgPSBhZG0uZGVoYW5jZVZhbHVlc18oYWRtLnZhbHVlc18pO1xuICAgIHJldHVybiBkZWhhbmNlZFZhbHVlc1tmdW5jTmFtZV0uYXBwbHkoZGVoYW5jZWRWYWx1ZXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4vLyBNYWtlIHN1cmUgY2FsbGJhY2tzIHJlY2lldmUgY29ycmVjdCBhcnJheSBhcmcgIzIzMjZcbmZ1bmN0aW9uIG1hcExpa2VGdW5jKGZ1bmNOYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgYWRtLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgdmFyIGRlaGFuY2VkVmFsdWVzID0gYWRtLmRlaGFuY2VWYWx1ZXNfKGFkbS52YWx1ZXNfKTtcbiAgICByZXR1cm4gZGVoYW5jZWRWYWx1ZXNbZnVuY05hbWVdKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgZWxlbWVudCwgaW5kZXgsIF90aGlzMik7XG4gICAgfSk7XG4gIH07XG59XG4vLyBNYWtlIHN1cmUgY2FsbGJhY2tzIHJlY2lldmUgY29ycmVjdCBhcnJheSBhcmcgIzIzMjZcbmZ1bmN0aW9uIHJlZHVjZUxpa2VGdW5jKGZ1bmNOYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIGFkbS5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBkZWhhbmNlZFZhbHVlcyA9IGFkbS5kZWhhbmNlVmFsdWVzXyhhZG0udmFsdWVzXyk7XG4gICAgLy8gIzI0MzIgLSByZWR1Y2UgYmVoYXZpb3IgZGVwZW5kcyBvbiBhcmd1bWVudHMubGVuZ3RoXG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICAgIGFyZ3VtZW50c1swXSA9IGZ1bmN0aW9uIChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUsIGluZGV4LCBfdGhpczMpO1xuICAgIH07XG4gICAgcmV0dXJuIGRlaGFuY2VkVmFsdWVzW2Z1bmNOYW1lXS5hcHBseShkZWhhbmNlZFZhbHVlcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbnZhciBpc09ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvblwiLCBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbik7XG5mdW5jdGlvbiBpc09ic2VydmFibGVBcnJheSh0aGluZykge1xuICByZXR1cm4gaXNPYmplY3QodGhpbmcpICYmIGlzT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24odGhpbmdbJG1vYnhdKTtcbn1cblxudmFyIF9TeW1ib2wkaXRlcmF0b3IsIF9TeW1ib2wkdG9TdHJpbmdUYWc7XG52YXIgT2JzZXJ2YWJsZU1hcE1hcmtlciA9IHt9O1xudmFyIEFERCA9IFwiYWRkXCI7XG52YXIgREVMRVRFID0gXCJkZWxldGVcIjtcbi8vIGp1c3QgZXh0ZW5kIE1hcD8gU2VlIGFsc28gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbmVzdGhhcnVzLzEzYjRkNzRmMmVmNGEyZjQzNTdkYmQzZmMyM2MxZTU0XG4vLyBCdXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9pc3N1ZXMvMTU1NlxuX1N5bWJvbCRpdGVyYXRvciA9IFN5bWJvbC5pdGVyYXRvcjtcbl9TeW1ib2wkdG9TdHJpbmdUYWcgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG52YXIgT2JzZXJ2YWJsZU1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIGhhc01hcCwgbm90IGhhc2hNYXAgPi0pLlxuXG4gIGZ1bmN0aW9uIE9ic2VydmFibGVNYXAoaW5pdGlhbERhdGEsIGVuaGFuY2VyXywgbmFtZV8pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChlbmhhbmNlcl8gPT09IHZvaWQgMCkge1xuICAgICAgZW5oYW5jZXJfID0gZGVlcEVuaGFuY2VyO1xuICAgIH1cbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk9ic2VydmFibGVNYXBAXCIgKyBnZXROZXh0SWQoKSA6IFwiT2JzZXJ2YWJsZU1hcFwiO1xuICAgIH1cbiAgICB0aGlzLmVuaGFuY2VyXyA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXNbJG1vYnhdID0gT2JzZXJ2YWJsZU1hcE1hcmtlcjtcbiAgICB0aGlzLmRhdGFfID0gdm9pZCAwO1xuICAgIHRoaXMuaGFzTWFwXyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleXNBdG9tXyA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmhhbmNlcl8gPSBlbmhhbmNlcl87XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgIGlmICghaXNGdW5jdGlvbihNYXApKSB7XG4gICAgICBkaWUoMTgpO1xuICAgIH1cbiAgICB0aGlzLmtleXNBdG9tXyA9IGNyZWF0ZUF0b20ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLmtleXMoKVwiIDogXCJPYnNlcnZhYmxlTWFwLmtleXMoKVwiKTtcbiAgICB0aGlzLmRhdGFfID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuaGFzTWFwXyA9IG5ldyBNYXAoKTtcbiAgICBhbGxvd1N0YXRlQ2hhbmdlcyh0cnVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5tZXJnZShpbml0aWFsRGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgdmFyIF9wcm90byA9IE9ic2VydmFibGVNYXAucHJvdG90eXBlO1xuICBfcHJvdG8uaGFzXyA9IGZ1bmN0aW9uIGhhc18oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YV8uaGFzKGtleSk7XG4gIH07XG4gIF9wcm90by5oYXMgPSBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgaWYgKCFnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc18oa2V5KTtcbiAgICB9XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5oYXNNYXBfLmdldChrZXkpO1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHZhciBuZXdFbnRyeSA9IGVudHJ5ID0gbmV3IE9ic2VydmFibGVWYWx1ZSh0aGlzLmhhc18oa2V5KSwgcmVmZXJlbmNlRW5oYW5jZXIsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi5cIiArIHN0cmluZ2lmeUtleShrZXkpICsgXCI/XCIgOiBcIk9ic2VydmFibGVNYXAua2V5P1wiLCBmYWxzZSk7XG4gICAgICB0aGlzLmhhc01hcF8uc2V0KGtleSwgbmV3RW50cnkpO1xuICAgICAgb25CZWNvbWVVbm9ic2VydmVkKG5ld0VudHJ5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuaGFzTWFwX1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS5nZXQoKTtcbiAgfTtcbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGhhc0tleSA9IHRoaXMuaGFzXyhrZXkpO1xuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICB0eXBlOiBoYXNLZXkgPyBVUERBVEUgOiBBREQsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgbmV3VmFsdWU6IHZhbHVlLFxuICAgICAgICBuYW1lOiBrZXlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGhhc0tleSkge1xuICAgICAgdGhpcy51cGRhdGVWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkVmFsdWVfKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmtleXNBdG9tXyk7XG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuYW1lOiBrZXlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5oYXNfKGtleSkpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgX2NoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm1hcFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogdGhpcy5kYXRhXy5nZXQoa2V5KS52YWx1ZV8sXG4gICAgICAgIG5hbWU6IGtleVxuICAgICAgfSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRTdGFydChfY2hhbmdlKTtcbiAgICAgIH0gLy8gVE9ETyBmaXggdHlwZVxuICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMzJGhhc01hcF8kZ2V0O1xuICAgICAgICBfdGhpczMua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICAgICAgKF90aGlzMyRoYXNNYXBfJGdldCA9IF90aGlzMy5oYXNNYXBfLmdldChrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMzJGhhc01hcF8kZ2V0LnNldE5ld1ZhbHVlXyhmYWxzZSk7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gX3RoaXMzLmRhdGFfLmdldChrZXkpO1xuICAgICAgICBvYnNlcnZhYmxlLnNldE5ld1ZhbHVlXyh1bmRlZmluZWQpO1xuICAgICAgICBfdGhpczMuZGF0YV9bXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIF9wcm90by51cGRhdGVWYWx1ZV8gPSBmdW5jdGlvbiB1cGRhdGVWYWx1ZV8oa2V5LCBuZXdWYWx1ZSkge1xuICAgIHZhciBvYnNlcnZhYmxlID0gdGhpcy5kYXRhXy5nZXQoa2V5KTtcbiAgICBuZXdWYWx1ZSA9IG9ic2VydmFibGUucHJlcGFyZU5ld1ZhbHVlXyhuZXdWYWx1ZSk7XG4gICAgaWYgKG5ld1ZhbHVlICE9PSBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwibWFwXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG9sZFZhbHVlOiBvYnNlcnZhYmxlLnZhbHVlXyxcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH0gOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICAgIH0gLy8gVE9ETyBmaXggdHlwZVxuICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmFkZFZhbHVlXyA9IGZ1bmN0aW9uIGFkZFZhbHVlXyhrZXksIG5ld1ZhbHVlKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5rZXlzQXRvbV8pO1xuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpczQkaGFzTWFwXyRnZXQ7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlVmFsdWUobmV3VmFsdWUsIF90aGlzNC5lbmhhbmNlcl8sIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IF90aGlzNC5uYW1lXyArIFwiLlwiICsgc3RyaW5naWZ5S2V5KGtleSkgOiBcIk9ic2VydmFibGVNYXAua2V5XCIsIGZhbHNlKTtcbiAgICAgIF90aGlzNC5kYXRhXy5zZXQoa2V5LCBvYnNlcnZhYmxlKTtcbiAgICAgIG5ld1ZhbHVlID0gb2JzZXJ2YWJsZS52YWx1ZV87IC8vIHZhbHVlIG1pZ2h0IGhhdmUgYmVlbiBjaGFuZ2VkXG4gICAgICAoX3RoaXM0JGhhc01hcF8kZ2V0ID0gX3RoaXM0Lmhhc01hcF8uZ2V0KGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpczQkaGFzTWFwXyRnZXQuc2V0TmV3VmFsdWVfKHRydWUpO1xuICAgICAgX3RoaXM0LmtleXNBdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG4gICAgfSk7XG4gICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJtYXBcIixcbiAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgIHR5cGU6IEFERCxcbiAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgIG5hbWU6IGtleSxcbiAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgIH0gOiBudWxsO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgIH0gLy8gVE9ETyBmaXggdHlwZVxuICAgIGlmIChub3RpZnkpIHtcbiAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWVfKHRoaXMuZGF0YV8uZ2V0KGtleSkuZ2V0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWVfKHVuZGVmaW5lZCk7XG4gIH07XG4gIF9wcm90by5kZWhhbmNlVmFsdWVfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlXyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICBfcHJvdG8ua2V5cyA9IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5kYXRhXy5rZXlzKCk7XG4gIH07XG4gIF9wcm90by52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBrZXlzID0gdGhpcy5rZXlzKCk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgX2tleXMkbmV4dCA9IGtleXMubmV4dCgpLFxuICAgICAgICAgIGRvbmUgPSBfa2V5cyRuZXh0LmRvbmUsXG4gICAgICAgICAgdmFsdWUgPSBfa2V5cyRuZXh0LnZhbHVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGRvbmUsXG4gICAgICAgICAgdmFsdWU6IGRvbmUgPyB1bmRlZmluZWQgOiBzZWxmLmdldCh2YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIga2V5cyA9IHRoaXMua2V5cygpO1xuICAgIHJldHVybiBtYWtlSXRlcmFibGUoe1xuICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIF9rZXlzJG5leHQyID0ga2V5cy5uZXh0KCksXG4gICAgICAgICAgZG9uZSA9IF9rZXlzJG5leHQyLmRvbmUsXG4gICAgICAgICAgdmFsdWUgPSBfa2V5cyRuZXh0Mi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBkb25lLFxuICAgICAgICAgIHZhbHVlOiBkb25lID8gdW5kZWZpbmVkIDogW3ZhbHVlLCBzZWxmLmdldCh2YWx1ZSldXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIF9wcm90b1tfU3ltYm9sJGl0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH07XG4gIF9wcm90by5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodGhpcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc3RlcC52YWx1ZSxcbiAgICAgICAga2V5ID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgIHZhbHVlID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKiogTWVyZ2UgYW5vdGhlciBvYmplY3QgaW50byB0aGlzIG9iamVjdCwgcmV0dXJucyB0aGlzLiAqLztcbiAgX3Byb3RvLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2Uob3RoZXIpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKG90aGVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgTWFwKG90aGVyKTtcbiAgICB9XG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3Qob3RoZXIpKSB7XG4gICAgICAgIGdldFBsYWluT2JqZWN0S2V5cyhvdGhlcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNS5zZXQoa2V5LCBvdGhlcltrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3RoZXIpKSB7XG4gICAgICAgIG90aGVyLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIga2V5ID0gX3JlZlswXSxcbiAgICAgICAgICAgIHZhbHVlID0gX3JlZlsxXTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM1LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRVM2TWFwKG90aGVyKSkge1xuICAgICAgICBpZiAob3RoZXIuY29uc3RydWN0b3IgIT09IE1hcCkge1xuICAgICAgICAgIGRpZSgxOSwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM1LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG90aGVyICE9PSBudWxsICYmIG90aGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGllKDIwLCBvdGhlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHVudHJhY2tlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKF90aGlzNi5rZXlzKCkpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgX3RoaXM2W1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8ucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UodmFsdWVzKSB7XG4gICAgdmFyIF90aGlzNyA9IHRoaXM7XG4gICAgLy8gSW1wbGVtZW50YXRpb24gcmVxdWlyZW1lbnRzOlxuICAgIC8vIC0gcmVzcGVjdCBvcmRlcmluZyBvZiByZXBsYWNlbWVudCBtYXBcbiAgICAvLyAtIGFsbG93IGludGVyY2VwdG9ycyB0byBydW4gYW5kIHBvdGVudGlhbGx5IHByZXZlbnQgaW5kaXZpZHVhbCBvcGVyYXRpb25zXG4gICAgLy8gLSBkb24ndCByZWNyZWF0ZSBvYnNlcnZhYmxlcyB0aGF0IGFscmVhZHkgZXhpc3QgaW4gb3JpZ2luYWwgbWFwIChzbyB3ZSBkb24ndCBkZXN0cm95IGV4aXN0aW5nIHN1YnNjcmlwdGlvbnMpXG4gICAgLy8gLSBkb24ndCBfa2V5c0F0b20ucmVwb3J0Q2hhbmdlZCBpZiB0aGUga2V5cyBvZiByZXN1bHRpbmcgbWFwIGFyZSBpbmRlbnRpY2FsIChvcmRlciBtYXR0ZXJzISlcbiAgICAvLyAtIG5vdGUgdGhhdCByZXN1bHQgbWFwIG1heSBkaWZmZXIgZnJvbSByZXBsYWNlbWVudCBtYXAgZHVlIHRvIHRoZSBpbnRlcmNlcHRvcnNcbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDb252ZXJ0IHRvIG1hcCBzbyB3ZSBjYW4gZG8gcXVpY2sga2V5IGxvb2t1cHNcbiAgICAgIHZhciByZXBsYWNlbWVudE1hcCA9IGNvbnZlcnRUb01hcCh2YWx1ZXMpO1xuICAgICAgdmFyIG9yZGVyZWREYXRhID0gbmV3IE1hcCgpO1xuICAgICAgLy8gVXNlZCBmb3Igb3B0aW1pemF0aW9uXG4gICAgICB2YXIga2V5c1JlcG9ydENoYW5nZWRDYWxsZWQgPSBmYWxzZTtcbiAgICAgIC8vIERlbGV0ZSBrZXlzIHRoYXQgZG9uJ3QgZXhpc3QgaW4gcmVwbGFjZW1lbnQgbWFwXG4gICAgICAvLyBpZiB0aGUga2V5IGRlbGV0aW9uIGlzIHByZXZlbnRlZCBieSBpbnRlcmNlcHRvclxuICAgICAgLy8gYWRkIGVudHJ5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlc3VsdCBtYXBcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKF90aGlzNy5kYXRhXy5rZXlzKCkpLCBfc3RlcDM7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMygpKS5kb25lOykge1xuICAgICAgICB2YXIga2V5ID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAvLyBDb25jdXJyZW50bHkgaXRlcmF0aW5nL2RlbGV0aW5nIGtleXNcbiAgICAgICAgLy8gaXRlcmF0b3Igc2hvdWxkIGhhbmRsZSB0aGlzIGNvcnJlY3RseVxuICAgICAgICBpZiAoIXJlcGxhY2VtZW50TWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgdmFyIGRlbGV0ZWQgPSBfdGhpczdbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgICAgICAvLyBXYXMgdGhlIGtleSByZW1vdmVkP1xuICAgICAgICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgICAgICAvLyBfa2V5c0F0b20ucmVwb3J0Q2hhbmdlZCgpIHdhcyBhbHJlYWR5IGNhbGxlZFxuICAgICAgICAgICAga2V5c1JlcG9ydENoYW5nZWRDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWxldGUgcHJldmVudGVkIGJ5IGludGVyY2VwdG9yXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpczcuZGF0YV8uZ2V0KGtleSk7XG4gICAgICAgICAgICBvcmRlcmVkRGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBNZXJnZSBlbnRyaWVzXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShyZXBsYWNlbWVudE1hcC5lbnRyaWVzKCkpLCBfc3RlcDQ7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNCgpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXA0JHZhbHVlID0gX3N0ZXA0LnZhbHVlLFxuICAgICAgICAgIF9rZXkgPSBfc3RlcDQkdmFsdWVbMF0sXG4gICAgICAgICAgX3ZhbHVlID0gX3N0ZXA0JHZhbHVlWzFdO1xuICAgICAgICAvLyBXZSB3aWxsIHdhbnQgdG8ga25vdyB3aGV0aGVyIGEgbmV3IGtleSBpcyBhZGRlZFxuICAgICAgICB2YXIga2V5RXhpc3RlZCA9IF90aGlzNy5kYXRhXy5oYXMoX2tleSk7XG4gICAgICAgIC8vIEFkZCBvciB1cGRhdGUgdmFsdWVcbiAgICAgICAgX3RoaXM3LnNldChfa2V5LCBfdmFsdWUpO1xuICAgICAgICAvLyBUaGUgYWRkaXRpb24gY291bGQgaGF2ZSBiZWVuIHByZXZlbnQgYnkgaW50ZXJjZXB0b3JcbiAgICAgICAgaWYgKF90aGlzNy5kYXRhXy5oYXMoX2tleSkpIHtcbiAgICAgICAgICAvLyBUaGUgdXBkYXRlIGNvdWxkIGhhdmUgYmVlbiBwcmV2ZW50ZWQgYnkgaW50ZXJjZXB0b3JcbiAgICAgICAgICAvLyBhbmQgYWxzbyB3ZSB3YW50IHRvIHByZXNlcnZlIGV4aXN0aW5nIHZhbHVlc1xuICAgICAgICAgIC8vIHNvIHVzZSB2YWx1ZSBmcm9tIF9kYXRhIG1hcCAoaW5zdGVhZCBvZiByZXBsYWNlbWVudCBtYXApXG4gICAgICAgICAgdmFyIF92YWx1ZTIgPSBfdGhpczcuZGF0YV8uZ2V0KF9rZXkpO1xuICAgICAgICAgIG9yZGVyZWREYXRhLnNldChfa2V5LCBfdmFsdWUyKTtcbiAgICAgICAgICAvLyBXYXMgYSBuZXcga2V5IGFkZGVkP1xuICAgICAgICAgIGlmICgha2V5RXhpc3RlZCkge1xuICAgICAgICAgICAgLy8gX2tleXNBdG9tLnJlcG9ydENoYW5nZWQoKSB3YXMgYWxyZWFkeSBjYWxsZWRcbiAgICAgICAgICAgIGtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGZvciBwb3NzaWJsZSBrZXkgb3JkZXIgY2hhbmdlXG4gICAgICBpZiAoIWtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkKSB7XG4gICAgICAgIGlmIChfdGhpczcuZGF0YV8uc2l6ZSAhPT0gb3JkZXJlZERhdGEuc2l6ZSkge1xuICAgICAgICAgIC8vIElmIHNpemUgZGlmZmVycywga2V5cyBhcmUgZGVmaW5pdGVseSBtb2RpZmllZFxuICAgICAgICAgIF90aGlzNy5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpdGVyMSA9IF90aGlzNy5kYXRhXy5rZXlzKCk7XG4gICAgICAgICAgdmFyIGl0ZXIyID0gb3JkZXJlZERhdGEua2V5cygpO1xuICAgICAgICAgIHZhciBuZXh0MSA9IGl0ZXIxLm5leHQoKTtcbiAgICAgICAgICB2YXIgbmV4dDIgPSBpdGVyMi5uZXh0KCk7XG4gICAgICAgICAgd2hpbGUgKCFuZXh0MS5kb25lKSB7XG4gICAgICAgICAgICBpZiAobmV4dDEudmFsdWUgIT09IG5leHQyLnZhbHVlKSB7XG4gICAgICAgICAgICAgIF90aGlzNy5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQxID0gaXRlcjEubmV4dCgpO1xuICAgICAgICAgICAgbmV4dDIgPSBpdGVyMi5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBVc2UgY29ycmVjdGx5IG9yZGVyZWQgbWFwXG4gICAgICBfdGhpczcuZGF0YV8gPSBvcmRlcmVkRGF0YTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBPYnNlcnZhYmxlTWFwXVwiO1xuICB9O1xuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMpO1xuICB9O1xuICAvKipcclxuICAgKiBPYnNlcnZlcyB0aGlzIG9iamVjdC4gVHJpZ2dlcnMgZm9yIHRoZSBldmVudHMgJ2FkZCcsICd1cGRhdGUnIGFuZCAnZGVsZXRlJy5cclxuICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9vYnNlcnZlXHJcbiAgICogZm9yIGNhbGxiYWNrIGRldGFpbHNcclxuICAgKi9cbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmlyZUltbWVkaWF0ZWx5ID09PSB0cnVlKSB7XG4gICAgICBkaWUoXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IGZpcmVJbW1lZGlhdGVseT10cnVlIGluIGNvbWJpbmF0aW9uIHdpdGggbWFwcy5cIik7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmFibGVNYXAsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXy5zaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCR0b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcIk1hcFwiO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gT2JzZXJ2YWJsZU1hcDtcbn0oKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxudmFyIGlzT2JzZXJ2YWJsZU1hcCA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZU1hcFwiLCBPYnNlcnZhYmxlTWFwKTtcbmZ1bmN0aW9uIGNvbnZlcnRUb01hcChkYXRhU3RydWN0dXJlKSB7XG4gIGlmIChpc0VTNk1hcChkYXRhU3RydWN0dXJlKSB8fCBpc09ic2VydmFibGVNYXAoZGF0YVN0cnVjdHVyZSkpIHtcbiAgICByZXR1cm4gZGF0YVN0cnVjdHVyZTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGFTdHJ1Y3R1cmUpKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoZGF0YVN0cnVjdHVyZSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChkYXRhU3RydWN0dXJlKSkge1xuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGFTdHJ1Y3R1cmUpIHtcbiAgICAgIG1hcC5zZXQoa2V5LCBkYXRhU3RydWN0dXJlW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkaWUoMjEsIGRhdGFTdHJ1Y3R1cmUpO1xuICB9XG59XG5cbnZhciBfU3ltYm9sJGl0ZXJhdG9yJDEsIF9TeW1ib2wkdG9TdHJpbmdUYWckMTtcbnZhciBPYnNlcnZhYmxlU2V0TWFya2VyID0ge307XG5fU3ltYm9sJGl0ZXJhdG9yJDEgPSBTeW1ib2wuaXRlcmF0b3I7XG5fU3ltYm9sJHRvU3RyaW5nVGFnJDEgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG52YXIgT2JzZXJ2YWJsZVNldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGVTZXQoaW5pdGlhbERhdGEsIGVuaGFuY2VyLCBuYW1lXykge1xuICAgIGlmIChlbmhhbmNlciA9PT0gdm9pZCAwKSB7XG4gICAgICBlbmhhbmNlciA9IGRlZXBFbmhhbmNlcjtcbiAgICB9XG4gICAgaWYgKG5hbWVfID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWVfID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJPYnNlcnZhYmxlU2V0QFwiICsgZ2V0TmV4dElkKCkgOiBcIk9ic2VydmFibGVTZXRcIjtcbiAgICB9XG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzWyRtb2J4XSA9IE9ic2VydmFibGVTZXRNYXJrZXI7XG4gICAgdGhpcy5kYXRhXyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmF0b21fID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWhhbmNlciA9IHZvaWQgMDtcbiAgICB0aGlzLmVuaGFuY2VyXyA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWVfID0gbmFtZV87XG4gICAgaWYgKCFpc0Z1bmN0aW9uKFNldCkpIHtcbiAgICAgIGRpZSgyMik7XG4gICAgfVxuICAgIHRoaXMuYXRvbV8gPSBjcmVhdGVBdG9tKHRoaXMubmFtZV8pO1xuICAgIHRoaXMuZW5oYW5jZXJfID0gZnVuY3Rpb24gKG5ld1YsIG9sZFYpIHtcbiAgICAgIHJldHVybiBlbmhhbmNlcihuZXdWLCBvbGRWLCBuYW1lXyk7XG4gICAgfTtcbiAgICBpZiAoaW5pdGlhbERhdGEpIHtcbiAgICAgIHRoaXMucmVwbGFjZShpbml0aWFsRGF0YSk7XG4gICAgfVxuICB9XG4gIHZhciBfcHJvdG8gPSBPYnNlcnZhYmxlU2V0LnByb3RvdHlwZTtcbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZV8gPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWVfKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgdW50cmFja2VkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShfdGhpcy5kYXRhXy52YWx1ZXMoKSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgX3RoaXNbXCJkZWxldGVcIl0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrRm4sIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0aGlzKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICAgIHZhciB2YWx1ZSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgIGNhbGxiYWNrRm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwgdmFsdWUsIHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMuYXRvbV8pO1xuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgbmV3VmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLy8gaWRlYWxseSwgdmFsdWUgPSBjaGFuZ2UudmFsdWUgd291bGQgYmUgZG9uZSBoZXJlLCBzbyB0aGF0IHZhbHVlcyBjYW4gYmVcbiAgICAgIC8vIGNoYW5nZWQgYnkgaW50ZXJjZXB0b3IuIFNhbWUgYXBwbGllcyBmb3Igb3RoZXIgU2V0IGFuZCBNYXAgYXBpJ3MuXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmRhdGFfLmFkZChfdGhpczIuZW5oYW5jZXJfKHZhbHVlLCB1bmRlZmluZWQpKTtcbiAgICAgICAgX3RoaXMyLmF0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG5vdGlmeVNweSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgX2NoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInNldFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuZXdWYWx1ZTogdmFsdWVcbiAgICAgIH0gOiBudWxsO1xuICAgICAgaWYgKG5vdGlmeVNweSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAobm90aWZ5KSB7XG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBfY2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChub3RpZnlTcHkgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gX2RlbGV0ZSh2YWx1ZSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICB0eXBlOiBERUxFVEUsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgb2xkVmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgdmFyIG5vdGlmeVNweSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgX2NoYW5nZTIgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJzZXRcIixcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICB0eXBlOiBERUxFVEUsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgb2xkVmFsdWU6IHZhbHVlXG4gICAgICB9IDogbnVsbDtcbiAgICAgIGlmIChub3RpZnlTcHkgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UyKTtcbiAgICAgIH1cbiAgICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLmF0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICAgICAgX3RoaXMzLmRhdGFfW1wiZGVsZXRlXCJdKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZTIpO1xuICAgICAgfVxuICAgICAgaWYgKG5vdGlmeVNweSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfcHJvdG8uaGFzID0gZnVuY3Rpb24gaGFzKHZhbHVlKSB7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiB0aGlzLmRhdGFfLmhhcyh0aGlzLmRlaGFuY2VWYWx1ZV8odmFsdWUpKTtcbiAgfTtcbiAgX3Byb3RvLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgIHZhciBrZXlzID0gQXJyYXkuZnJvbSh0aGlzLmtleXMoKSk7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5LmZyb20odGhpcy52YWx1ZXMoKSk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIG5leHRJbmRleCArPSAxO1xuICAgICAgICByZXR1cm4gaW5kZXggPCB2YWx1ZXMubGVuZ3RoID8ge1xuICAgICAgICAgIHZhbHVlOiBba2V5c1tpbmRleF0sIHZhbHVlc1tpbmRleF1dLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBfcHJvdG8ua2V5cyA9IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gIH07XG4gIF9wcm90by52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICB2YXIgb2JzZXJ2YWJsZVZhbHVlcyA9IEFycmF5LmZyb20odGhpcy5kYXRhXy52YWx1ZXMoKSk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICByZXR1cm4gbmV4dEluZGV4IDwgb2JzZXJ2YWJsZVZhbHVlcy5sZW5ndGggPyB7XG4gICAgICAgICAgdmFsdWU6IHNlbGYuZGVoYW5jZVZhbHVlXyhvYnNlcnZhYmxlVmFsdWVzW25leHRJbmRleCsrXSksXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShvdGhlcikge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgIGlmIChpc09ic2VydmFibGVTZXQob3RoZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZXQob3RoZXIpO1xuICAgIH1cbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvdGhlcikpIHtcbiAgICAgICAgX3RoaXM0LmNsZWFyKCk7XG4gICAgICAgIG90aGVyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5hZGQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNFUzZTZXQob3RoZXIpKSB7XG4gICAgICAgIF90aGlzNC5jbGVhcigpO1xuICAgICAgICBvdGhlci5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQuYWRkKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG90aGVyICE9PSBudWxsICYmIG90aGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGllKFwiQ2Fubm90IGluaXRpYWxpemUgc2V0IGZyb20gXCIgKyBvdGhlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAvLyAuLi4gJ2ZpcmVJbW1lZGlhdGVseScgY291bGQgYWxzbyBiZSB0cnVlP1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmlyZUltbWVkaWF0ZWx5ID09PSB0cnVlKSB7XG4gICAgICBkaWUoXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IGZpcmVJbW1lZGlhdGVseT10cnVlIGluIGNvbWJpbmF0aW9uIHdpdGggc2V0cy5cIik7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBPYnNlcnZhYmxlU2V0XVwiO1xuICB9O1xuICBfcHJvdG9bX1N5bWJvbCRpdGVyYXRvciQxXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgfTtcbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmFibGVTZXQsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnJDEsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJTZXRcIjtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE9ic2VydmFibGVTZXQ7XG59KCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbnZhciBpc09ic2VydmFibGVTZXQgPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVTZXRcIiwgT2JzZXJ2YWJsZVNldCk7XG5cbnZhciBkZXNjcmlwdG9yQ2FjaGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBSRU1PVkUgPSBcInJlbW92ZVwiO1xudmFyIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbih0YXJnZXRfLCB2YWx1ZXNfLCBuYW1lXyxcbiAgLy8gVXNlZCBhbnl0aW1lIGFubm90YXRpb24gaXMgbm90IGV4cGxpY2l0ZWx5IHByb3ZpZGVkXG4gIGRlZmF1bHRBbm5vdGF0aW9uXykge1xuICAgIGlmICh2YWx1ZXNfID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlc18gPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0QW5ub3RhdGlvbl8gPT09IHZvaWQgMCkge1xuICAgICAgZGVmYXVsdEFubm90YXRpb25fID0gYXV0b0Fubm90YXRpb247XG4gICAgfVxuICAgIHRoaXMudGFyZ2V0XyA9IHZvaWQgMDtcbiAgICB0aGlzLnZhbHVlc18gPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleXNBdG9tXyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18gPSB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnNfID0gdm9pZCAwO1xuICAgIHRoaXMucHJveHlfID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQbGFpbk9iamVjdF8gPSB2b2lkIDA7XG4gICAgdGhpcy5hcHBsaWVkQW5ub3RhdGlvbnNfID0gdm9pZCAwO1xuICAgIHRoaXMucGVuZGluZ0tleXNfID0gdm9pZCAwO1xuICAgIHRoaXMudGFyZ2V0XyA9IHRhcmdldF87XG4gICAgdGhpcy52YWx1ZXNfID0gdmFsdWVzXztcbiAgICB0aGlzLm5hbWVfID0gbmFtZV87XG4gICAgdGhpcy5kZWZhdWx0QW5ub3RhdGlvbl8gPSBkZWZhdWx0QW5ub3RhdGlvbl87XG4gICAgdGhpcy5rZXlzQXRvbV8gPSBuZXcgQXRvbShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB0aGlzLm5hbWVfICsgXCIua2V5c1wiIDogXCJPYnNlcnZhYmxlT2JqZWN0LmtleXNcIik7XG4gICAgLy8gT3B0aW1pemF0aW9uOiB3ZSB1c2UgdGhpcyBmcmVxdWVudGx5XG4gICAgdGhpcy5pc1BsYWluT2JqZWN0XyA9IGlzUGxhaW5PYmplY3QodGhpcy50YXJnZXRfKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc0Fubm90YXRpb24odGhpcy5kZWZhdWx0QW5ub3RhdGlvbl8pKSB7XG4gICAgICBkaWUoXCJkZWZhdWx0QW5ub3RhdGlvbiBtdXN0IGJlIHZhbGlkIGFubm90YXRpb25cIik7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIC8vIFByZXBhcmUgc3RydWN0dXJlIGZvciB0cmFja2luZyB3aGljaCBmaWVsZHMgd2VyZSBhbHJlYWR5IGFubm90YXRlZFxuICAgICAgdGhpcy5hcHBsaWVkQW5ub3RhdGlvbnNfID0ge307XG4gICAgfVxuICB9XG4gIHZhciBfcHJvdG8gPSBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlO1xuICBfcHJvdG8uZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8gPSBmdW5jdGlvbiBnZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNfLmdldChrZXkpLmdldCgpO1xuICB9O1xuICBfcHJvdG8uc2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8gPSBmdW5jdGlvbiBzZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXksIG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLnZhbHVlc18uZ2V0KGtleSk7XG4gICAgaWYgKG9ic2VydmFibGUgaW5zdGFuY2VvZiBDb21wdXRlZFZhbHVlKSB7XG4gICAgICBvYnNlcnZhYmxlLnNldChuZXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaW50ZXJjZXB0XG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgfVxuICAgIG5ld1ZhbHVlID0gb2JzZXJ2YWJsZS5wcmVwYXJlTmV3VmFsdWVfKG5ld1ZhbHVlKTtcbiAgICAvLyBub3RpZnkgc3B5ICYgb2JzZXJ2ZXJzXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQpIHtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIF9jaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm9iamVjdFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBvbGRWYWx1ZTogb2JzZXJ2YWJsZS52YWx1ZV8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9IDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UpO1xuICAgICAgfVxuICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9wcm90by5nZXRfID0gZnVuY3Rpb24gZ2V0XyhrZXkpIHtcbiAgICBpZiAoZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uICYmICFoYXNQcm9wKHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgLy8gS2V5IGRvZXNuJ3QgZXhpc3QgeWV0LCBzdWJzY3JpYmUgZm9yIGl0IGluIGNhc2UgaXQncyBhZGRlZCBsYXRlclxuICAgICAgdGhpcy5oYXNfKGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhcmdldF9ba2V5XTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBrZXlcclxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcclxuICAgKiBAcGFyYW0ge0Fubm90YXRpb258Ym9vbGVhbn0gYW5ub3RhdGlvbiB0cnVlIC0gdXNlIGRlZmF1bHQgYW5ub3RhdGlvbiwgZmFsc2UgLSBjb3B5IGFzIGlzXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBwcm94eVRyYXAgd2hldGhlciBpdCdzIGNhbGxlZCBmcm9tIHByb3h5IHRyYXBcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxudWxsfSB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUgKHByb3h5VHJhcCArIG5vbi1jb25maWd1cmFibGUpLCBudWxsIHdoZW4gY2FuY2VsbGVkIGJ5IGludGVyY2VwdG9yXHJcbiAgICovO1xuICBfcHJvdG8uc2V0XyA9IGZ1bmN0aW9uIHNldF8oa2V5LCB2YWx1ZSwgcHJveHlUcmFwKSB7XG4gICAgaWYgKHByb3h5VHJhcCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm94eVRyYXAgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgdXNlIC5oYXMoa2V5KSAtIHdlIGNhcmUgYWJvdXQgb3duXG4gICAgaWYgKGhhc1Byb3AodGhpcy50YXJnZXRfLCBrZXkpKSB7XG4gICAgICAvLyBFeGlzdGluZyBwcm9wXG4gICAgICBpZiAodGhpcy52YWx1ZXNfLmhhcyhrZXkpKSB7XG4gICAgICAgIC8vIE9ic2VydmFibGUgKGNhbiBiZSBpbnRlcmNlcHRlZClcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICAvLyBOb24tb2JzZXJ2YWJsZSAtIHByb3h5XG4gICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0aGlzLnRhcmdldF8sIGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9uLW9ic2VydmFibGVcbiAgICAgICAgdGhpcy50YXJnZXRfW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5ldyBwcm9wXG4gICAgICByZXR1cm4gdGhpcy5leHRlbmRfKGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0sIHRoaXMuZGVmYXVsdEFubm90YXRpb25fLCBwcm94eVRyYXApO1xuICAgIH1cbiAgfVxuICAvLyBUcmFwIGZvciBcImluXCJcbiAgO1xuICBfcHJvdG8uaGFzXyA9IGZ1bmN0aW9uIGhhc18oa2V5KSB7XG4gICAgaWYgKCFnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIC8vIFNraXAga2V5IHN1YnNjcmlwdGlvbiBvdXRzaWRlIGRlcml2YXRpb25cbiAgICAgIHJldHVybiBrZXkgaW4gdGhpcy50YXJnZXRfO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdLZXlzXyB8fCAodGhpcy5wZW5kaW5nS2V5c18gPSBuZXcgTWFwKCkpO1xuICAgIHZhciBlbnRyeSA9IHRoaXMucGVuZGluZ0tleXNfLmdldChrZXkpO1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIGVudHJ5ID0gbmV3IE9ic2VydmFibGVWYWx1ZShrZXkgaW4gdGhpcy50YXJnZXRfLCByZWZlcmVuY2VFbmhhbmNlciwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLlwiICsgc3RyaW5naWZ5S2V5KGtleSkgKyBcIj9cIiA6IFwiT2JzZXJ2YWJsZU9iamVjdC5rZXk/XCIsIGZhbHNlKTtcbiAgICAgIHRoaXMucGVuZGluZ0tleXNfLnNldChrZXksIGVudHJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5LmdldCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxyXG4gICAqIEBwYXJhbSB7QW5ub3RhdGlvbnxib29sZWFufSBhbm5vdGF0aW9uIHRydWUgLSB1c2UgZGVmYXVsdCBhbm5vdGF0aW9uLCBmYWxzZSAtIGlnbm9yZSBwcm9wXHJcbiAgICovO1xuICBfcHJvdG8ubWFrZV8gPSBmdW5jdGlvbiBtYWtlXyhrZXksIGFubm90YXRpb24pIHtcbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgYW5ub3RhdGlvbiA9IHRoaXMuZGVmYXVsdEFubm90YXRpb25fO1xuICAgIH1cbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXNzZXJ0QW5ub3RhYmxlKHRoaXMsIGFubm90YXRpb24sIGtleSk7XG4gICAgaWYgKCEoa2V5IGluIHRoaXMudGFyZ2V0XykpIHtcbiAgICAgIHZhciBfdGhpcyR0YXJnZXRfJHN0b3JlZEE7XG4gICAgICAvLyBUaHJvdyBvbiBtaXNzaW5nIGtleSwgZXhjZXB0IGZvciBkZWNvcmF0b3JzOlxuICAgICAgLy8gRGVjb3JhdG9yIGFubm90YXRpb25zIGFyZSBjb2xsZWN0ZWQgZnJvbSB3aG9sZSBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAvLyBXaGVuIGNhbGxlZCBmcm9tIHN1cGVyKCkgc29tZSBwcm9wcyBtYXkgbm90IGV4aXN0IHlldC5cbiAgICAgIC8vIEhvd2V2ZXIgd2UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBtaXNzaW5nIHByb3AsXG4gICAgICAvLyBiZWNhdXNlIHRoZSBkZWNvcmF0b3IgbXVzdCBoYXZlIGJlZW4gYXBwbGllZCB0byBzb21ldGhpbmcuXG4gICAgICBpZiAoKF90aGlzJHRhcmdldF8kc3RvcmVkQSA9IHRoaXMudGFyZ2V0X1tzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pICE9IG51bGwgJiYgX3RoaXMkdGFyZ2V0XyRzdG9yZWRBW2tleV0pIHtcbiAgICAgICAgcmV0dXJuOyAvLyB3aWxsIGJlIGFubm90YXRlZCBieSBzdWJjbGFzcyBjb25zdHJ1Y3RvclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGllKDEsIGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfLCB0aGlzLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSB0aGlzLnRhcmdldF87XG4gICAgd2hpbGUgKHNvdXJjZSAmJiBzb3VyY2UgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXREZXNjcmlwdG9yKHNvdXJjZSwga2V5KTtcbiAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgIHZhciBvdXRjb21lID0gYW5ub3RhdGlvbi5tYWtlXyh0aGlzLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG4gICAgICAgIGlmIChvdXRjb21lID09PSAwIC8qIENhbmNlbCAqLykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0Y29tZSA9PT0gMSAvKiBCcmVhayAqLykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzb3VyY2UgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKTtcbiAgICB9XG4gICAgcmVjb3JkQW5ub3RhdGlvbkFwcGxpZWQodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBrZXlcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5RGVzY3JpcHRvcn0gZGVzY3JpcHRvclxyXG4gICAqIEBwYXJhbSB7QW5ub3RhdGlvbnxib29sZWFufSBhbm5vdGF0aW9uIHRydWUgLSB1c2UgZGVmYXVsdCBhbm5vdGF0aW9uLCBmYWxzZSAtIGNvcHkgYXMgaXNcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcclxuICAgKi87XG4gIF9wcm90by5leHRlbmRfID0gZnVuY3Rpb24gZXh0ZW5kXyhrZXksIGRlc2NyaXB0b3IsIGFubm90YXRpb24sIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhbm5vdGF0aW9uID09PSB0cnVlKSB7XG4gICAgICBhbm5vdGF0aW9uID0gdGhpcy5kZWZhdWx0QW5ub3RhdGlvbl87XG4gICAgfVxuICAgIGlmIChhbm5vdGF0aW9uID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmaW5lUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbiAgICB9XG4gICAgYXNzZXJ0QW5ub3RhYmxlKHRoaXMsIGFubm90YXRpb24sIGtleSk7XG4gICAgdmFyIG91dGNvbWUgPSBhbm5vdGF0aW9uLmV4dGVuZF8odGhpcywga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApO1xuICAgIGlmIChvdXRjb21lKSB7XG4gICAgICByZWNvcmRBbm5vdGF0aW9uQXBwbGllZCh0aGlzLCBhbm5vdGF0aW9uLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0Y29tZTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBrZXlcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5RGVzY3JpcHRvcn0gZGVzY3JpcHRvclxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJveHlUcmFwIHdoZXRoZXIgaXQncyBjYWxsZWQgZnJvbSBwcm94eSB0cmFwXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVsbH0gdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlIChwcm94eVRyYXAgKyBub24tY29uZmlndXJhYmxlKSwgbnVsbCB3aGVuIGNhbmNlbGxlZCBieSBpbnRlcmNlcHRvclxyXG4gICAqLztcbiAgX3Byb3RvLmRlZmluZVByb3BlcnR5XyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5XyhrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzdGFydEJhdGNoKCk7XG4gICAgICAvLyBEZWxldGVcbiAgICAgIHZhciBkZWxldGVPdXRjb21lID0gdGhpcy5kZWxldGVfKGtleSk7XG4gICAgICBpZiAoIWRlbGV0ZU91dGNvbWUpIHtcbiAgICAgICAgLy8gRmFpbHVyZSBvciBpbnRlcmNlcHRlZFxuICAgICAgICByZXR1cm4gZGVsZXRlT3V0Y29tZTtcbiAgICAgIH1cbiAgICAgIC8vIEFERCBpbnRlcmNlcHRvclxuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgdHlwZTogQURELFxuICAgICAgICAgIG5ld1ZhbHVlOiBkZXNjcmlwdG9yLnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgZGVzY3JpcHRvciA9IF9leHRlbmRzKHt9LCBkZXNjcmlwdG9yLCB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRGVmaW5lXG4gICAgICBpZiAocHJveHlUcmFwKSB7XG4gICAgICAgIGlmICghUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vdGlmeVxuICAgICAgdGhpcy5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyhrZXksIGRlc2NyaXB0b3IudmFsdWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBJZiBvcmlnaW5hbCBkZXNjcmlwdG9yIGJlY29tZXMgcmVsZXZhbnQsIG1vdmUgdGhpcyB0byBhbm5vdGF0aW9uIGRpcmVjdGx5XG4gIDtcbiAgX3Byb3RvLmRlZmluZU9ic2VydmFibGVQcm9wZXJ0eV8gPSBmdW5jdGlvbiBkZWZpbmVPYnNlcnZhYmxlUHJvcGVydHlfKGtleSwgdmFsdWUsIGVuaGFuY2VyLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgc3RhcnRCYXRjaCgpO1xuICAgICAgLy8gRGVsZXRlXG4gICAgICB2YXIgZGVsZXRlT3V0Y29tZSA9IHRoaXMuZGVsZXRlXyhrZXkpO1xuICAgICAgaWYgKCFkZWxldGVPdXRjb21lKSB7XG4gICAgICAgIC8vIEZhaWx1cmUgb3IgaW50ZXJjZXB0ZWRcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU91dGNvbWU7XG4gICAgICB9XG4gICAgICAvLyBBREQgaW50ZXJjZXB0b3JcbiAgICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgICBuZXdWYWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgY2FjaGVkRGVzY3JpcHRvciA9IGdldENhY2hlZE9ic2VydmFibGVQcm9wRGVzY3JpcHRvcihrZXkpO1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZ2xvYmFsU3RhdGUuc2FmZURlc2NyaXB0b3JzID8gdGhpcy5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogY2FjaGVkRGVzY3JpcHRvci5nZXQsXG4gICAgICAgIHNldDogY2FjaGVkRGVzY3JpcHRvci5zZXRcbiAgICAgIH07XG4gICAgICAvLyBEZWZpbmVcbiAgICAgIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgaWYgKCFSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKHZhbHVlLCBlbmhhbmNlciwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgOiBcIk9ic2VydmFibGVPYmplY3Qua2V5XCIsIGZhbHNlKTtcbiAgICAgIHRoaXMudmFsdWVzXy5zZXQoa2V5LCBvYnNlcnZhYmxlKTtcbiAgICAgIC8vIE5vdGlmeSAodmFsdWUgcG9zc2libHkgY2hhbmdlZCBieSBPYnNlcnZhYmxlVmFsdWUpXG4gICAgICB0aGlzLm5vdGlmeVByb3BlcnR5QWRkaXRpb25fKGtleSwgb2JzZXJ2YWJsZS52YWx1ZV8pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBJZiBvcmlnaW5hbCBkZXNjcmlwdG9yIGJlY29tZXMgcmVsZXZhbnQsIG1vdmUgdGhpcyB0byBhbm5vdGF0aW9uIGRpcmVjdGx5XG4gIDtcbiAgX3Byb3RvLmRlZmluZUNvbXB1dGVkUHJvcGVydHlfID0gZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eV8oa2V5LCBvcHRpb25zLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgc3RhcnRCYXRjaCgpO1xuICAgICAgLy8gRGVsZXRlXG4gICAgICB2YXIgZGVsZXRlT3V0Y29tZSA9IHRoaXMuZGVsZXRlXyhrZXkpO1xuICAgICAgaWYgKCFkZWxldGVPdXRjb21lKSB7XG4gICAgICAgIC8vIEZhaWx1cmUgb3IgaW50ZXJjZXB0ZWRcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU91dGNvbWU7XG4gICAgICB9XG4gICAgICAvLyBBREQgaW50ZXJjZXB0b3JcbiAgICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgICBuZXdWYWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcHRpb25zLm5hbWUgfHwgKG9wdGlvbnMubmFtZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpIDogXCJPYnNlcnZhYmxlT2JqZWN0LmtleVwiKTtcbiAgICAgIG9wdGlvbnMuY29udGV4dCA9IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XztcbiAgICAgIHZhciBjYWNoZWREZXNjcmlwdG9yID0gZ2V0Q2FjaGVkT2JzZXJ2YWJsZVByb3BEZXNjcmlwdG9yKGtleSk7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnMgPyB0aGlzLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogY2FjaGVkRGVzY3JpcHRvci5nZXQsXG4gICAgICAgIHNldDogY2FjaGVkRGVzY3JpcHRvci5zZXRcbiAgICAgIH07XG4gICAgICAvLyBEZWZpbmVcbiAgICAgIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgaWYgKCFSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuICAgICAgdGhpcy52YWx1ZXNfLnNldChrZXksIG5ldyBDb21wdXRlZFZhbHVlKG9wdGlvbnMpKTtcbiAgICAgIC8vIE5vdGlmeVxuICAgICAgdGhpcy5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyhrZXksIHVuZGVmaW5lZCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlEZXNjcmlwdG9yfSBkZXNjcmlwdG9yXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBwcm94eVRyYXAgd2hldGhlciBpdCdzIGNhbGxlZCBmcm9tIHByb3h5IHRyYXBcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxudWxsfSB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUgKHByb3h5VHJhcCArIG5vbi1jb25maWd1cmFibGUpLCBudWxsIHdoZW4gY2FuY2VsbGVkIGJ5IGludGVyY2VwdG9yXHJcbiAgICovO1xuICBfcHJvdG8uZGVsZXRlXyA9IGZ1bmN0aW9uIGRlbGV0ZV8oa2V5LCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBObyBzdWNoIHByb3BcbiAgICBpZiAoIWhhc1Byb3AodGhpcy50YXJnZXRfLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gSW50ZXJjZXB0XG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIHR5cGU6IFJFTU9WRVxuICAgICAgfSk7XG4gICAgICAvLyBDYW5jZWxsZWRcbiAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBEZWxldGVcbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzJHBlbmRpbmdLZXlzXywgX3RoaXMkcGVuZGluZ0tleXNfJGdlO1xuICAgICAgc3RhcnRCYXRjaCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTcHlFbmFibGVkKCk7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMudmFsdWVzXy5nZXQoa2V5KTtcbiAgICAgIC8vIFZhbHVlIG5lZWRlZCBmb3Igc3BpZXMvbGlzdGVuZXJzXG4gICAgICB2YXIgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAvLyBPcHRpbWl6YXRpb246IGRvbid0IHB1bGwgdGhlIHZhbHVlIHVubGVzcyB3ZSB3aWxsIG5lZWQgaXRcbiAgICAgIGlmICghb2JzZXJ2YWJsZSAmJiAobm90aWZ5IHx8IG5vdGlmeVNweSkpIHtcbiAgICAgICAgdmFyIF9nZXREZXNjcmlwdG9yO1xuICAgICAgICB2YWx1ZSA9IChfZ2V0RGVzY3JpcHRvciA9IGdldERlc2NyaXB0b3IodGhpcy50YXJnZXRfLCBrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX2dldERlc2NyaXB0b3IudmFsdWU7XG4gICAgICB9XG4gICAgICAvLyBkZWxldGUgcHJvcCAoZG8gZmlyc3QsIG1heSBmYWlsKVxuICAgICAgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICBpZiAoIVJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy50YXJnZXRfW2tleV07XG4gICAgICB9XG4gICAgICAvLyBBbGxvdyByZS1hbm5vdGF0aW5nIHRoaXMgZmllbGRcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXBwbGllZEFubm90YXRpb25zX1trZXldO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYXIgb2JzZXJ2YWJsZVxuICAgICAgaWYgKG9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNfW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICAgIC8vIGZvciBjb21wdXRlZCwgdmFsdWUgaXMgdW5kZWZpbmVkXG4gICAgICAgIGlmIChvYnNlcnZhYmxlIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVZhbHVlKSB7XG4gICAgICAgICAgdmFsdWUgPSBvYnNlcnZhYmxlLnZhbHVlXztcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RpZnk6IGF1dG9ydW4oKCkgPT4gb2JqW2tleV0pLCBzZWUgIzE3OTZcbiAgICAgICAgcHJvcGFnYXRlQ2hhbmdlZChvYnNlcnZhYmxlKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vdGlmeSBcImtleXMvZW50cmllcy92YWx1ZXNcIiBvYnNlcnZlcnNcbiAgICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICAgIC8vIE5vdGlmeSBcImhhc1wiIG9ic2VydmVyc1xuICAgICAgLy8gXCJpblwiIGFzIGl0IG1heSBzdGlsbCBleGlzdCBpbiBwcm90b1xuICAgICAgKF90aGlzJHBlbmRpbmdLZXlzXyA9IHRoaXMucGVuZGluZ0tleXNfKSA9PSBudWxsID8gdm9pZCAwIDogKF90aGlzJHBlbmRpbmdLZXlzXyRnZSA9IF90aGlzJHBlbmRpbmdLZXlzXy5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBlbmRpbmdLZXlzXyRnZS5zZXQoa2V5IGluIHRoaXMudGFyZ2V0Xyk7XG4gICAgICAvLyBOb3RpZnkgc3BpZXMvbGlzdGVuZXJzXG4gICAgICBpZiAobm90aWZ5IHx8IG5vdGlmeVNweSkge1xuICAgICAgICB2YXIgX2NoYW5nZTIgPSB7XG4gICAgICAgICAgdHlwZTogUkVNT1ZFLFxuICAgICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm9iamVjdFwiLFxuICAgICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgICBvbGRWYWx1ZTogdmFsdWUsXG4gICAgICAgICAgbmFtZToga2V5XG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgICAgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXHJcbiAgICogT2JzZXJ2ZXMgdGhpcyBvYmplY3QuIFRyaWdnZXJzIGZvciB0aGUgZXZlbnRzICdhZGQnLCAndXBkYXRlJyBhbmQgJ2RlbGV0ZScuXHJcbiAgICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qvb2JzZXJ2ZVxyXG4gICAqIGZvciBjYWxsYmFjayBkZXRhaWxzXHJcbiAgICovO1xuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhjYWxsYmFjaywgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmaXJlSW1tZWRpYXRlbHkgPT09IHRydWUpIHtcbiAgICAgIGRpZShcImBvYnNlcnZlYCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZpcmUgaW1tZWRpYXRlbHkgcHJvcGVydHkgZm9yIG9ic2VydmFibGUgb2JqZWN0cy5cIik7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfTtcbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcbiAgX3Byb3RvLm5vdGlmeVByb3BlcnR5QWRkaXRpb25fID0gZnVuY3Rpb24gbm90aWZ5UHJvcGVydHlBZGRpdGlvbl8oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBfdGhpcyRwZW5kaW5nS2V5c18yLCBfdGhpcyRwZW5kaW5nS2V5c18yJGc7XG4gICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICB2YXIgbm90aWZ5U3B5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgIGlmIChub3RpZnkgfHwgbm90aWZ5U3B5KSB7XG4gICAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgdHlwZTogQURELFxuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJvYmplY3RcIixcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICBuZXdWYWx1ZTogdmFsdWVcbiAgICAgIH0gOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgKF90aGlzJHBlbmRpbmdLZXlzXzIgPSB0aGlzLnBlbmRpbmdLZXlzXykgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyRwZW5kaW5nS2V5c18yJGcgPSBfdGhpcyRwZW5kaW5nS2V5c18yLmdldChrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcGVuZGluZ0tleXNfMiRnLnNldCh0cnVlKTtcbiAgICAvLyBOb3RpZnkgXCJrZXlzL2VudHJpZXMvdmFsdWVzXCIgb2JzZXJ2ZXJzXG4gICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICB9O1xuICBfcHJvdG8ub3duS2V5c18gPSBmdW5jdGlvbiBvd25LZXlzXygpIHtcbiAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiBvd25LZXlzKHRoaXMudGFyZ2V0Xyk7XG4gIH07XG4gIF9wcm90by5rZXlzXyA9IGZ1bmN0aW9uIGtleXNfKCkge1xuICAgIC8vIFJldHVybnMgZW51bWVyYWJsZSAmJiBvd24sIGJ1dCB1bmZvcnR1bmF0ZWx5IGtleXNBdG9tIHdpbGwgcmVwb3J0IG9uIEFOWSBrZXkgY2hhbmdlLlxuICAgIC8vIFRoZXJlIGlzIG5vIHdheSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIE9iamVjdC5rZXlzKG9iamVjdCkgYW5kIFJlZmxlY3Qub3duS2V5cyhvYmplY3QpIC0gYm90aCBhcmUgaGFuZGxlZCBieSBvd25LZXlzIHRyYXAuXG4gICAgLy8gV2UgY2FuIGVpdGhlciBvdmVyLXJlcG9ydCBpbiBPYmplY3Qua2V5cyhvYmplY3QpIG9yIHVuZGVyLXJlcG9ydCBpbiBSZWZsZWN0Lm93bktleXMob2JqZWN0KVxuICAgIC8vIFdlIGNob29zZSB0byBvdmVyLXJlcG9ydCBpbiBPYmplY3Qua2V5cyhvYmplY3QpLCBiZWNhdXNlOlxuICAgIC8vIC0gdHlwaWNhbGx5IGl0J3MgdXNlZCB3aXRoIHNpbXBsZSBkYXRhIG9iamVjdHNcbiAgICAvLyAtIHdoZW4gc3ltYm9saWMvbm9uLWVudW1lcmFibGUga2V5cyBhcmUgcmVsZXZhbnQgUmVmbGVjdC5vd25LZXlzIHdvcmtzIGFzIGV4cGVjdGVkXG4gICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50YXJnZXRfKTtcbiAgfTtcbiAgcmV0dXJuIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbjtcbn0oKTtcbmZ1bmN0aW9uIGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJG5hbWU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgb3B0aW9ucyAmJiBpc09ic2VydmFibGVPYmplY3QodGFyZ2V0KSkge1xuICAgIGRpZShcIk9wdGlvbnMgY2FuJ3QgYmUgcHJvdmlkZWQgZm9yIGFscmVhZHkgb2JzZXJ2YWJsZSBvYmplY3RzLlwiKTtcbiAgfVxuICBpZiAoaGFzUHJvcCh0YXJnZXQsICRtb2J4KSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIShnZXRBZG1pbmlzdHJhdGlvbih0YXJnZXQpIGluc3RhbmNlb2YgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKSkge1xuICAgICAgZGllKFwiQ2Fubm90IGNvbnZlcnQgJ1wiICsgZ2V0RGVidWdOYW1lKHRhcmdldCkgKyBcIicgaW50byBvYnNlcnZhYmxlIG9iamVjdDpcIiArIFwiXFxuVGhlIHRhcmdldCBpcyBhbHJlYWR5IG9ic2VydmFibGUgb2YgZGlmZmVyZW50IHR5cGUuXCIgKyBcIlxcbkV4dGVuZGluZyBidWlsdGlucyBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFPYmplY3QuaXNFeHRlbnNpYmxlKHRhcmdldCkpIHtcbiAgICBkaWUoXCJDYW5ub3QgbWFrZSB0aGUgZGVzaWduYXRlZCBvYmplY3Qgb2JzZXJ2YWJsZTsgaXQgaXMgbm90IGV4dGVuc2libGVcIik7XG4gIH1cbiAgdmFyIG5hbWUgPSAoX29wdGlvbnMkbmFtZSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubmFtZSkgIT0gbnVsbCA/IF9vcHRpb25zJG5hbWUgOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAoaXNQbGFpbk9iamVjdCh0YXJnZXQpID8gXCJPYnNlcnZhYmxlT2JqZWN0XCIgOiB0YXJnZXQuY29uc3RydWN0b3IubmFtZSkgKyBcIkBcIiArIGdldE5leHRJZCgpIDogXCJPYnNlcnZhYmxlT2JqZWN0XCI7XG4gIHZhciBhZG0gPSBuZXcgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKHRhcmdldCwgbmV3IE1hcCgpLCBTdHJpbmcobmFtZSksIGdldEFubm90YXRpb25Gcm9tT3B0aW9ucyhvcHRpb25zKSk7XG4gIGFkZEhpZGRlblByb3AodGFyZ2V0LCAkbW9ieCwgYWRtKTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbnZhciBpc09ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uXCIsIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbik7XG5mdW5jdGlvbiBnZXRDYWNoZWRPYnNlcnZhYmxlUHJvcERlc2NyaXB0b3Ioa2V5KSB7XG4gIHJldHVybiBkZXNjcmlwdG9yQ2FjaGVba2V5XSB8fCAoZGVzY3JpcHRvckNhY2hlW2tleV0gPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1skbW9ieF0uZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5KTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpc1skbW9ieF0uc2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZU9iamVjdCh0aGluZykge1xuICBpZiAoaXNPYmplY3QodGhpbmcpKSB7XG4gICAgcmV0dXJuIGlzT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKHRoaW5nWyRtb2J4XSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmVjb3JkQW5ub3RhdGlvbkFwcGxpZWQoYWRtLCBhbm5vdGF0aW9uLCBrZXkpIHtcbiAgdmFyIF9hZG0kdGFyZ2V0XyRzdG9yZWRBbjtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGFkbS5hcHBsaWVkQW5ub3RhdGlvbnNfW2tleV0gPSBhbm5vdGF0aW9uO1xuICB9XG4gIC8vIFJlbW92ZSBhcHBsaWVkIGRlY29yYXRvciBhbm5vdGF0aW9uIHNvIHdlIGRvbid0IHRyeSB0byBhcHBseSBpdCBhZ2FpbiBpbiBzdWJjbGFzcyBjb25zdHJ1Y3RvclxuICAoX2FkbSR0YXJnZXRfJHN0b3JlZEFuID0gYWRtLnRhcmdldF9bc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSA9PSBudWxsID8gdHJ1ZSA6IGRlbGV0ZSBfYWRtJHRhcmdldF8kc3RvcmVkQW5ba2V5XTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFubm90YWJsZShhZG0sIGFubm90YXRpb24sIGtleSkge1xuICAvLyBWYWxpZCBhbm5vdGF0aW9uXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzQW5ub3RhdGlvbihhbm5vdGF0aW9uKSkge1xuICAgIGRpZShcIkNhbm5vdCBhbm5vdGF0ZSAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOiBJbnZhbGlkIGFubm90YXRpb24uXCIpO1xuICB9XG4gIC8qXHJcbiAgLy8gQ29uZmlndXJhYmxlLCBub3Qgc2VhbGVkLCBub3QgZnJvemVuXHJcbiAgLy8gUG9zc2libHkgbm90IG5lZWRlZCwganVzdCBhIGxpdHRsZSBiZXR0ZXIgZXJyb3IgdGhlbiB0aGUgb25lIHRocm93biBieSBlbmdpbmUuXHJcbiAgLy8gQ2FzZXMgd2hlcmUgdGhpcyB3b3VsZCBiZSB1c2VmdWwgdGhlIG1vc3QgKHN1YmNsYXNzIGZpZWxkIGluaXRpYWxpemVyKSBhcmUgbm90IGludGVyY2VwdGFibGUgYnkgdGhpcy5cclxuICBpZiAoX19ERVZfXykge1xyXG4gICAgICBjb25zdCBjb25maWd1cmFibGUgPSBnZXREZXNjcmlwdG9yKGFkbS50YXJnZXRfLCBrZXkpPy5jb25maWd1cmFibGVcclxuICAgICAgY29uc3QgZnJvemVuID0gT2JqZWN0LmlzRnJvemVuKGFkbS50YXJnZXRfKVxyXG4gICAgICBjb25zdCBzZWFsZWQgPSBPYmplY3QuaXNTZWFsZWQoYWRtLnRhcmdldF8pXHJcbiAgICAgIGlmICghY29uZmlndXJhYmxlIHx8IGZyb3plbiB8fCBzZWFsZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGAke2FkbS5uYW1lX30uJHtrZXkudG9TdHJpbmcoKX1gXHJcbiAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSA9IGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfXHJcbiAgICAgICAgICBsZXQgZXJyb3IgPSBgQ2Fubm90IGFwcGx5ICcke3JlcXVlc3RlZEFubm90YXRpb25UeXBlfScgdG8gJyR7ZmllbGROYW1lfSc6YFxyXG4gICAgICAgICAgaWYgKGZyb3plbikge1xyXG4gICAgICAgICAgICAgIGVycm9yICs9IGBcXG5PYmplY3QgaXMgZnJvemVuLmBcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChzZWFsZWQpIHtcclxuICAgICAgICAgICAgICBlcnJvciArPSBgXFxuT2JqZWN0IGlzIHNlYWxlZC5gXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIWNvbmZpZ3VyYWJsZSkge1xyXG4gICAgICAgICAgICAgIGVycm9yICs9IGBcXG5wcm9wZXJ0eSBpcyBub3QgY29uZmlndXJhYmxlLmBcclxuICAgICAgICAgICAgICAvLyBNZW50aW9uIG9ubHkgaWYgY2F1c2VkIGJ5IHVzIHRvIGF2b2lkIGNvbmZ1c2lvblxyXG4gICAgICAgICAgICAgIGlmIChoYXNQcm9wKGFkbS5hcHBsaWVkQW5ub3RhdGlvbnMhLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGVycm9yICs9IGBcXG5UbyBwcmV2ZW50IGFjY2lkZW50YWwgcmUtZGVmaW5pdGlvbiBvZiBhIGZpZWxkIGJ5IGEgc3ViY2xhc3MsIGBcclxuICAgICAgICAgICAgICAgICAgZXJyb3IgKz0gYGFsbCBhbm5vdGF0ZWQgZmllbGRzIG9mIG5vbi1wbGFpbiBvYmplY3RzIChjbGFzc2VzKSBhcmUgbm90IGNvbmZpZ3VyYWJsZS5gXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGllKGVycm9yKVxyXG4gICAgICB9XHJcbiAgfVxyXG4gICovXG4gIC8vIE5vdCBhbm5vdGF0ZWRcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNPdmVycmlkZShhbm5vdGF0aW9uKSAmJiBoYXNQcm9wKGFkbS5hcHBsaWVkQW5ub3RhdGlvbnNfLCBrZXkpKSB7XG4gICAgdmFyIGZpZWxkTmFtZSA9IGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCk7XG4gICAgdmFyIGN1cnJlbnRBbm5vdGF0aW9uVHlwZSA9IGFkbS5hcHBsaWVkQW5ub3RhdGlvbnNfW2tleV0uYW5ub3RhdGlvblR5cGVfO1xuICAgIHZhciByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSA9IGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfO1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSArIFwiJyB0byAnXCIgKyBmaWVsZE5hbWUgKyBcIic6XCIgKyAoXCJcXG5UaGUgZmllbGQgaXMgYWxyZWFkeSBhbm5vdGF0ZWQgd2l0aCAnXCIgKyBjdXJyZW50QW5ub3RhdGlvblR5cGUgKyBcIicuXCIpICsgXCJcXG5SZS1hbm5vdGF0aW5nIGZpZWxkcyBpcyBub3QgYWxsb3dlZC5cIiArIFwiXFxuVXNlICdvdmVycmlkZScgYW5ub3RhdGlvbiBmb3IgbWV0aG9kcyBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzLlwiKTtcbiAgfVxufVxuXG4vLyBCdWcgaW4gc2FmYXJpIDkuKiAob3IgaU9TIDkgc2FmYXJpIG1vYmlsZSkuIFNlZSAjMzY0XG52YXIgRU5UUllfMCA9IC8qI19fUFVSRV9fKi9jcmVhdGVBcnJheUVudHJ5RGVzY3JpcHRvcigwKTtcbi8qKlxyXG4gKiBUaGlzIGFycmF5IGJ1ZmZlciBjb250YWlucyB0d28gbGlzdHMgb2YgcHJvcGVydGllcywgc28gdGhhdCBhbGwgYXJyYXlzXHJcbiAqIGNhbiByZWN5Y2xlIHRoZWlyIHByb3BlcnR5IGRlZmluaXRpb25zLCB3aGljaCBzaWduaWZpY2FudGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlIG9mIGNyZWF0aW5nXHJcbiAqIHByb3BlcnRpZXMgb24gdGhlIGZseS5cclxuICovXG52YXIgT0JTRVJWQUJMRV9BUlJBWV9CVUZGRVJfU0laRSA9IDA7XG4vLyBUeXBlc2NyaXB0IHdvcmthcm91bmQgdG8gbWFrZSBzdXJlIE9ic2VydmFibGVBcnJheSBleHRlbmRzIEFycmF5XG52YXIgU3R1YkFycmF5ID0gZnVuY3Rpb24gU3R1YkFycmF5KCkge307XG5mdW5jdGlvbiBpbmhlcml0KGN0b3IsIHByb3RvKSB7XG4gIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY3Rvci5wcm90b3R5cGUsIHByb3RvKTtcbiAgfSBlbHNlIGlmIChjdG9yLnByb3RvdHlwZS5fX3Byb3RvX18gIT09IHVuZGVmaW5lZCkge1xuICAgIGN0b3IucHJvdG90eXBlLl9fcHJvdG9fXyA9IHByb3RvO1xuICB9IGVsc2Uge1xuICAgIGN0b3IucHJvdG90eXBlID0gcHJvdG87XG4gIH1cbn1cbmluaGVyaXQoU3R1YkFycmF5LCBBcnJheS5wcm90b3R5cGUpO1xuLy8gV2VleCBwcm90byBmcmVlemUgcHJvdGVjdGlvbiB3YXMgaGVyZSxcbi8vIGJ1dCBpdCBpcyB1bmNsZWFyIHdoeSB0aGUgaGFjayBpcyBuZWVkIGFzIE1vYlggbmV2ZXIgY2hhbmdlZCB0aGUgcHJvdG90eXBlXG4vLyBhbnl3YXksIHNvIHJlbW92ZWQgaXQgaW4gVjZcbnZhciBMZWdhY3lPYnNlcnZhYmxlQXJyYXkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHViQXJyYXksIF9TeW1ib2wkdG9TdHJpbmdUYWcsIF9TeW1ib2wkaXRlcmF0b3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoTGVnYWN5T2JzZXJ2YWJsZUFycmF5LCBfU3R1YkFycmF5KTtcbiAgZnVuY3Rpb24gTGVnYWN5T2JzZXJ2YWJsZUFycmF5KGluaXRpYWxWYWx1ZXMsIGVuaGFuY2VyLCBuYW1lLCBvd25lZCkge1xuICAgIHZhciBfdGhpcztcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJPYnNlcnZhYmxlQXJyYXlAXCIgKyBnZXROZXh0SWQoKSA6IFwiT2JzZXJ2YWJsZUFycmF5XCI7XG4gICAgfVxuICAgIGlmIChvd25lZCA9PT0gdm9pZCAwKSB7XG4gICAgICBvd25lZCA9IGZhbHNlO1xuICAgIH1cbiAgICBfdGhpcyA9IF9TdHViQXJyYXkuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIHZhciBhZG0gPSBuZXcgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24obmFtZSwgZW5oYW5jZXIsIG93bmVkLCB0cnVlKTtcbiAgICBhZG0ucHJveHlfID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyk7XG4gICAgYWRkSGlkZGVuRmluYWxQcm9wKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAkbW9ieCwgYWRtKTtcbiAgICBpZiAoaW5pdGlhbFZhbHVlcyAmJiBpbml0aWFsVmFsdWVzLmxlbmd0aCkge1xuICAgICAgdmFyIHByZXYgPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KHRydWUpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgX3RoaXMuc3BsaWNlV2l0aEFycmF5KDAsIDAsIGluaXRpYWxWYWx1ZXMpO1xuICAgICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldik7XG4gICAgfVxuICAgIHtcbiAgICAgIC8vIFNlZW1zIHRoYXQgU2FmYXJpIHdvbid0IHVzZSBudW1lcmljIHByb3RvdHlwZSBzZXR0ZXIgdW50aWxsIGFueSAqIG51bWVyaWMgcHJvcGVydHkgaXNcbiAgICAgIC8vIGRlZmluZWQgb24gdGhlIGluc3RhbmNlLiBBZnRlciB0aGF0IGl0IHdvcmtzIGZpbmUsIGV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSBpcyBkZWxldGVkLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIjBcIiwgRU5UUllfMCk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gTGVnYWN5T2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZTtcbiAgX3Byb3RvLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB0aGlzWyRtb2J4XS5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcnJheXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcnJheXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KHRoaXMuc2xpY2UoKSxcbiAgICAvL0B0cy1pZ25vcmVcbiAgICBhcnJheXMubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gaXNPYnNlcnZhYmxlQXJyYXkoYSkgPyBhLnNsaWNlKCkgOiBhO1xuICAgIH0pKTtcbiAgfTtcbiAgX3Byb3RvW19TeW1ib2wkaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHJldHVybiBuZXh0SW5kZXggPCBzZWxmLmxlbmd0aCA/IHtcbiAgICAgICAgICB2YWx1ZTogc2VsZltuZXh0SW5kZXgrK10sXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgX2NyZWF0ZUNsYXNzKExlZ2FjeU9ic2VydmFibGVBcnJheSwgW3tcbiAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1skbW9ieF0uZ2V0QXJyYXlMZW5ndGhfKCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZW5ndGgpIHtcbiAgICAgIHRoaXNbJG1vYnhdLnNldEFycmF5TGVuZ3RoXyhuZXdMZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCR0b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcIkFycmF5XCI7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMZWdhY3lPYnNlcnZhYmxlQXJyYXk7XG59KFN0dWJBcnJheSwgU3ltYm9sLnRvU3RyaW5nVGFnLCBTeW1ib2wuaXRlcmF0b3IpO1xuT2JqZWN0LmVudHJpZXMoYXJyYXlFeHRlbnNpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBwcm9wID0gX3JlZlswXSxcbiAgICBmbiA9IF9yZWZbMV07XG4gIGlmIChwcm9wICE9PSBcImNvbmNhdFwiKSB7XG4gICAgYWRkSGlkZGVuUHJvcChMZWdhY3lPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLCBwcm9wLCBmbik7XG4gIH1cbn0pO1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlFbnRyeURlc2NyaXB0b3IoaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1skbW9ieF0uZ2V0XyhpbmRleCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpc1skbW9ieF0uc2V0XyhpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5QnVmZmVySXRlbShpbmRleCkge1xuICBkZWZpbmVQcm9wZXJ0eShMZWdhY3lPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLCBcIlwiICsgaW5kZXgsIGNyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yKGluZGV4KSk7XG59XG5mdW5jdGlvbiByZXNlcnZlQXJyYXlCdWZmZXIobWF4KSB7XG4gIGlmIChtYXggPiBPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSBPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFOyBpbmRleCA8IG1heCArIDEwMDsgaW5kZXgrKykge1xuICAgICAgY3JlYXRlQXJyYXlCdWZmZXJJdGVtKGluZGV4KTtcbiAgICB9XG4gICAgT0JTRVJWQUJMRV9BUlJBWV9CVUZGRVJfU0laRSA9IG1heDtcbiAgfVxufVxucmVzZXJ2ZUFycmF5QnVmZmVyKDEwMDApO1xuZnVuY3Rpb24gY3JlYXRlTGVnYWN5QXJyYXkoaW5pdGlhbFZhbHVlcywgZW5oYW5jZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBMZWdhY3lPYnNlcnZhYmxlQXJyYXkoaW5pdGlhbFZhbHVlcywgZW5oYW5jZXIsIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkge1xuICBpZiAodHlwZW9mIHRoaW5nID09PSBcIm9iamVjdFwiICYmIHRoaW5nICE9PSBudWxsKSB7XG4gICAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KHRoaW5nKSkge1xuICAgICAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGllKDIzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGluZ1skbW9ieF0uYXRvbV87XG4gICAgfVxuICAgIGlmIChpc09ic2VydmFibGVTZXQodGhpbmcpKSB7XG4gICAgICByZXR1cm4gdGhpbmcuYXRvbV87XG4gICAgfVxuICAgIGlmIChpc09ic2VydmFibGVNYXAodGhpbmcpKSB7XG4gICAgICBpZiAocHJvcGVydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpbmcua2V5c0F0b21fO1xuICAgICAgfVxuICAgICAgdmFyIG9ic2VydmFibGUgPSB0aGluZy5kYXRhXy5nZXQocHJvcGVydHkpIHx8IHRoaW5nLmhhc01hcF8uZ2V0KHByb3BlcnR5KTtcbiAgICAgIGlmICghb2JzZXJ2YWJsZSkge1xuICAgICAgICBkaWUoMjUsIHByb3BlcnR5LCBnZXREZWJ1Z05hbWUodGhpbmcpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH1cbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSkge1xuICAgICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gZGllKDI2KTtcbiAgICAgIH1cbiAgICAgIHZhciBfb2JzZXJ2YWJsZSA9IHRoaW5nWyRtb2J4XS52YWx1ZXNfLmdldChwcm9wZXJ0eSk7XG4gICAgICBpZiAoIV9vYnNlcnZhYmxlKSB7XG4gICAgICAgIGRpZSgyNywgcHJvcGVydHksIGdldERlYnVnTmFtZSh0aGluZykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9vYnNlcnZhYmxlO1xuICAgIH1cbiAgICBpZiAoaXNBdG9tKHRoaW5nKSB8fCBpc0NvbXB1dGVkVmFsdWUodGhpbmcpIHx8IGlzUmVhY3Rpb24odGhpbmcpKSB7XG4gICAgICByZXR1cm4gdGhpbmc7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpbmcpKSB7XG4gICAgaWYgKGlzUmVhY3Rpb24odGhpbmdbJG1vYnhdKSkge1xuICAgICAgLy8gZGlzcG9zZXIgZnVuY3Rpb25cbiAgICAgIHJldHVybiB0aGluZ1skbW9ieF07XG4gICAgfVxuICB9XG4gIGRpZSgyOCk7XG59XG5mdW5jdGlvbiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcGVydHkpIHtcbiAgaWYgKCF0aGluZykge1xuICAgIGRpZSgyOSk7XG4gIH1cbiAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24oZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpKTtcbiAgfVxuICBpZiAoaXNBdG9tKHRoaW5nKSB8fCBpc0NvbXB1dGVkVmFsdWUodGhpbmcpIHx8IGlzUmVhY3Rpb24odGhpbmcpKSB7XG4gICAgcmV0dXJuIHRoaW5nO1xuICB9XG4gIGlmIChpc09ic2VydmFibGVNYXAodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZVNldCh0aGluZykpIHtcbiAgICByZXR1cm4gdGhpbmc7XG4gIH1cbiAgaWYgKHRoaW5nWyRtb2J4XSkge1xuICAgIHJldHVybiB0aGluZ1skbW9ieF07XG4gIH1cbiAgZGllKDI0LCB0aGluZyk7XG59XG5mdW5jdGlvbiBnZXREZWJ1Z05hbWUodGhpbmcsIHByb3BlcnR5KSB7XG4gIHZhciBuYW1lZDtcbiAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBuYW1lZCA9IGdldEF0b20odGhpbmcsIHByb3BlcnR5KTtcbiAgfSBlbHNlIGlmIChpc0FjdGlvbih0aGluZykpIHtcbiAgICByZXR1cm4gdGhpbmcubmFtZTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVPYmplY3QodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZU1hcCh0aGluZykgfHwgaXNPYnNlcnZhYmxlU2V0KHRoaW5nKSkge1xuICAgIG5hbWVkID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcpO1xuICB9IGVsc2Uge1xuICAgIC8vIHZhbGlkIGZvciBhcnJheXMgYXMgd2VsbFxuICAgIG5hbWVkID0gZ2V0QXRvbSh0aGluZyk7XG4gIH1cbiAgcmV0dXJuIG5hbWVkLm5hbWVfO1xufVxuXG52YXIgdG9TdHJpbmcgPSBvYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYiwgZGVwdGgpIHtcbiAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICBkZXB0aCA9IC0xO1xuICB9XG4gIHJldHVybiBlcShhLCBiLCBkZXB0aCk7XG59XG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvYmxvYi81YzIzN2E3YzY4MmZiNjhmZDUzNzgyMDNmMGJmMjJkY2UxNjI0ODU0L3VuZGVyc2NvcmUuanMjTDExODYtTDEyODlcbi8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG5mdW5jdGlvbiBlcShhLCBiLCBkZXB0aCwgYVN0YWNrLCBiU3RhY2spIHtcbiAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gIH1cbiAgLy8gYG51bGxgIG9yIGB1bmRlZmluZWRgIG9ubHkgZXF1YWwgdG8gaXRzZWxmIChzdHJpY3QgY29tcGFyaXNvbikuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gIGlmIChhICE9PSBhKSB7XG4gICAgcmV0dXJuIGIgIT09IGI7XG4gIH1cbiAgLy8gRXhoYXVzdCBwcmltaXRpdmUgY2hlY2tzXG4gIHZhciB0eXBlID0gdHlwZW9mIGE7XG4gIGlmICh0eXBlICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiAhPSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgY2FzZSBcIltvYmplY3QgUmVnRXhwXVwiOlxuICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgY2FzZSBcIltvYmplY3QgU3RyaW5nXVwiOlxuICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgIHJldHVybiBcIlwiICsgYSA9PT0gXCJcIiArIGI7XG4gICAgY2FzZSBcIltvYmplY3QgTnVtYmVyXVwiOlxuICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOLlxuICAgICAgaWYgKCthICE9PSArYSkge1xuICAgICAgICByZXR1cm4gK2IgIT09ICtiO1xuICAgICAgfVxuICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgY2FzZSBcIltvYmplY3QgRGF0ZV1cIjpcbiAgICBjYXNlIFwiW29iamVjdCBCb29sZWFuXVwiOlxuICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICBjYXNlIFwiW29iamVjdCBTeW1ib2xdXCI6XG4gICAgICByZXR1cm4gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wudmFsdWVPZi5jYWxsKGEpID09PSBTeW1ib2wudmFsdWVPZi5jYWxsKGIpO1xuICAgIGNhc2UgXCJbb2JqZWN0IE1hcF1cIjpcbiAgICBjYXNlIFwiW29iamVjdCBTZXRdXCI6XG4gICAgICAvLyBNYXBzIGFuZCBTZXRzIGFyZSB1bndyYXBwZWQgdG8gYXJyYXlzIG9mIGVudHJ5LXBhaXJzLCBhZGRpbmcgYW4gaW5jaWRlbnRhbCBsZXZlbC5cbiAgICAgIC8vIEhpZGUgdGhpcyBleHRyYSBsZXZlbCBieSBpbmNyZWFzaW5nIHRoZSBkZXB0aC5cbiAgICAgIGlmIChkZXB0aCA+PSAwKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgYSA9IHVud3JhcChhKTtcbiAgYiA9IHVud3JhcChiKTtcbiAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICBpZiAoIWFyZUFycmF5cykge1xuICAgIGlmICh0eXBlb2YgYSAhPSBcIm9iamVjdFwiIHx8IHR5cGVvZiBiICE9IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLFxuICAgICAgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShpc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmIGlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpICYmIFwiY29uc3RydWN0b3JcIiBpbiBhICYmIFwiY29uc3RydWN0b3JcIiBpbiBiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChkZXB0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChkZXB0aCA8IDApIHtcbiAgICBkZXB0aCA9IC0xO1xuICB9XG4gIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICBhU3RhY2sgPSBhU3RhY2sgfHwgW107XG4gIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcbiAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHtcbiAgICAgIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG4gIH1cbiAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICBhU3RhY2sucHVzaChhKTtcbiAgYlN0YWNrLnB1c2goYik7XG4gIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICBpZiAoYXJlQXJyYXlzKSB7XG4gICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmICghZXEoYVtsZW5ndGhdLCBiW2xlbmd0aF0sIGRlcHRoIC0gMSwgYVN0YWNrLCBiU3RhY2spKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICB2YXIga2V5O1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICBpZiAoT2JqZWN0LmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgIGlmICghKGhhc1Byb3AoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgZGVwdGggLSAxLCBhU3RhY2ssIGJTdGFjaykpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gIGFTdGFjay5wb3AoKTtcbiAgYlN0YWNrLnBvcCgpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVud3JhcChhKSB7XG4gIGlmIChpc09ic2VydmFibGVBcnJheShhKSkge1xuICAgIHJldHVybiBhLnNsaWNlKCk7XG4gIH1cbiAgaWYgKGlzRVM2TWFwKGEpIHx8IGlzT2JzZXJ2YWJsZU1hcChhKSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGEuZW50cmllcygpKTtcbiAgfVxuICBpZiAoaXNFUzZTZXQoYSkgfHwgaXNPYnNlcnZhYmxlU2V0KGEpKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYS5lbnRyaWVzKCkpO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBtYWtlSXRlcmFibGUoaXRlcmF0b3IpIHtcbiAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGdldFNlbGY7XG4gIHJldHVybiBpdGVyYXRvcjtcbn1cbmZ1bmN0aW9uIGdldFNlbGYoKSB7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBpc0Fubm90YXRpb24odGhpbmcpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBDYW4gYmUgZnVuY3Rpb25cbiAgICB0aGluZyBpbnN0YW5jZW9mIE9iamVjdCAmJiB0eXBlb2YgdGhpbmcuYW5ub3RhdGlvblR5cGVfID09PSBcInN0cmluZ1wiICYmIGlzRnVuY3Rpb24odGhpbmcubWFrZV8pICYmIGlzRnVuY3Rpb24odGhpbmcuZXh0ZW5kXylcbiAgKTtcbn1cblxuLyoqXHJcbiAqIChjKSBNaWNoZWwgV2VzdHN0cmF0ZSAyMDE1IC0gMjAyMFxyXG4gKiBNSVQgTGljZW5zZWRcclxuICpcclxuICogV2VsY29tZSB0byB0aGUgbW9ieCBzb3VyY2VzISBUbyBnZXQgYSBnbG9iYWwgb3ZlcnZpZXcgb2YgaG93IE1vYlggaW50ZXJuYWxseSB3b3JrcyxcclxuICogdGhpcyBpcyBhIGdvb2QgcGxhY2UgdG8gc3RhcnQ6XHJcbiAqIGh0dHBzOi8vbWVkaXVtLmNvbS9AbXdlc3RzdHJhdGUvYmVjb21pbmctZnVsbHktcmVhY3RpdmUtYW4taW4tZGVwdGgtZXhwbGFuYXRpb24tb2YtbW9ic2VydmFibGUtNTU5OTUyNjJhMjU0Iy54dmJoNnFkNzRcclxuICpcclxuICogU291cmNlIGZvbGRlcnM6XHJcbiAqID09PT09PT09PT09PT09PVxyXG4gKlxyXG4gKiAtIGFwaS8gICAgIE1vc3Qgb2YgdGhlIHB1YmxpYyBzdGF0aWMgbWV0aG9kcyBleHBvc2VkIGJ5IHRoZSBtb2R1bGUgY2FuIGJlIGZvdW5kIGhlcmUuXHJcbiAqIC0gY29yZS8gICAgSW1wbGVtZW50YXRpb24gb2YgdGhlIE1vYlggYWxnb3JpdGhtOyBhdG9tcywgZGVyaXZhdGlvbnMsIHJlYWN0aW9ucywgZGVwZW5kZW5jeSB0cmVlcywgb3B0aW1pemF0aW9ucy4gQ29vbCBzdHVmZiBjYW4gYmUgZm91bmQgaGVyZS5cclxuICogLSB0eXBlcy8gICBBbGwgdGhlIG1hZ2ljIHRoYXQgaXMgbmVlZCB0byBoYXZlIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCB2YWx1ZXMgaXMgaW4gdGhpcyBmb2xkZXIuIEluY2x1ZGluZyB0aGUgbW9kaWZpZXJzIGxpa2UgYGFzRmxhdGAuXHJcbiAqIC0gdXRpbHMvICAgVXRpbGl0eSBzdHVmZi5cclxuICpcclxuICovXG5bXCJTeW1ib2xcIiwgXCJNYXBcIiwgXCJTZXRcIl0uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICB2YXIgZyA9IGdldEdsb2JhbCgpO1xuICBpZiAodHlwZW9mIGdbbV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkaWUoXCJNb2JYIHJlcXVpcmVzIGdsb2JhbCAnXCIgKyBtICsgXCInIHRvIGJlIGF2YWlsYWJsZSBvciBwb2x5ZmlsbGVkXCIpO1xuICB9XG59KTtcbmlmICh0eXBlb2YgX19NT0JYX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09IFwib2JqZWN0XCIpIHtcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5keWtvZy9tb2J4LWRldnRvb2xzL1xuICBfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3RNb2J4KHtcbiAgICBzcHk6IHNweSxcbiAgICBleHRyYXM6IHtcbiAgICAgIGdldERlYnVnTmFtZTogZ2V0RGVidWdOYW1lXG4gICAgfSxcbiAgICAkbW9ieDogJG1vYnhcbiAgfSk7XG59XG5cbmV4cG9ydCB7ICRtb2J4LCBGbG93Q2FuY2VsbGF0aW9uRXJyb3IsIE9ic2VydmFibGVNYXAsIE9ic2VydmFibGVTZXQsIFJlYWN0aW9uLCBhbGxvd1N0YXRlQ2hhbmdlcyBhcyBfYWxsb3dTdGF0ZUNoYW5nZXMsIHJ1bkluQWN0aW9uIGFzIF9hbGxvd1N0YXRlQ2hhbmdlc0luc2lkZUNvbXB1dGVkLCBhbGxvd1N0YXRlUmVhZHNFbmQgYXMgX2FsbG93U3RhdGVSZWFkc0VuZCwgYWxsb3dTdGF0ZVJlYWRzU3RhcnQgYXMgX2FsbG93U3RhdGVSZWFkc1N0YXJ0LCBhdXRvQWN0aW9uIGFzIF9hdXRvQWN0aW9uLCBfZW5kQWN0aW9uLCBnZXRBZG1pbmlzdHJhdGlvbiBhcyBfZ2V0QWRtaW5pc3RyYXRpb24sIGdldEdsb2JhbFN0YXRlIGFzIF9nZXRHbG9iYWxTdGF0ZSwgaW50ZXJjZXB0UmVhZHMgYXMgX2ludGVyY2VwdFJlYWRzLCBpc0NvbXB1dGluZ0Rlcml2YXRpb24gYXMgX2lzQ29tcHV0aW5nRGVyaXZhdGlvbiwgcmVzZXRHbG9iYWxTdGF0ZSBhcyBfcmVzZXRHbG9iYWxTdGF0ZSwgX3N0YXJ0QWN0aW9uLCBhY3Rpb24sIGF1dG9ydW4sIGNvbXBhcmVyLCBjb21wdXRlZCwgY29uZmlndXJlLCBjcmVhdGVBdG9tLCBhcGlEZWZpbmVQcm9wZXJ0eSBhcyBkZWZpbmVQcm9wZXJ0eSwgZW50cmllcywgZXh0ZW5kT2JzZXJ2YWJsZSwgZmxvdywgZmxvd1Jlc3VsdCwgZ2V0LCBnZXRBdG9tLCBnZXREZWJ1Z05hbWUsIGdldERlcGVuZGVuY3lUcmVlLCBnZXRPYnNlcnZlclRyZWUsIGhhcywgaW50ZXJjZXB0LCBpc0FjdGlvbiwgaXNPYnNlcnZhYmxlVmFsdWUgYXMgaXNCb3hlZE9ic2VydmFibGUsIGlzQ29tcHV0ZWQsIGlzQ29tcHV0ZWRQcm9wLCBpc0Zsb3csIGlzRmxvd0NhbmNlbGxhdGlvbkVycm9yLCBpc09ic2VydmFibGUsIGlzT2JzZXJ2YWJsZUFycmF5LCBpc09ic2VydmFibGVNYXAsIGlzT2JzZXJ2YWJsZU9iamVjdCwgaXNPYnNlcnZhYmxlUHJvcCwgaXNPYnNlcnZhYmxlU2V0LCBrZXlzLCBtYWtlQXV0b09ic2VydmFibGUsIG1ha2VPYnNlcnZhYmxlLCBvYnNlcnZhYmxlLCBvYnNlcnZlLCBvbkJlY29tZU9ic2VydmVkLCBvbkJlY29tZVVub2JzZXJ2ZWQsIG9uUmVhY3Rpb25FcnJvciwgb3ZlcnJpZGUsIGFwaU93bktleXMgYXMgb3duS2V5cywgcmVhY3Rpb24sIHJlbW92ZSwgcnVuSW5BY3Rpb24sIHNldCwgc3B5LCB0b0pTLCB0cmFjZSwgdHJhbnNhY3Rpb24sIHVudHJhY2tlZCwgdmFsdWVzLCB3aGVuIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2J4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJuaWNlRXJyb3JzIiwiXyIsImFubm90YXRpb25UeXBlIiwia2V5IiwidG9TdHJpbmciLCJpbmRleCIsImxlbmd0aCIsIm90aGVyIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiZGF0YVN0cnVjdHVyZSIsInRoaW5nIiwicHJvcGVydHkiLCJkZXJpdmF0aW9uIiwibWV0aG9kIiwiZXJyb3JzIiwicHJvY2VzcyIsImRpZSIsImVycm9yIiwiX2xlbiIsImFyZ3VtZW50cyIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJlIiwiYXBwbHkiLCJFcnJvciIsIm1hcCIsIlN0cmluZyIsImpvaW4iLCJtb2NrR2xvYmFsIiwiZ2V0R2xvYmFsIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJhc3NpZ24iLCJPYmplY3QiLCJnZXREZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVmaW5lUHJvcGVydHkiLCJvYmplY3RQcm90b3R5cGUiLCJwcm90b3R5cGUiLCJFTVBUWV9BUlJBWSIsImZyZWV6ZSIsIkVNUFRZX09CSkVDVCIsImhhc1Byb3h5IiwiUHJveHkiLCJwbGFpbk9iamVjdFN0cmluZyIsImFzc2VydFByb3hpZXMiLCJ3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50IiwibXNnIiwiZ2xvYmFsU3RhdGUiLCJ2ZXJpZnlQcm94aWVzIiwiZ2V0TmV4dElkIiwibW9ieEd1aWQiLCJvbmNlIiwiZnVuYyIsImludm9rZWQiLCJub29wIiwiaXNGdW5jdGlvbiIsImZuIiwiaXNTdHJpbmdpc2giLCJ2YWx1ZSIsInQiLCJpc09iamVjdCIsImlzUGxhaW5PYmplY3QiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwicHJvdG9Db25zdHJ1Y3RvciIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImlzR2VuZXJhdG9yIiwib2JqIiwiZGlzcGxheU5hbWUiLCJhZGRIaWRkZW5Qcm9wIiwib2JqZWN0IiwicHJvcE5hbWUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJhZGRIaWRkZW5GaW5hbFByb3AiLCJjcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlIiwidGhlQ2xhc3MiLCJ4IiwiaXNFUzZNYXAiLCJNYXAiLCJpc0VTNlNldCIsIlNldCIsImhhc0dldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldFBsYWluT2JqZWN0S2V5cyIsImtleXMiLCJzeW1ib2xzIiwiY29uY2F0IiwiZmlsdGVyIiwicyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwib3duS2V5cyIsIlJlZmxlY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwic3RyaW5naWZ5S2V5IiwidG9QcmltaXRpdmUiLCJoYXNQcm9wIiwidGFyZ2V0IiwicHJvcCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJyZXMiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImkiLCJkZXNjcmlwdG9yIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9leHRlbmRzIiwiYmluZCIsInNvdXJjZSIsIl9pbmhlcml0c0xvb3NlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwibyIsInAiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsInNsaWNlIiwiZnJvbSIsInRlc3QiLCJhcnIiLCJsZW4iLCJhcnIyIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSIsImFsbG93QXJyYXlMaWtlIiwiaXQiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm5leHQiLCJpc0FycmF5IiwiZG9uZSIsIlR5cGVFcnJvciIsIl90b1ByaW1pdGl2ZSIsImlucHV0IiwiaGludCIsInByaW0iLCJ1bmRlZmluZWQiLCJOdW1iZXIiLCJhcmciLCJzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCIsImNyZWF0ZURlY29yYXRvckFubm90YXRpb24iLCJhbm5vdGF0aW9uIiwiZGVjb3JhdG9yIiwic3RvcmVBbm5vdGF0aW9uIiwiaXNPdmVycmlkZSIsImZpZWxkTmFtZSIsImFzc2VydE5vdERlY29yYXRlZCIsImN1cnJlbnRBbm5vdGF0aW9uVHlwZSIsImFubm90YXRpb25UeXBlXyIsInJlcXVlc3RlZEFubm90YXRpb25UeXBlIiwiY29sbGVjdFN0b3JlZEFubm90YXRpb25zIiwiJG1vYngiLCJBdG9tIiwibmFtZV8iLCJpc1BlbmRpbmdVbm9ic2VydmF0aW9uXyIsImlzQmVpbmdPYnNlcnZlZF8iLCJvYnNlcnZlcnNfIiwiZGlmZlZhbHVlXyIsImxhc3RBY2Nlc3NlZEJ5XyIsImxvd2VzdE9ic2VydmVyU3RhdGVfIiwiSURlcml2YXRpb25TdGF0ZV8iLCJOT1RfVFJBQ0tJTkdfIiwib25CT0wiLCJvbkJVT0wiLCJfcHJvdG8iLCJvbkJPIiwibGlzdGVuZXIiLCJvbkJVTyIsInJlcG9ydE9ic2VydmVkIiwicmVwb3J0T2JzZXJ2ZWQkMSIsInJlcG9ydENoYW5nZWQiLCJzdGFydEJhdGNoIiwicHJvcGFnYXRlQ2hhbmdlZCIsImVuZEJhdGNoIiwiaXNBdG9tIiwiY3JlYXRlQXRvbSIsIm9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyIiwib25CZWNvbWVVbm9ic2VydmVkSGFuZGxlciIsImF0b20iLCJvbkJlY29tZU9ic2VydmVkIiwib25CZWNvbWVVbm9ic2VydmVkIiwiaWRlbnRpdHlDb21wYXJlciIsImEiLCJiIiwic3RydWN0dXJhbENvbXBhcmVyIiwiZGVlcEVxdWFsIiwic2hhbGxvd0NvbXBhcmVyIiwiZGVmYXVsdENvbXBhcmVyIiwiaXMiLCJjb21wYXJlciIsImlkZW50aXR5Iiwic3RydWN0dXJhbCIsInNoYWxsb3ciLCJkZWVwRW5oYW5jZXIiLCJ2IiwiaXNPYnNlcnZhYmxlIiwib2JzZXJ2YWJsZSIsImFycmF5Iiwic2V0IiwiaXNBY3Rpb24iLCJpc0Zsb3ciLCJmbG93IiwiYXV0b0FjdGlvbiIsInNoYWxsb3dFbmhhbmNlciIsImlzT2JzZXJ2YWJsZU9iamVjdCIsImlzT2JzZXJ2YWJsZUFycmF5IiwiaXNPYnNlcnZhYmxlTWFwIiwiaXNPYnNlcnZhYmxlU2V0IiwiZGVlcCIsInJlZmVyZW5jZUVuaGFuY2VyIiwibmV3VmFsdWUiLCJyZWZTdHJ1Y3RFbmhhbmNlciIsIm9sZFZhbHVlIiwiT1ZFUlJJREUiLCJvdmVycmlkZSIsIm1ha2VfIiwiZXh0ZW5kXyIsImFkbSIsImlzUGxhaW5PYmplY3RfIiwiYXBwbGllZEFubm90YXRpb25zXyIsInByb3h5VHJhcCIsImNyZWF0ZUFjdGlvbkFubm90YXRpb24iLCJvcHRpb25zIiwib3B0aW9uc18iLCJtYWtlXyQxIiwiZXh0ZW5kXyQxIiwiX3RoaXMkb3B0aW9uc18iLCJib3VuZCIsInRhcmdldF8iLCJhY3Rpb25EZXNjcmlwdG9yIiwiY3JlYXRlQWN0aW9uRGVzY3JpcHRvciIsImRlZmluZVByb3BlcnR5XyIsImFzc2VydEFjdGlvbkRlc2NyaXB0b3IiLCJfcmVmIiwiX3JlZjIiLCJzYWZlRGVzY3JpcHRvcnMiLCJfYW5ub3RhdGlvbiRvcHRpb25zXyIsIl9hbm5vdGF0aW9uJG9wdGlvbnNfJCIsIl9hbm5vdGF0aW9uJG9wdGlvbnNfMiIsIl9hbm5vdGF0aW9uJG9wdGlvbnNfJDIiLCJfYW5ub3RhdGlvbiRvcHRpb25zXzMiLCJfYW5ub3RhdGlvbiRvcHRpb25zXzQiLCJfYWRtJHByb3h5XzIiLCJfYWRtJHByb3h5XyIsInByb3h5XyIsImNyZWF0ZUFjdGlvbiIsImNyZWF0ZUZsb3dBbm5vdGF0aW9uIiwibWFrZV8kMiIsImV4dGVuZF8kMiIsImZsb3dEZXNjcmlwdG9yIiwiY3JlYXRlRmxvd0Rlc2NyaXB0b3IiLCJfdGhpcyRvcHRpb25zXzIiLCJhc3NlcnRGbG93RGVzY3JpcHRvciIsImlzTW9iWEZsb3ciLCJjcmVhdGVDb21wdXRlZEFubm90YXRpb24iLCJtYWtlXyQzIiwiZXh0ZW5kXyQzIiwiYXNzZXJ0Q29tcHV0ZWREZXNjcmlwdG9yIiwiZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eV8iLCJnZXQiLCJjcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbiIsIm1ha2VfJDQiLCJleHRlbmRfJDQiLCJfdGhpcyRvcHRpb25zXyRlbmhhbmMiLCJhc3NlcnRPYnNlcnZhYmxlRGVzY3JpcHRvciIsImRlZmluZU9ic2VydmFibGVQcm9wZXJ0eV8iLCJlbmhhbmNlciIsIkFVVE8iLCJhdXRvQW5ub3RhdGlvbiIsImNyZWF0ZUF1dG9Bbm5vdGF0aW9uIiwibWFrZV8kNSIsImV4dGVuZF8kNSIsIl90aGlzJG9wdGlvbnNfMyIsIl90aGlzJG9wdGlvbnNfNCIsImNvbXB1dGVkIiwiZmxvd0Fubm90YXRpb24iLCJhdXRvQmluZCIsImFjdGlvbkFubm90YXRpb24iLCJvYnNlcnZhYmxlQW5ub3RhdGlvbiIsInJlZiIsIl90aGlzJG9wdGlvbnNfNSIsIl90aGlzJG9wdGlvbnNfNiIsIk9CU0VSVkFCTEUiLCJPQlNFUlZBQkxFX1JFRiIsIk9CU0VSVkFCTEVfU0hBTExPVyIsIk9CU0VSVkFCTEVfU1RSVUNUIiwiZGVmYXVsdENyZWF0ZU9ic2VydmFibGVPcHRpb25zIiwiZGVmYXVsdERlY29yYXRvciIsInByb3h5IiwiYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyIsIm9ic2VydmFibGVSZWZBbm5vdGF0aW9uIiwib2JzZXJ2YWJsZVNoYWxsb3dBbm5vdGF0aW9uIiwib2JzZXJ2YWJsZVN0cnVjdEFubm90YXRpb24iLCJvYnNlcnZhYmxlRGVjb3JhdG9yQW5ub3RhdGlvbiIsImdldEVuaGFuY2VyRnJvbU9wdGlvbnMiLCJnZXRFbmhhbmNlckZyb21Bbm5vdGF0aW9uIiwiZ2V0QW5ub3RhdGlvbkZyb21PcHRpb25zIiwiX29wdGlvbnMkZGVmYXVsdERlY29yIiwiY3JlYXRlT2JzZXJ2YWJsZSIsImFyZzIiLCJhcmczIiwiYm94Iiwib2JzZXJ2YWJsZUZhY3RvcmllcyIsIk9ic2VydmFibGVWYWx1ZSIsImVxdWFscyIsImluaXRpYWxWYWx1ZXMiLCJ1c2VQcm94aWVzIiwiY3JlYXRlTGVnYWN5QXJyYXkiLCJjcmVhdGVPYnNlcnZhYmxlQXJyYXkiLCJPYnNlcnZhYmxlTWFwIiwiT2JzZXJ2YWJsZVNldCIsImRlY29yYXRvcnMiLCJleHRlbmRPYnNlcnZhYmxlIiwiYXNPYnNlcnZhYmxlT2JqZWN0IiwiYXNEeW5hbWljT2JzZXJ2YWJsZU9iamVjdCIsInN0cnVjdCIsIkNPTVBVVEVEIiwiQ09NUFVURURfU1RSVUNUIiwiY29tcHV0ZWRBbm5vdGF0aW9uIiwiY29tcHV0ZWRTdHJ1Y3RBbm5vdGF0aW9uIiwiYXJnMSIsIm9wdHMiLCJDb21wdXRlZFZhbHVlIiwiX2dldERlc2NyaXB0b3IkY29uZmlnIiwiX2dldERlc2NyaXB0b3IiLCJjdXJyZW50QWN0aW9uSWQiLCJuZXh0QWN0aW9uSWQiLCJpc0Z1bmN0aW9uTmFtZUNvbmZpZ3VyYWJsZSIsInRtcE5hbWVEZXNjcmlwdG9yIiwiYWN0aW9uTmFtZSIsImV4ZWN1dGVBY3Rpb24iLCJpc01vYnhBY3Rpb24iLCJjYW5SdW5Bc0Rlcml2YXRpb24iLCJzY29wZSIsInJ1bkluZm8iLCJfc3RhcnRBY3Rpb24iLCJlcnIiLCJlcnJvcl8iLCJfZW5kQWN0aW9uIiwibm90aWZ5U3B5XyIsImlzU3B5RW5hYmxlZCIsInN0YXJ0VGltZV8iLCJEYXRlIiwibm93IiwiZmxhdHRlbmVkQXJncyIsInNweVJlcG9ydFN0YXJ0IiwidHlwZSIsIkFDVElPTiIsInByZXZEZXJpdmF0aW9uXyIsInRyYWNraW5nRGVyaXZhdGlvbiIsInJ1bkFzQWN0aW9uIiwicHJldkFsbG93U3RhdGVDaGFuZ2VzXyIsImFsbG93U3RhdGVDaGFuZ2VzIiwidW50cmFja2VkU3RhcnQiLCJhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0IiwicHJldkFsbG93U3RhdGVSZWFkc18iLCJhbGxvd1N0YXRlUmVhZHNTdGFydCIsInJ1bkFzQWN0aW9uXyIsImFjdGlvbklkXyIsInBhcmVudEFjdGlvbklkXyIsInN1cHByZXNzUmVhY3Rpb25FcnJvcnMiLCJhbGxvd1N0YXRlQ2hhbmdlc0VuZCIsImFsbG93U3RhdGVSZWFkc0VuZCIsInVudHJhY2tlZEVuZCIsInNweVJlcG9ydEVuZCIsInRpbWUiLCJwcmV2IiwiX1N5bWJvbCR0b1ByaW1pdGl2ZSIsIkNSRUFURSIsIl9BdG9tIiwibm90aWZ5U3B5IiwiX3RoaXMiLCJoYXNVbnJlcG9ydGVkQ2hhbmdlXyIsImludGVyY2VwdG9yc18iLCJjaGFuZ2VMaXN0ZW5lcnNfIiwidmFsdWVfIiwiZGVoYW5jZXIiLCJzcHlSZXBvcnQiLCJvYnNlcnZhYmxlS2luZCIsImRlYnVnT2JqZWN0TmFtZSIsImRlaGFuY2VWYWx1ZSIsInByZXBhcmVOZXdWYWx1ZV8iLCJVTkNIQU5HRUQiLCJVUERBVEUiLCJzZXROZXdWYWx1ZV8iLCJjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCIsImhhc0ludGVyY2VwdG9ycyIsImNoYW5nZSIsImludGVyY2VwdENoYW5nZSIsImhhc0xpc3RlbmVycyIsIm5vdGlmeUxpc3RlbmVycyIsImludGVyY2VwdF8iLCJoYW5kbGVyIiwicmVnaXN0ZXJJbnRlcmNlcHRvciIsIm9ic2VydmVfIiwiZmlyZUltbWVkaWF0ZWx5IiwicmVnaXN0ZXJMaXN0ZW5lciIsInJhdyIsInRvSlNPTiIsInZhbHVlT2YiLCJpc09ic2VydmFibGVWYWx1ZSIsIl9TeW1ib2wkdG9QcmltaXRpdmUkMSIsImRlcGVuZGVuY2llc1N0YXRlXyIsIm9ic2VydmluZ18iLCJuZXdPYnNlcnZpbmdfIiwicnVuSWRfIiwiVVBfVE9fREFURV8iLCJ1bmJvdW5kRGVwc0NvdW50XyIsIkNhdWdodEV4Y2VwdGlvbiIsInRyaWdnZXJlZEJ5XyIsImlzQ29tcHV0aW5nXyIsImlzUnVubmluZ1NldHRlcl8iLCJzZXR0ZXJfIiwiaXNUcmFjaW5nXyIsIlRyYWNlTW9kZSIsIk5PTkUiLCJzY29wZV8iLCJlcXVhbHNfIiwicmVxdWlyZXNSZWFjdGlvbl8iLCJrZWVwQWxpdmVfIiwiY29tcGFyZVN0cnVjdHVyYWwiLCJjb250ZXh0IiwicmVxdWlyZXNSZWFjdGlvbiIsImtlZXBBbGl2ZSIsIm9uQmVjb21lU3RhbGVfIiwicHJvcGFnYXRlTWF5YmVDaGFuZ2VkIiwiaW5CYXRjaCIsInNpemUiLCJzaG91bGRDb21wdXRlIiwid2FybkFib3V0VW50cmFja2VkUmVhZF8iLCJjb21wdXRlVmFsdWVfIiwicHJldlRyYWNraW5nQ29udGV4dCIsInRyYWNraW5nQ29udGV4dCIsInRyYWNrQW5kQ29tcHV0ZSIsInByb3BhZ2F0ZUNoYW5nZUNvbmZpcm1lZCIsInJlc3VsdCIsImlzQ2F1Z2h0RXhjZXB0aW9uIiwiY2F1c2UiLCJ3YXNTdXNwZW5kZWQiLCJjaGFuZ2VkIiwidHJhY2siLCJ0cmFja0Rlcml2ZWRGdW5jdGlvbiIsImRpc2FibGVFcnJvckJvdW5kYXJpZXMiLCJzdXNwZW5kXyIsImNsZWFyT2JzZXJ2aW5nIiwiY29uc29sZSIsImxvZyIsImZpcnN0VGltZSIsInByZXZWYWx1ZSIsImF1dG9ydW4iLCJwcmV2VSIsImNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvbiIsIndhcm4iLCJpc0NvbXB1dGVkVmFsdWUiLCJTVEFMRV8iLCJQT1NTSUJMWV9TVEFMRV8iLCJwcmV2QWxsb3dTdGF0ZVJlYWRzIiwicHJldlVudHJhY2tlZCIsIm9icyIsImwiLCJjaGFuZ2VEZXBlbmRlbmNpZXNTdGF0ZVRvMCIsImlzQ29tcHV0aW5nRGVyaXZhdGlvbiIsImhhc09ic2VydmVycyIsImVuZm9yY2VBY3Rpb25zIiwiY2hlY2tJZlN0YXRlUmVhZHNBcmVBbGxvd2VkIiwiYWxsb3dTdGF0ZVJlYWRzIiwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb24iLCJmIiwicnVuSWQiLCJwcmV2VHJhY2tpbmciLCJiaW5kRGVwZW5kZW5jaWVzIiwid2FybkFib3V0RGVyaXZhdGlvbldpdGhvdXREZXBlbmRlbmNpZXMiLCJyZXF1aXJlc09ic2VydmFibGVfIiwicmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGUiLCJwcmV2T2JzZXJ2aW5nIiwib2JzZXJ2aW5nIiwibG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlIiwiaTAiLCJkZXAiLCJfZGVwIiwicmVtb3ZlT2JzZXJ2ZXIiLCJfZGVwMiIsImFkZE9ic2VydmVyIiwidW50cmFja2VkIiwiYWN0aW9uIiwicGVyc2lzdGVudEtleXMiLCJNb2JYR2xvYmFscyIsInZlcnNpb24iLCJwZW5kaW5nVW5vYnNlcnZhdGlvbnMiLCJwZW5kaW5nUmVhY3Rpb25zIiwiaXNSdW5uaW5nUmVhY3Rpb25zIiwic3B5TGlzdGVuZXJzIiwiZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzIiwiY2FuTWVyZ2VHbG9iYWxTdGF0ZSIsImlzb2xhdGVDYWxsZWQiLCJfX21vYnhJbnN0YW5jZUNvdW50IiwiX19tb2J4R2xvYmFscyIsInNldFRpbWVvdXQiLCJpc29sYXRlR2xvYmFsU3RhdGUiLCJnZXRHbG9iYWxTdGF0ZSIsInJlc2V0R2xvYmFsU3RhdGUiLCJkZWZhdWx0R2xvYmFscyIsImluZGV4T2YiLCJnZXRPYnNlcnZlcnMiLCJub2RlIiwiYWRkIiwicXVldWVGb3JVbm9ic2VydmF0aW9uIiwicHVzaCIsInJ1blJlYWN0aW9ucyIsImxpc3QiLCJkIiwibG9nVHJhY2VJbmZvIiwiQlJFQUsiLCJsaW5lcyIsInByaW50RGVwVHJlZSIsImdldERlcGVuZGVuY3lUcmVlIiwiRnVuY3Rpb24iLCJyZXBsYWNlIiwidHJlZSIsImRlcHRoIiwicmVwZWF0IiwiZGVwZW5kZW5jaWVzIiwiY2hpbGQiLCJSZWFjdGlvbiIsIm9uSW52YWxpZGF0ZV8iLCJlcnJvckhhbmRsZXJfIiwiaXNEaXNwb3NlZF8iLCJpc1NjaGVkdWxlZF8iLCJpc1RyYWNrUGVuZGluZ18iLCJpc1J1bm5pbmdfIiwic2NoZWR1bGVfIiwiaXNTY2hlZHVsZWQiLCJydW5SZWFjdGlvbl8iLCJyZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fIiwibm90aWZ5Iiwic3RhcnRUaW1lIiwicHJldlJlYWN0aW9uIiwibWVzc2FnZSIsImRpc3Bvc2UiLCJnZXREaXNwb3Nlcl8iLCJyIiwidHJhY2UiLCJ0cmFjZSQxIiwiZW50ZXJCcmVha1BvaW50Iiwib25SZWFjdGlvbkVycm9yIiwiaWR4Iiwic3BsaWNlIiwiTUFYX1JFQUNUSU9OX0lURVJBVElPTlMiLCJyZWFjdGlvblNjaGVkdWxlciIsInJ1blJlYWN0aW9uc0hlbHBlciIsImFsbFJlYWN0aW9ucyIsIml0ZXJhdGlvbnMiLCJyZW1haW5pbmdSZWFjdGlvbnMiLCJpc1JlYWN0aW9uIiwic2V0UmVhY3Rpb25TY2hlZHVsZXIiLCJiYXNlU2NoZWR1bGVyIiwiZXZlbnQiLCJsaXN0ZW5lcnMiLCJFTkRfRVZFTlQiLCJzcHkiLCJBQ1RJT05fQk9VTkQiLCJBVVRPQUNUSU9OIiwiQVVUT0FDVElPTl9CT1VORCIsIkRFRkFVTFRfQUNUSU9OX05BTUUiLCJhY3Rpb25Cb3VuZEFubm90YXRpb24iLCJhdXRvQWN0aW9uQW5ub3RhdGlvbiIsImF1dG9BY3Rpb25Cb3VuZEFubm90YXRpb24iLCJjcmVhdGVBY3Rpb25GYWN0b3J5IiwicnVuSW5BY3Rpb24iLCJ2aWV3IiwiX29wdHMkbmFtZSIsIl9vcHRzIiwicnVuU3luYyIsInNjaGVkdWxlciIsImRlbGF5IiwicmVhY3Rpb24iLCJyZWFjdGlvblJ1bm5lciIsIm9uRXJyb3IiLCJyZXF1aXJlc09ic2VydmFibGUiLCJjcmVhdGVTY2hlZHVsZXJGcm9tT3B0aW9ucyIsInJ1biIsImV4cHJlc3Npb24iLCJlZmZlY3QiLCJfb3B0cyRuYW1lMiIsImVmZmVjdEFjdGlvbiIsIndyYXBFcnJvckhhbmRsZXIiLCJuZXh0VmFsdWUiLCJlcnJvckhhbmRsZXIiLCJiYXNlRm4iLCJPTl9CRUNPTUVfT0JTRVJWRUQiLCJPTl9CRUNPTUVfVU5PQlNFUlZFRCIsImludGVyY2VwdEhvb2siLCJob29rIiwiZ2V0QXRvbSIsImNiIiwibGlzdGVuZXJzS2V5IiwiaG9va0xpc3RlbmVycyIsIk5FVkVSIiwiQUxXQVlTIiwiT0JTRVJWRUQiLCJjb25maWd1cmUiLCJlYSIsInByb3BlcnRpZXMiLCJhbm5vdGF0aW9ucyIsImRlc2NyaXB0b3JzIiwibm9kZVRvRGVwZW5kZW5jeVRyZWUiLCJ1bmlxdWUiLCJnZXRPYnNlcnZlclRyZWUiLCJub2RlVG9PYnNlcnZlclRyZWUiLCJvYnNlcnZlcnMiLCJnZW5lcmF0b3JJZCIsIkZsb3dDYW5jZWxsYXRpb25FcnJvciIsImlzRmxvd0NhbmNlbGxhdGlvbkVycm9yIiwiZmxvd0JvdW5kQW5ub3RhdGlvbiIsImdlbmVyYXRvciIsImN0eCIsImdlbiIsInJlamVjdG9yIiwicGVuZGluZ1Byb21pc2UiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzdGVwSWQiLCJvbkZ1bGZpbGxlZCIsInJldCIsIm9uUmVqZWN0ZWQiLCJ0aGVuIiwiY2FuY2VsIiwiY2FuY2VsUHJvbWlzZSIsIl9yZXMiLCJ5aWVsZGVkUHJvbWlzZSIsImZsb3dSZXN1bHQiLCJpbnRlcmNlcHRSZWFkcyIsInByb3BPckhhbmRsZXIiLCJnZXRBZG1pbmlzdHJhdGlvbiIsImludGVyY2VwdCIsImludGVyY2VwdFByb3BlcnR5IiwiaW50ZXJjZXB0SW50ZXJjZXB0YWJsZSIsIl9pc0NvbXB1dGVkIiwidmFsdWVzXyIsImhhcyIsImlzQ29tcHV0ZWQiLCJpc0NvbXB1dGVkUHJvcCIsIl9pc09ic2VydmFibGUiLCJpc09ic2VydmFibGVQcm9wIiwia2V5c18iLCJ2YWx1ZXMiLCJlbnRyaWVzIiwiX3ZhbHVlcyIsInNldF8iLCJwYXJzZUludCIsInJlbW92ZSIsImRlbGV0ZV8iLCJoYXNfIiwiZ2V0XyIsImFwaURlZmluZVByb3BlcnR5IiwiYXBpT3duS2V5cyIsIm93bktleXNfIiwib2JzZXJ2ZSIsInByb3BPckNiIiwiY2JPckZpcmUiLCJvYnNlcnZlT2JzZXJ2YWJsZVByb3BlcnR5Iiwib2JzZXJ2ZU9ic2VydmFibGUiLCJjYWNoZSIsInRvSlNIZWxwZXIiLCJfX2FscmVhZHlTZWVuIiwiX3JlczIiLCJfcmVzMyIsInRvSlMiLCJwb3AiLCJnZXRBdG9tRnJvbUFyZ3MiLCJMT0ciLCJ0cmFuc2FjdGlvbiIsInRoaXNBcmciLCJ3aGVuIiwicHJlZGljYXRlIiwid2hlblByb21pc2UiLCJfd2hlbiIsInRpbWVvdXRIYW5kbGUiLCJ0aW1lb3V0IiwiZGlzcG9zZXIiLCJjb25kIiwiY2xlYXJUaW1lb3V0IiwiX29wdHMkc2lnbmFsIiwic2lnbmFsIiwiYWJvcnRlZCIsImFib3J0IiwiX29wdHMkc2lnbmFsMiIsImFkZEV2ZW50TGlzdGVuZXIiLCJfb3B0cyRzaWduYWwzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImdldEFkbSIsIm9iamVjdFByb3h5VHJhcHMiLCJfZ2V0QWRtJHNldF8iLCJkZWxldGVQcm9wZXJ0eSIsIl9nZXRBZG0kZGVsZXRlXyIsIl9nZXRBZG0kZGVmaW5lUHJvcGVydCIsInByZXZlbnRFeHRlbnNpb25zIiwiX3RhcmdldCQkbW9ieCIsIl90YXJnZXQkJG1vYngkcHJveHlfIiwiaW50ZXJjZXB0YWJsZSIsImludGVyY2VwdG9ycyIsImxpc3RlbmFibGUiLCJtYWtlT2JzZXJ2YWJsZSIsIl9hbm5vdGF0aW9ucyIsImtleXNTeW1ib2wiLCJtYWtlQXV0b09ic2VydmFibGUiLCJvdmVycmlkZXMiLCJTUExJQ0UiLCJNQVhfU1BMSUNFX1NJWkUiLCJhcnJheVRyYXBzIiwiZ2V0QXJyYXlMZW5ndGhfIiwiaXNOYU4iLCJhcnJheUV4dGVuc2lvbnMiLCJzZXRBcnJheUxlbmd0aF8iLCJPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbiIsIm93bmVkXyIsImxlZ2FjeU1vZGVfIiwiYXRvbV8iLCJlbmhhbmNlcl8iLCJsYXN0S25vd25MZW5ndGhfIiwibmV3ViIsIm9sZFYiLCJkZWhhbmNlVmFsdWVfIiwiZGVoYW5jZVZhbHVlc18iLCJhZGRlZCIsImFkZGVkQ291bnQiLCJyZW1vdmVkIiwicmVtb3ZlZENvdW50IiwibmV3TGVuZ3RoIiwiY3VycmVudExlbmd0aCIsIm5ld0l0ZW1zIiwic3BsaWNlV2l0aEFycmF5XyIsInVwZGF0ZUFycmF5TGVuZ3RoXyIsIm9sZExlbmd0aCIsImRlbHRhIiwicmVzZXJ2ZUFycmF5QnVmZmVyIiwiZGVsZXRlQ291bnQiLCJNYXRoIiwibWF4IiwibWluIiwibGVuZ3RoRGVsdGEiLCJzcGxpY2VJdGVtc0ludG9WYWx1ZXNfIiwibm90aWZ5QXJyYXlTcGxpY2VfIiwiX3RoaXMkdmFsdWVzXyIsIm9sZEl0ZW1zIiwiX2kiLCJub3RpZnlBcnJheUNoaWxkVXBkYXRlXyIsIm93bmVkIiwiY2xlYXIiLCJzcGxpY2VXaXRoQXJyYXkiLCJfbGVuMiIsIml0ZW1zIiwiX2tleTIiLCJzaGlmdCIsInVuc2hpZnQiLCJfbGVuMyIsIl9rZXkzIiwicmV2ZXJzZSIsInNvcnQiLCJjb3B5IiwiYWRkQXJyYXlFeHRlbnNpb24iLCJzaW1wbGVGdW5jIiwibWFwTGlrZUZ1bmMiLCJyZWR1Y2VMaWtlRnVuYyIsImZ1bmNOYW1lIiwiZnVuY0ZhY3RvcnkiLCJkZWhhbmNlZFZhbHVlcyIsImNhbGxiYWNrIiwiX3RoaXMyIiwiZWxlbWVudCIsIl90aGlzMyIsImFjY3VtdWxhdG9yIiwiY3VycmVudFZhbHVlIiwiaXNPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbiIsIl9TeW1ib2wkaXRlcmF0b3IiLCJfU3ltYm9sJHRvU3RyaW5nVGFnIiwiT2JzZXJ2YWJsZU1hcE1hcmtlciIsIkFERCIsIkRFTEVURSIsInRvU3RyaW5nVGFnIiwiaW5pdGlhbERhdGEiLCJkYXRhXyIsImhhc01hcF8iLCJrZXlzQXRvbV8iLCJtZXJnZSIsImVudHJ5IiwibmV3RW50cnkiLCJoYXNLZXkiLCJ1cGRhdGVWYWx1ZV8iLCJhZGRWYWx1ZV8iLCJfZGVsZXRlIiwiX2NoYW5nZSIsIl90aGlzMyRoYXNNYXBfJGdldCIsIl90aGlzNCIsIl90aGlzNCRoYXNNYXBfJGdldCIsIm1ha2VJdGVyYWJsZSIsIl9rZXlzJG5leHQiLCJfa2V5cyRuZXh0MiIsIl9pdGVyYXRvciIsIl9zdGVwIiwiX3N0ZXAkdmFsdWUiLCJfdGhpczUiLCJfdGhpczYiLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwiX3RoaXM3IiwicmVwbGFjZW1lbnRNYXAiLCJjb252ZXJ0VG9NYXAiLCJvcmRlcmVkRGF0YSIsImtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkIiwiX2l0ZXJhdG9yMyIsIl9zdGVwMyIsImRlbGV0ZWQiLCJfaXRlcmF0b3I0IiwiX3N0ZXA0IiwiX3N0ZXA0JHZhbHVlIiwiX3ZhbHVlIiwia2V5RXhpc3RlZCIsIl92YWx1ZTIiLCJpdGVyMSIsIml0ZXIyIiwibmV4dDEiLCJuZXh0MiIsIl9TeW1ib2wkaXRlcmF0b3IkMSIsIl9TeW1ib2wkdG9TdHJpbmdUYWckMSIsIk9ic2VydmFibGVTZXRNYXJrZXIiLCJjYWxsYmFja0ZuIiwiX2NoYW5nZTIiLCJuZXh0SW5kZXgiLCJvYnNlcnZhYmxlVmFsdWVzIiwiZGVzY3JpcHRvckNhY2hlIiwiUkVNT1ZFIiwiT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uIiwiZGVmYXVsdEFubm90YXRpb25fIiwicGVuZGluZ0tleXNfIiwiaXNBbm5vdGF0aW9uIiwiZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8iLCJzZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyIsImFzc2VydEFubm90YWJsZSIsIl90aGlzJHRhcmdldF8kc3RvcmVkQSIsIm91dGNvbWUiLCJyZWNvcmRBbm5vdGF0aW9uQXBwbGllZCIsImRlbGV0ZU91dGNvbWUiLCJub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyIsImNhY2hlZERlc2NyaXB0b3IiLCJnZXRDYWNoZWRPYnNlcnZhYmxlUHJvcERlc2NyaXB0b3IiLCJfdGhpcyRwZW5kaW5nS2V5c18iLCJfdGhpcyRwZW5kaW5nS2V5c18kZ2UiLCJfdGhpcyRwZW5kaW5nS2V5c18yIiwiX3RoaXMkcGVuZGluZ0tleXNfMiRnIiwiX29wdGlvbnMkbmFtZSIsImdldERlYnVnTmFtZSIsImlzRXh0ZW5zaWJsZSIsImlzT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uIiwiX2FkbSR0YXJnZXRfJHN0b3JlZEFuIiwiRU5UUllfMCIsImNyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yIiwiT0JTRVJWQUJMRV9BUlJBWV9CVUZGRVJfU0laRSIsIlN0dWJBcnJheSIsImluaGVyaXQiLCJjdG9yIiwiTGVnYWN5T2JzZXJ2YWJsZUFycmF5IiwiX1N0dWJBcnJheSIsImFycmF5cyIsImNyZWF0ZUFycmF5QnVmZmVySXRlbSIsIl9vYnNlcnZhYmxlIiwibmFtZWQiLCJlcSIsImFTdGFjayIsImJTdGFjayIsImNsYXNzTmFtZSIsInVud3JhcCIsImFyZUFycmF5cyIsImFDdG9yIiwiYkN0b3IiLCJnZXRTZWxmIiwibSIsImciLCJfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImluamVjdE1vYngiLCJleHRyYXMiLCJfYWxsb3dTdGF0ZUNoYW5nZXMiLCJfYWxsb3dTdGF0ZUNoYW5nZXNJbnNpZGVDb21wdXRlZCIsIl9hbGxvd1N0YXRlUmVhZHNFbmQiLCJfYWxsb3dTdGF0ZVJlYWRzU3RhcnQiLCJfYXV0b0FjdGlvbiIsIl9nZXRBZG1pbmlzdHJhdGlvbiIsIl9nZXRHbG9iYWxTdGF0ZSIsIl9pbnRlcmNlcHRSZWFkcyIsIl9pc0NvbXB1dGluZ0Rlcml2YXRpb24iLCJfcmVzZXRHbG9iYWxTdGF0ZSIsImlzQm94ZWRPYnNlcnZhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mobx/dist/mobx.esm.js\n");

/***/ })

};
;